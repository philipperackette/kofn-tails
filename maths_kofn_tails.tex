\documentclass[12pt,a4paper]{article}

% ============================
% Encodage, langue, mise en page
% ============================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

\usepackage{geometry}
\geometry{margin=1.9cm}

% ============================
% Maths et mise en forme
% ============================
\usepackage{amsmath,amssymb,amsthm,mathtools}
%\usepackage{amsmath} % si pas déjà là

\usepackage{bm}
\usepackage{mathrsfs}
\usepackage{enumitem}
\usepackage{array}
\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning}
\usepackage{hyperref}
\usepackage{url}
\usepackage{thmtools}

% Supprimer l'indentation de tous les paragraphes
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.5em}  % Espacement entre paragraphes

% ============================
% Environnements mathématiques
% ============================
\numberwithin{equation}{section}

% Style pour les environnements (sans italique)
\theoremstyle{definition}
\newtheorem{theorem}{Théorème}[section]
\newtheorem{lemma}[theorem]{Lemme}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollaire}
\newtheorem{definition}[theorem]{Définition}
\newtheorem{propriete}[theorem]{Propriété}
\newtheorem{remark}[theorem]{Remarque}
\newtheorem{example}[theorem]{Exemple}

% ============================
% Raccourcis usuels
% ============================
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\F}{\mathbb{F}}

\newcommand{\Ell}{\mathscr{E}}
\newcommand{\bin}{\{0,1\}}
\newcommand{\concat}{\,\Vert\,}
\newcommand{\xor}{\oplus}

% Macros pour éviter les problèmes de crochets dans les arguments optionnels
\newcommand{\FdeuxX}{\F_2[X]}  % F_2[X]
\newcommand{\FdeuxQuot}{\F_2[X]/(X^2+X+1)}  % F_2[X]/(X^2+X+1)
\newcommand{\Kpolys}{\mathbb{K}[X]}  % Anneau de polynômes

\DeclareMathOperator{\HKDF}{HKDF}
\DeclareMathOperator{\PBKDF}{PBKDF2}
\DeclareMathOperator{\HMAC}{HMAC}
\DeclareMathOperator{\AESGCM}{AES-GCM}
\DeclareMathOperator{\RSAOAEP}{RSA-OAEP}
\DeclareMathOperator{\MGF}{MGF1}
\DeclareMathOperator{\ord}{ord}

% ============================
% Métadonnées
% ============================
\title{\textbf{Contrôle distribué du pouvoir de signature et de déchiffrement dans un environnement sécurisé\\[0.5em]
\large Implémentation \texttt{Python} clé en main et étude mathématique}}
\author{Philippe Rackette}
\date{\centering\today}

% ============================
\begin{document}
\maketitle

\vfill
\begin{center}
  \includegraphics[width=0.6\textwidth]{cover_image.png}
\end{center}
\vfill

\newpage

\begin{abstract}
Ce texte formalise, dans un cadre mathématique, le schéma de partage
de secret de Shamir ($k$ sur $n$)~\cite{shamir1979share} mis en \oe uvre par la procédure \textit{k of n Tails} pour la gestion d'un secret maître. Cette \textbf{procédure autonome complète et directement opérationnelle sous Tails OS\footnote{\href{https://tails.net/}{Tails} est développé par le \href{https://www.torproject.org/}{Projet Tor}.}} est donnée par le fichier \texttt{procedure\_kofn\_tails\_v1.html} du dépôt~\cite{git-hub}.
La version de référence de cette procédure est identifiée par le hachage
SHA\mbox{-}256 suivant\footnote{La signature OpenPGP de ce fichier doit être vérifiée à l'aide de la clé publique~\cite{rackette-pgp} présente dans~\cite{git-hub}.} :
\begin{center}
  \texttt{ed223dd055108b0c08cd6d7b3011962d5bdc5f92dd38760c5c6a202982fcde84}.
\end{center}

\medskip\noindent
Le protocole repose sur les briques cryptographiques suivantes :
\begin{itemize}[leftmargin=2em]
  \item le partage de secret de Shamir~\cite{shamir1979share} sur un corps fini pour répartir un secret maître $S$ selon un seuil $k$ sur $n$~;
  \item la dérivation de clés symétriques à partir de $S$ et de mots de passe par \textbf{HKDF} (\textit{HMAC-based Key Derivation Function})~\cite{rfc5869} et \textbf{PBKDF2} (\textit{Password-Based Key Derivation Function 2})~\cite{rfc8018}~;
  \item une clé de signature \textbf{Ed25519} (\textit{Edwards-curve Digital Signature Algorithm})~\cite{rfc8032} dérivée de $S$ (schéma de signature sur courbe elliptique)~;
  \item un chiffrement hybride \textbf{RSA-4096} (\textit{Rivest Shamir Adleman})/\textbf{AES-256-GCM} (\textit{Advanced Encryption Standard in Galois/Counter Mode})~\cite{rfc8017,fips197,nist-sp800-38d} pour les fichiers destinés aux membres du groupe $k$ sur $n$~; la clé RSA privée est elle-même chiffrée par AES-256-GCM à partir de~$S$.
\end{itemize}

Nous détaillons, pour chaque type d'objet manipulé, les garanties effectives
en termes de confidentialité, d'intégrité et d'authenticité :
\begin{itemize}[leftmargin=2em]
  \item \textbf{Parts de secret} : confidentialité et intégrité assurées par AES-GCM avec une clé dérivée du mot de passe du porteur (PBKDF2)~;
  \item \textbf{Signatures de fichiers} : intégrité et authenticité cryptographiques assurées par Ed25519 à partir de la clé dérivée de $S$~;
  \item \textbf{Fichiers chiffrés hybrides RSA--AES} : confidentialité et intégrité du contenu assurées par AES-GCM~; l'authenticité de la \emph{source} n'est en revanche pas garantie en l'absence de signature dédiée~;
  \item \textbf{Clés publiques} : leur authenticité doit être vérifiée par des canaux hors bande (vérification humaine, échange préalable sur canal sécurisé, etc.).
\end{itemize}

Les objets sont d'abord définis dans leur structure algébrique naturelle
(corps finis, groupes, espaces de clés), puis mis en correspondance explicite
avec les formats de fichiers et les scripts décrits dans
\texttt{procedure\_kofn\_tails\_v1.html}, afin d'assurer une traçabilité complète
entre le modèle mathématique et la mise en \oe uvre opérationnelle.
Dans toute la suite, l'expression \og procédure Tails\fg{} désigne ce document
HTML identifié par l'empreinte SHA\mbox{-}256 ci-dessus. Ce texte fournit ainsi
à la fois une preuve mathématique rigoureuse du schéma et une spécification
directement alignée sur l'implémentation \texttt{Python} fournie.
\end{abstract}

\newpage
\tableofcontents

%=========================================================

%=========================================================
\section*{Table des notations}
\addcontentsline{toc}{section}{Table des notations}

\begin{center}
\footnotesize
\renewcommand{\arraystretch}{1.1}
\begin{tabular}{>{$}l<{$} p{0.8\textwidth}}
\toprule
\bin^t & Mots binaires de longueur $t$ \\
\bin^* & Mots binaires de longueur finie (union sur $t\ge 0$) \\
\lVert x\rVert & Longueur en bits de $x\in\bin^*$ \\
x\concat y & Concaténation de mots binaires \\
x\xor y & XOR bit-à-bit ($x,y$ de même longueur) \\
\gcd(a,b) & Plus grand commun diviseur de $a$ et $b$ \\
\ord(x)   & Ordre de l'élément $x$ dans un groupe (plus petit $k \ge 1$ tel que $x^k = e$) \\
\mathrm{val}_{\mathrm{be}}(b) & Encodage big-endian $b\in\bin^t \to \{0,\dots,2^t-1\}$ \\
\mathrm{val}_{\mathrm{le}}(b) & Encodage little-endian $b\in\bin^t \to \{0,\dots,2^t-1\}$ \\
S \in \bin^{256} & Secret maître (32 octets) \\
s_0 & Entier $\mathrm{val}_{\mathrm{be}}(S)\in\{0,\dots,2^{256}-1\}$ \\
P = 2^{521} - 1 & Premier de Mersenne, cardinal de $\F_P$ \\
\F_P & Corps fini à $P$ éléments \\
\F_P[X] & Polynômes à coefficients dans $\F_P$ \\
\mathcal{P}_{<k} & Polynômes de degré $<k$ dans $\F_P[X]$ \\
(x_i,y_i) & Part de Shamir du participant $i$ ($\in\F_P^2$) \\
q = 2^{255} - 19 & Cardinal du corps de base de Ed25519 \\
E(\F_q) & Groupe des points de la courbe elliptique \\
B \in E(\F_q) & Point de base d'ordre premier $\ell$ \\
\ell & Ordre premier de $B$ ($\approx 2^{252}$) \\
\Z_\ell & Groupe additif cyclique $(\{0,\dots,\ell-1\}, + \bmod \ell)$ \\
a \in \Z_\ell & Clé privée Ed25519 \\
A = aB & Clé publique Ed25519 \\
(n,e,d) & Paramètres RSA : module, exposants public/privé \\
h & Fonction de hachage $h:\bin^* \to \bin^d$ \\
\HMAC_h & MAC HMAC basé sur $h$ (avec $h$ fonction de hachage sous-jacente) \\
\HKDF_h & Dérivation de clé HKDF (RFC 5869) basée sur $h$ \\
\PBKDF_h & Dérivation par mot de passe (PBKDF2, RFC 8018) basée sur $h$ \\
\MGF_h & Génération de masque MGF1 (RFC 8017) basée sur $h$ \\
\RSAOAEP & RSA avec rembourrage OAEP (RFC 8017) \\
\AESGCM_K & AES-GCM sous clé symétrique $K$ \\
\mathrm{IKM} & Input Keying Material (ici $S$) \\
\mathrm{saltEd} & Sel HKDF constant pour $K_{\mathrm{Ed}}$ \\
W & Sel HKDF aléatoire par cérémonie pour $K_{\mathrm{RSA}}$ \\
\mathrm{info}_{\mathrm{Ed}} & Contexte HKDF pour Ed25519 \\
\mathrm{info}_{\mathrm{RSA}} & Contexte HKDF pour RSA \\
P_i & Mot de passe du participant $i$ \\
S_i & Sel PBKDF2 individuel \\
K_i & Clé symétrique pour chiffrer la part $i$ \\
K_{\mathrm{Ed}} & Graine Ed25519 dérivée de $S$ \\
K_{\mathrm{RSA}} & Clé symétrique AES-256 (dérivée de $S$ par HKDF) pour chiffrer la clé privée RSA \\
K_{\mathrm{AES}} & Clé AES-256 éphémère (clé de session, générée aléatoirement pour chaque chiffrement hybride) \\
N,\,N_i & Nonces AES-GCM \\
\perp & Symbole d'échec/rejet \\
\bottomrule
\end{tabular}
\end{center}

\newpage

%=========================================================



%=========================================================
\section{Cadre algébrique de base}

\subsection{Préambule et motivation}

Cette section rassemble les notions d'algèbre et d'arithmétique modulaire utilisées dans la suite du document : 
\begin{itemize}
  \item L'\textbf{arithmétique modulaire} (entiers, pgcd, inverses) définit le socle concret pour l'anneau $\Z/n\Z$ et prépare le corps $\F_p = \Z/p\Z$.
  \item Les \textbf{théorèmes d'isomorphisme} généralisent ces structures, s'appuyant sur des exemples concrets.
  \item Les \textbf{corps finis et extensions} s'appuient sur les deux précédents (utilisation des isomorphismes pour l'unicité de $\F_p$).
  \item Les \textbf{mots binaires et encodages} formalisent la conversion vers les représentations informatiques.
\end{itemize}

\subsection{Arithmétique modulaire et groupe multiplicatif $(\Z/n\Z)^\times$}


\begin{theorem}[Identité de Bézout (lemme de Bachet-Bézout)]
\label{thm:bezout}
Soient $a, b \in \Z$ deux entiers non tous les deux nuls. Il existe $u, v \in \Z$ tels que :
\[
au + bv = \gcd(a, b)
\]
\end{theorem}

\begin{proof}
Soit $d = \gcd(a, b)$. Considérons l'ensemble :
\[
S = \{ax + by \mid x, y \in \Z \text{ et } ax + by > 0\}
\]

\medskip

\noindent\textbf{L'ensemble $S$ est non vide.} 
Puisque $a$ et $b$ ne sont pas tous deux nuls, au moins l'un des nombres $|a|$ ou $|b|$ est strictement positif. 
Ainsi, si $a \neq 0$, alors $a\cdot 1 + b\cdot 0 = |a| > 0$, donc $|a| \in S$ ; 
si $b \neq 0$, alors $a\cdot 0 + b\cdot 1 = |b| > 0$, donc $|b| \in S$.

\medskip

\noindent\textbf{Soit $m$ le plus petit élément de $S$.} 
Par le principe du bon ordre (l'ensemble des entiers positifs est bien ordonné, donc tout sous-ensemble non vide d'entiers positifs possède un plus petit élément), 
$S$ a un plus petit élément que nous notons $m$. Par définition de $S$, il existe $u_0, v_0 \in \Z$ tels que :
\[
m = au_0 + bv_0 > 0.
\]

\medskip

\noindent\textbf{$m$ divise $a$ et $b$.} 
Effectuons la division euclidienne de $a$ par $m$ : $a = mq + r$ avec $0 \le r < m$.
Alors :
\[
r = a - mq = a - (au_0 + bv_0)q = a(1 - u_0q) + b(-v_0q).
\]
Si $r > 0$, alors $r \in S$ et $r < m$, ce qui contredit la minimalité de $m$. Donc $r = 0$, et $m$ divise $a$.
De même, en divisant $b$ par $m$, on montre que $m$ divise $b$.

\medskip

\noindent\textbf{$m$ est le plus grand diviseur commun.} 
Puisque $m$ divise $a$ et $b$, et que $m = au_0 + bv_0$, tout diviseur commun de $a$ et $b$ divise aussi $m$.
En effet, si $d'$ divise $a$ et $b$, alors $a = d'a'$ et $b = d'b'$, donc :
\[
m = d'a'u_0 + d'b'v_0 = d'(a'u_0 + b'v_0),
\]
et $d'$ divise $m$.

En particulier, $d = \gcd(a, b)$ divise $m$. Mais puisque $m$ divise $a$ et $b$, et que $d$ est le plus grand diviseur commun (au sens de la divisibilité), on a $m \le d$. Comme $d$ divise $m$, on a aussi $d \le m$. Donc $m = d$.

\medskip

\noindent\textbf{Conclusion.} 
Nous avons montré que le plus petit élément positif $m$ de $S$ est égal à $\gcd(a, b)$, et qu'il s'écrit $m = au_0 + bv_0$ pour certains $u_0, v_0 \in \Z$.
Ainsi, $\gcd(a, b) = au_0 + bv_0$.
\end{proof}


\begin{remark}[Nombres premiers entre eux]
Deux entiers $a$ et $b$ sont dits \emph{premiers entre eux} (ou \emph{copremiers}) si et seulement si $\gcd(a, b) = 1$. Cette propriété est fondamentale pour l'inversibilité modulo $n$ et pour les théorèmes d'Euler et de Fermat.
\end{remark}

\begin{theorem}[Théorème de Gauss (lemme d'Euclide)]
\label{thm:gauss-div}
Soient $a, b, c$ des entiers. Si $a$ et $b$ sont premiers entre eux et $a$ divise $bc$, alors $a$ divise $c$.
\end{theorem}

\begin{proof}
Puisque $\gcd(a,b) = 1$, par l'identité de Bézout, il existe des entiers $u,v$ tels que :
\[
au + bv = 1
\]
Multiplions cette égalité par $c$ :
\[
auc + bvc = c
\]
Par hypothèse, $a$ divise $bc$, donc $a$ divise $bvc$. De plus, $a$ divise évidemment $auc$. Donc $a$ divise la somme $auc + bvc = c$.
\end{proof}

\begin{definition}[Anneau $\Z/n\Z$ et groupe multiplicatif $(\Z/n\Z)^\times$]\label{def:Zmodn}
Soit $n \in \N^*$. On note $\Z/n\Z$ l'ensemble des classes de congruence modulo $n$,
que l'on identifie à $\{0,1,\dots,n-1\}$.
On munit $\Z/n\Z$ des opérations
\[
\bar a + \bar b = \overline{a+b}, \qquad
\bar a \cdot \bar b = \overline{ab},
\]
c'est-à-dire de l'addition et de la multiplication modulo $n$.

\end{definition}

\begin{proposition}\label{prop:Zmodn-anneau}
Les opérations $+$ et $\cdot$ ainsi définies sont bien définies sur $\Z/n\Z$
(c'est-à-dire ne dépendent pas du représentant choisi dans la classe),
et $(\Z/n\Z, +, \cdot)$ est un anneau commutatif unitaire.
\end{proposition}

\begin{proof}
Soient $a,a',b,b' \in \Z$ tels que $a \equiv a' \pmod n$ et $b \equiv b' \pmod n$.
Alors $n \mid (a-a')$ et $n \mid (b-b')$, donc
\[
(a+b) - (a'+b') = (a-a') + (b-b') \equiv 0 \pmod n,
\]
et
\[
ab - a'b' = a(b-b') + b'(a-a') \equiv 0 \pmod n.
\]
Ainsi $a+b \equiv a'+b' \pmod n$ et $ab \equiv a'b' \pmod n$, ce qui montre
que les lois $+$ et $\cdot$ ne dépendent pas du choix des représentants :
elles sont bien définies sur les classes.

Les axiomes d'anneau (associativité, commutativité de $+$, distributivité,
existence d'un neutre $0 = \bar 0$ et d'opposés, existence d'un neutre
multiplicatif $1 = \bar 1$) se déduisent alors directement de ceux de $\Z$,
dont $\Z/n\Z$ est un quotient. On en conclut que $(\Z/n\Z,+,\cdot)$ est
un anneau commutatif unitaire.
\end{proof}


\begin{proposition}[Critère d'inversibilité modulo $n$]\label{prop:inv_mod_n}
Soit $a \in \{0,1,\dots,n-1\}$.  
La classe $\bar a \in \Z/n\Z$ est inversible dans $\Z/n\Z$ si et seulement si $\gcd(a,n)=1$.
En particulier,
\[
  (\Z/n\Z)^\times
  = \{\bar a \in \Z/n\Z \mid \gcd(a,n)=1\}
  \simeq \{a \in \{0,1,\dots,n-1\} \mid \gcd(a,n)=1\}.
\]
\end{proposition}

\begin{proof}
Si $\gcd(a,n)=1$, alors par l'identité de Bézout, il existe $u,v \in \Z$ tels que
\[
au + nv = 1.
\]
En réduisant modulo $n$, on obtient $au \equiv 1 \pmod n$, donc la classe $\bar a$ est inversible,
d'inverse $\bar u$.

Réciproquement, si $\bar a$ est inversible, il existe $b \in \Z$ tel que
\[
ab \equiv 1 \pmod n,
\]
c'est-à-dire $ab - kn = 1$ pour un certain $k \in \Z$. Tout diviseur commun de $a$ et $n$
divise alors $1$, donc $\gcd(a,n)=1$.
\end{proof}
\begin{definition}[Groupe multiplicatif $(\Z/n\Z)^\times$]\label{def:multgrpZnZ}
Le groupe multiplicatif modulo $n$ est l'ensemble des éléments inversibles de $\Z/n\Z$ :
\[
(\Z/n\Z)^\times = \{\bar a \in \Z/n\Z \mid \gcd(a,n)=1\}.
\]
\end{definition}



\begin{definition}[Indicatrice d'Euler]
L'indicatrice d'Euler $\varphi(n)$ est définie pour tout entier $n \geq 1$ comme le nombre d'entiers compris entre $1$ et $n$ qui sont premiers avec $n$ :
\[
\varphi(n) = \#\{k \in \{1, 2, \dots, n\} \mid \gcd(k, n) = 1\}
\]
\end{definition}

\begin{proposition}[Valeur de $\varphi(n)$ pour $n = pq$]
\label{prop:phi-pq}
Si $p$ et $q$ sont deux nombres premiers distincts et $n = pq$, alors :
\[
\varphi(n) = (p-1)(q-1)
\]
\end{proposition}

\begin{proof}
Parmi les $n = pq$ entiers de $1$ à $n$, les entiers qui ne sont pas premiers avec $n$ sont :
\begin{itemize}
\item Les multiples de $p$ : $p, 2p, 3p, \dots, qp$ $\to$ il y en a $q$
\item Les multiples de $q$ : $q, 2q, 3q, \dots, pq$ $\to$ il y en a $p$
\end{itemize}
L'entier $pq$ a été compté deux fois. Par le principe d'inclusion-exclusion :
\[
\varphi(n) = n - q - p + 1 = pq - p - q + 1 = (p-1)(q-1)
\]
\end{proof}




\begin{theorem}[Théorème de Lagrange pour les groupes finis]
\label{thm:lagrange-groupes}
Soit \( G \) un groupe fini et \( H \) un sous-groupe de \( G \). Alors le cardinal de \( H \) divise le cardinal de \( G \) :
\[
|H| \ \big|\ |G|.
\]
En particulier, pour tout \( g \in G \), l'ordre de \( g \) (défini comme le plus petit entier \( d > 0 \) tel que \( g^d = e \)) divise le cardinal de \( G \).
\end{theorem}

\begin{proof}
La démonstration se décompose en trois parties distinctes.

\paragraph{1. Relation d'équivalence et classes à gauche}
Pour exploiter la structure de groupe, on définit une relation \(\sim\) sur \( G \) par :
\[
x \sim y \quad \Longleftrightarrow \quad x^{-1}y \in H.
\]
On vérifie aisément qu'il s'agit d'une relation d'équivalence :
\begin{itemize}
  \item \textbf{Réflexivité :} Pour tout \( x \in G \), \( x^{-1}x = e \in H \), donc \( x \sim x \).
  \item \textbf{Symétrie :} Si \( x \sim y \), alors \( x^{-1}y \in H \). Comme \( H \) est un sous-groupe, l'inverse \( (x^{-1}y)^{-1} = y^{-1}x \) appartient à \( H \), donc \( y \sim x \).
  \item \textbf{Transitivité :} Si \( x \sim y \) et \( y \sim z \), alors \( x^{-1}y \in H \) et \( y^{-1}z \in H \). Le produit \( (x^{-1}y)(y^{-1}z) = x^{-1}z \) est dans \( H \), donc \( x \sim z \).
\end{itemize}

\subparagraph{Description des classes d'équivalence}
Pour un élément \( g \in G \), la classe d'équivalence de \( g \) est définie par :
\[
[g] = \{ x \in G : g \sim x \} = \{ x \in G : g^{-1}x \in H \}.
\]
Montrons que cet ensemble coïncide avec l'ensemble
\[
gH = \{ gh : h \in H \}.
\]

\begin{itemize}
  \item Si \( x \in [g] \), alors \( g^{-1}x \in H \). Notons \( h = g^{-1}x \in H \). En multipliant à gauche par \( g \), on obtient \( x = gh \), ce qui montre que \( x \in gH \).
  \item Réciproquement, si \( x \in gH \), il existe \( h \in H \) tel que \( x = gh \). Alors \( g^{-1}x = g^{-1}gh = h \in H \), donc \( g \sim x \) et \( x \in [g] \).
\end{itemize}

Ainsi, \( [g] = gH \). Les classes d'équivalence sont donc exactement les ensembles de la forme \( gH \) pour \( g \in G \). On les appelle les \emph{classes à gauche modulo \( H \)}.

\paragraph{2. Cardinal des classes et partition de \( G \)}

\subparagraph{Même cardinal pour toutes les classes}
Pour tout \( g \in G \), l'application
\[
f_g : H \longrightarrow gH, \quad h \longmapsto gh
\]
est une bijection :
\begin{itemize}
  \item Elle est surjective par définition de \( gH \).
  \item Elle est injective car \( gh_1 = gh_2 \) implique \( h_1 = h_2 \) (en multipliant à gauche par \( g^{-1} \)).
\end{itemize}
Ainsi, \( |gH| = |H| \) pour tout \( g \in G \).

\subparagraph{Partition de \( G \)}
Les classes à gauche forment une partition de \( G \) (propriété générale des relations d'équivalence). Notons \( r \) le nombre de classes distinctes (cet entier est appelé \emph{indice} de \( H \) dans \( G \) et noté \( [G:H] \)).

Puisque chaque classe a pour cardinal \( |H| \) et que ces classes sont disjointes et recouvrent \( G \), on a :
\[
|G| = \sum_{i=1}^{r} |g_iH| = \sum_{i=1}^{r} |H| = r \cdot |H|,
\]
où \( g_1, \dots, g_r \) sont des représentants des différentes classes.

Cette égalité montre que \( |H| \) divise \( |G| \), et que plus précisément \( [G:H] = \frac{|G|}{|H|} \).

\paragraph{3. Application au cas particulier d'un élément}
Pour tout \( g \in G \), considérons l'ensemble des puissances de \( g \) :
\[
\langle g \rangle = \{ g^n : n \in \mathbb{Z} \}.
\]

\subparagraph{Finitude et définition de l'ordre}
Comme \( G \) est fini, les puissances \( g^0, g^1, g^2, \dots \) ne peuvent être toutes distinctes. Il existe donc des entiers \( i < j \) tels que \( g^i = g^j \). En multipliant par \( g^{-i} \), on obtient \( g^{j-i} = e \) avec \( j-i > 0 \).

L'ensemble des entiers strictement positifs \( k \) tels que \( g^k = e \) est donc non vide. Soit \( d \) son plus petit élément (par le principe du bon ordre). Cet entier \( d \) est appelé \emph{ordre de \( g \)} et se note $\ord(g)$.

\subparagraph{Structure de \( \langle g \rangle \)}
Montrons que \( \langle g \rangle = \{ e, g, g^2, \dots, g^{d-1} \} \) et que ces éléments sont distincts.

Pour tout entier \( n \), effectuons la division euclidienne de \( n \) par \( d \) :
\[
n = qd + r, \quad \text{avec } 0 \leq r < d.
\]
Alors
\[
g^n = g^{qd+r} = (g^d)^q \cdot g^r = e^q \cdot g^r = g^r.
\]
Ainsi, toute puissance de \( g \) coïncide avec l'un des éléments \( g^r \) où \( 0 \leq r < d \).

De plus, ces éléments sont distincts : si \( g^i = g^j \) avec \( 0 \leq i < j < d \), alors \( g^{j-i} = e \) avec \( 0 < j-i < d \), ce qui contredit la minimalité de \( d \).

Par conséquent, \( \langle g \rangle \) possède exactement \( d \) éléments, c'est-à-dire \( |\langle g \rangle| = d \).

\subparagraph{Conclusion}
L'ensemble \( \langle g \rangle \) est un sous-groupe de \( G \) (c'est le sous-groupe engendré par \( g \)). D'après la première partie du théorème, son cardinal \( |\langle g \rangle| \) divise \( |G| \). Or \( |\langle g \rangle| = d \), qui est précisément l'ordre de \( g \). On en déduit que l'ordre de \( g \) divise le cardinal de \( G \).
\end{proof}







\begin{theorem}[Théorème d'Euler]
\label{thm:euler}
Si $a$ et $n$ sont premiers entre eux, alors :
\[
a^{\varphi(n)} \equiv 1 \pmod{n}
\]
\end{theorem}

\begin{proof}
L'ensemble $(\Z/n\Z)^\times$ est, par la Définition~\ref{def:multgrpZnZ}, un groupe multiplicatif d'ordre $\varphi(n)$. Pour tout $a \in (\Z/n\Z)^\times$, par le théorème de Lagrange (Théorème~\ref{thm:lagrange-groupes}) appliqué au sous-groupe $\langle a \rangle$, l'ordre de $a$ divise $\varphi(n)$. Donc $a^{\varphi(n)} = 1$ dans $(\Z/n\Z)^\times$, c'est-à-dire $a^{\varphi(n)} \equiv 1 \pmod{n}$.
\end{proof}

\begin{theorem}[Petit théorème de Fermat]
\label{thm:fermat}
Si $p$ est premier et $a$ n'est pas divisible par $p$, alors :
\[
a^{p-1} \equiv 1 \pmod{p}
\]
\end{theorem}

\begin{proof}
C'est un cas particulier du théorème d'Euler, car pour $p$ premier, $\varphi(p) = p-1$.
\end{proof}



\begin{proposition}[Algorithme d'Euclide étendu et inverse modulaire]\label{prop:euclide-etendu}
Soient $a,n \in \Z$ avec $\gcd(a,n)=1$. L'algorithme d'Euclide étendu calcule des entiers
$u,v$ tels que
\[
  au + nv = 1.
\]
En particulier, $u \bmod n$ est l'inverse de $a$ modulo $n$.
\end{proposition}

\paragraph{Algorithme d'Euclide étendu.}
Entrée : $n \ge 2$ et $a \in \{1,2,\dots,n-1\}$ avec $\gcd(a,n)=1$.  
Sortie : un entier $u$ tel que $au \equiv 1 \pmod n$.

\medskip
\noindent\textbf{Initialisation.}
\[
  r_0 \leftarrow n,\quad r_1 \leftarrow a, \qquad
  u_0 \leftarrow 0,\quad u_1 \leftarrow 1,\qquad
  v_0 \leftarrow 1,\quad v_1 \leftarrow 0.
\]

\noindent\textbf{Boucle :} tant que $r_1 \neq 0$ faire
\begin{enumerate}
  \item Calculer $q \leftarrow \left\lfloor \dfrac{r_0}{r_1} \right\rfloor$ (division euclidienne).
  \item Mettre à jour :
  \[
    r_2 \leftarrow r_0 - q\,r_1,\qquad
    u_2 \leftarrow u_0 - q\,u_1,\qquad
    v_2 \leftarrow v_0 - q\,v_1.
  \]
  \item Décaler les variables :
  \[
    r_0 \leftarrow r_1,\quad r_1 \leftarrow r_2,\qquad
    u_0 \leftarrow u_1,\quad u_1 \leftarrow u_2,\qquad
    v_0 \leftarrow v_1,\quad v_1 \leftarrow v_2.
  \]
\end{enumerate}
Fin de boucle.

\noindent\textbf{Résultat.} À la fin, on renvoie
\[
  u \equiv u_0 \pmod n
\]
(en ramenant $u_0$ dans l'intervalle $\{0,\dots,n-1\}$).

\medskip
\paragraph{Invariants de boucle.}
À chaque itération (avant l'étape 1), les variables courantes $r_0,r_1,u_0,u_1,v_0,v_1$
vérifient :
\begin{enumerate}
  \item[(I)] \textbf{Expression linéaire (relation de Bézout).}
  Il existe des entiers $u_0,u_1,v_0,v_1$ tels que
  \[
    r_0 = a u_0 + n v_0,\qquad
    r_1 = a u_1 + n v_1.
  \]
  \item[(II)] \textbf{PGCD préservé.}
  \[
    \gcd(r_0,r_1) = \gcd(n,a).
  \]
\end{enumerate}

\paragraph{Preuve de l'invariant (I).}
À l'initialisation,
\[
  r_0 = n = a\cdot 0 + n\cdot 1 = a u_0 + n v_0,\qquad
  r_1 = a = a\cdot 1 + n\cdot 0 = a u_1 + n v_1,
\]
donc la propriété (I) est vraie.

Supposons-la vraie au début d'une itération, c'est-à-dire
\[
  r_0 = a u_0 + n v_0,\qquad
  r_1 = a u_1 + n v_1.
\]
Après calcul de $q$ et mise à jour, on obtient
\[
  r_2 = r_0 - q r_1
      = (a u_0 + n v_0) - q (a u_1 + n v_1)
      = a(u_0 - q u_1) + n(v_0 - q v_1)
      = a u_2 + n v_2.
\]

Puis, après le décalage, les nouvelles valeurs
\[
  (r_0',r_1',u_0',u_1',v_0',v_1')
  = (r_1,r_2,u_1,u_2,v_1,v_2)
\]
sont données explicitement par
\[
  r_0' = r_1 = a u_1 + n v_1,\qquad
  r_1' = r_2 = a u_2 + n v_2,
\]
\[
  u_0' = u_1,\qquad u_1' = u_2,\qquad
  v_0' = v_1,\qquad v_1' = v_2.
\]

On retrouve donc encore des écritures de la forme
\[
  r_0' = a u_0' + n v_0',\qquad
  r_1' = a u_1' + n v_1',
\]
ce qui montre que (I) reste vraie à la fin de l'itération.
Par récurrence, (I) est donc vérifiée à chaque étape de la boucle.

\paragraph{Preuve de l'invariant (II).}
À l'initialisation,
\[
  \gcd(r_0,r_1) = \gcd(n,a).
\]

Lors d'une itération, on remplace $(r_0,r_1)$ par $(r_1,r_2)$ avec
\[
  r_2 = r_0 - q r_1.
\]
Montrons que
\[
  \gcd(r_0,r_1) = \gcd(r_1,r_2).
\]

Soit $d = \gcd(r_0,r_1)$. Alors $d$ divise $r_0$ et $r_1$, donc
$d$ divise aussi toute combinaison linéaire de $r_0$ et $r_1$, en
particulier
\[
  r_2 = r_0 - q r_1,
\]
de sorte que $d$ divise $r_1$ et $r_2$. Ainsi $d$ est un diviseur
commun de $r_1$ et $r_2$, donc
\[
  d \le \gcd(r_1,r_2).
\]

Réciproquement, soit $d' = \gcd(r_1,r_2)$. Alors $d'$ divise $r_1$
et $r_2$, donc divise aussi
\[
  r_0 = r_2 + q r_1.
\]
Ainsi $d'$ divise $r_0$ et $r_1$, donc $d'$ est un diviseur commun
de $r_0$ et $r_1$, d'où
\[
  d' \le \gcd(r_0,r_1).
\]

On a donc $d \le d'$ et $d' \le d$, ce qui implique
\[
  \gcd(r_0,r_1) = d = d' = \gcd(r_1,r_2).
\]

Par conséquent, remplacer $(r_0,r_1)$ par $(r_1,r_2)$ laisse le PGCD
inchangé. Comme à l'initialisation $\gcd(r_0,r_1) = \gcd(n,a)$, cette
égalité reste vraie à chaque itération, et l'invariant (II) est
préservé.
\paragraph{Terminaison et résultat.}
La suite $(r_i)$ issue de l'algorithme d'Euclide classique est strictement
décroissante en valeurs absolues et reste positive, donc la boucle finit
avec $r_1 = 0$. À ce moment-là, on a
\[
  r_0 = \gcd(r_0,r_1) = \gcd(n,a).
\]
Comme on suppose $\gcd(n,a)=1$, on obtient $r_0 = 1$ à la fin.

Par l'invariant (I), les valeurs finales $r_0,u_0,v_0$ vérifient donc
\[
  1 = r_0 = a u_0 + n v_0.
\]
En réduisant modulo $n$, on obtient $a u_0 \equiv 1 \pmod n$, ce qui montre
que $u_0$ (modulo $n$) est l'inverse de $a$ modulo $n$, ce qui prouve
la Proposition~\ref{prop:euclide-etendu}.


\begin{example}[Inverse de $5$ modulo $17$]\label{ex:inv-5-mod-17}
Appliquons l'algorithme d'Euclide étendu pour trouver l'inverse de $a = 5$
modulo $n = 17$.

\medskip
\centerline{
\begin{tabular}{c|c|c|c|c|c}
Étape & $q$ & $r_0$ & $r_1$ & $u_0$ & $u_1$ \\ \hline
Init. &   & $17$ & $5$  & $0$  & $1$ \\ \hline
1 & $3$ & $5$  & $2$  & $1$  & $-3$ \\
2 & $2$ & $2$  & $1$  & $-3$ & $7$  \\
3 & $2$ & $1$  & $0$  & $7$  & $-17$
\end{tabular}
}

\medskip
On obtient $r_0 = 1$ et $u_0 = 7$, avec
\[
  1 = 17\cdot(-2) + 5\cdot 7.
\]
Ainsi, $5\cdot 7 \equiv 1 \pmod{17}$ et l'inverse de $5$ modulo $17$ est
\[
  5^{-1} \equiv 7 \pmod{17}.
\]
\end{example}

\begin{remark}[À retenir pour RSA]
Pour RSA, nous utiliserons :
\begin{itemize}
  \item Le théorème d'Euler (ou le petit théorème de Fermat) dans la preuve de correction (section~\ref{thm:rsa-correct}).
  \item L'algorithme d'Euclide étendu pour calculer $d = e^{-1} \bmod \varphi(n)$.

\end{itemize}
\end{remark}

\subsection{Théorèmes fondamentaux d'isomorphisme}

\begin{definition}[Homomorphisme de groupes]
Soient $(G,\cdot)$ et $(H,\ast)$ deux groupes. Une application $f: G \to H$ est un \emph{homomorphisme de groupes} si pour tous $g_1, g_2 \in G$ :
\[
f(g_1 \cdot g_2) = f(g_1) \ast f(g_2).
\]
Le \emph{noyau} de $f$ est $\ker(f) = \{g \in G \mid f(g) = e_H\}$.
\end{definition}

\begin{definition}[Homomorphisme d'anneaux]
Soient $(A,+_A,\cdot_A)$ et $(B,+_B,\cdot_B)$ deux anneaux. Une application $f: A \to B$ est un \emph{homomorphisme d'anneaux} si pour tous $a_1, a_2 \in A$ :
\begin{align*}
f(a_1 +_A a_2) &= f(a_1) +_B f(a_2) \\
f(a_1 \cdot_A a_2) &= f(a_1) \cdot_B f(a_2) \\
f(1_A) &= 1_B
\end{align*}
Le \emph{noyau} de $f$ est $\ker(f) = \{a \in A \mid f(a) = 0_B\}$.

\begin{remark} Les deux premières conditions impliquent automatiquement $f(0_A) = 0_B$. En effet, pour tout $a \in A$, on a $f(a) = f(a +_A 0_A) = f(a) +_B f(0_A)$, d'où $f(0_A) = 0_B$ par simplification dans le groupe additif $(B, +_B)$.
\end{remark}
\end{definition}
\begin{theorem}[Premier théorème d'isomorphisme pour les groupes]
\label{thm:iso-groupes}
Soit $f: G \to H$ un homomorphisme de groupes. Alors :
\begin{enumerate}
  \item $\ker(f)$ est un sous-groupe distingué de $G$
  \item $\mathrm{Im}(f)$ est un sous-groupe de $H$
  \item $G/\ker(f) \simeq \mathrm{Im}(f)$
\end{enumerate}
\end{theorem}

\begin{proof}
(1) et (2) sont des vérifications directes. Pour (3), définissons :
\[
\overline{f}: G/\ker(f) \to \mathrm{Im}(f),\quad g\ker(f) \mapsto f(g).
\]
Vérifions que $\overline{f}$ est bien définie : si $g_1\ker(f) = g_2\ker(f)$, alors $g_1^{-1}g_2 \in \ker(f)$, donc $f(g_1^{-1}g_2) = e_H$, d'où $f(g_1) = f(g_2)$. Ceci montre que $\overline{f}$ ne dépend pas du choix du représentant de la classe $g\ker(f)$, ce qui est possible car $\ker(f)$ est distingué.

Montrons que $\overline{f}$ est un homomorphisme : 
\[
\overline{f}((g_1\ker(f))(g_2\ker(f))) = \overline{f}(g_1g_2\ker(f)) = f(g_1g_2) = f(g_1)f(g_2) = \overline{f}(g_1\ker(f))\overline{f}(g_2\ker(f)).
\]

L'injectivité vient de : si $\overline{f}(g\ker(f)) = e_H$, alors $f(g) = e_H$, donc $g \in \ker(f)$, d'où $g\ker(f) = \ker(f)$ (classe de l'élément neutre).

La surjectivité est immédiate par définition de $\mathrm{Im}(f)$.

Ainsi $\overline{f}$ est un isomorphisme.
\end{proof}

\begin{definition}[Idéal d'un anneau]
Un sous-ensemble $I$ d'un anneau $A$ est un \emph{idéal} si :
\begin{enumerate}
  \item $(I, +)$ est un sous-groupe de $(A, +)$
  \item Pour tout $a \in A$ et tout $x \in I$, on a $a \cdot x \in I$ et $x \cdot a \in I$ (stabilité par multiplication par tout élément de l'anneau)
\end{enumerate}
\end{definition}

\begin{theorem}[Premier théorème d'isomorphisme pour les anneaux]
\label{thm:iso-anneaux}
Soit $f: A \to B$ un homomorphisme d'anneaux. Alors :
\begin{enumerate}
  \item $\ker(f)$ est un idéal de $A$
  \item $\mathrm{Im}(f)$ est un sous-anneau de $B$
  \item $A/\ker(f) \simeq \mathrm{Im}(f)$
\end{enumerate}
\end{theorem}

\begin{proof}
(1) Montrons que $\ker(f)$ est un idéal. Soient $x, y \in \ker(f)$. Alors $f(x - y) = f(x) - f(y) = 0_B - 0_B = 0_B$, donc $x - y \in \ker(f)$. Soit $a \in A$ et $x \in \ker(f)$. Alors $f(a \cdot x) = f(a) \cdot f(x) = f(a) \cdot 0_B = 0_B$, donc $a \cdot x \in \ker(f)$. De même, $x \cdot a \in \ker(f)$. Ainsi $\ker(f)$ est un idéal.

(2) Soient $b_1, b_2 \in \mathrm{Im}(f)$. Il existe $a_1, a_2 \in A$ tels que $f(a_1) = b_1$ et $f(a_2) = b_2$. Alors $b_1 - b_2 = f(a_1) - f(a_2) = f(a_1 - a_2) \in \mathrm{Im}(f)$ et $b_1 \cdot b_2 = f(a_1) \cdot f(a_2) = f(a_1 \cdot a_2) \in \mathrm{Im}(f)$. De plus, $1_B = f(1_A) \in \mathrm{Im}(f)$. Donc $\mathrm{Im}(f)$ est un sous-anneau de $B$.

(3) Définissons $\overline{f}: A/\ker(f) \to \mathrm{Im}(f)$ par $\overline{f}(a + \ker(f)) = f(a)$. Cette application est bien définie car si $a + \ker(f) = a' + \ker(f)$, alors $a - a' \in \ker(f)$, donc $f(a - a') = 0_B$, soit $f(a) = f(a')$. C'est un homomorphisme d'anneaux car :
\begin{align*}
\overline{f}((a + \ker(f)) + (b + \ker(f))) &= \overline{f}(a + b + \ker(f)) = f(a + b) = f(a) + f(b) \\
&= \overline{f}(a + \ker(f)) + \overline{f}(b + \ker(f)), \\
\overline{f}((a + \ker(f)) \cdot (b + \ker(f))) &= \overline{f}(a \cdot b + \ker(f)) = f(a \cdot b) = f(a) \cdot f(b) \\
&= \overline{f}(a + \ker(f)) \cdot \overline(f)(b + \ker(f)), \\
\overline{f}(1_A + \ker(f)) &= f(1_A) = 1_B.
\end{align*}
L'injectivité : si $\overline{f}(a + \ker(f)) = 0_B$, alors $f(a) = 0_B$, donc $a \in \ker(f)$, d'où $a + \ker(f) = 0_A + \ker(f)$. La surjectivité est évidente. Donc $\overline{f}$ est un isomorphisme.
\end{proof}

\begin{remark}[Utilisation en cryptographie]
Ces théorèmes justifient plusieurs isomorphismes fondamentaux :
\begin{itemize}
  \item $\Z/p\Z \simeq \F_p$ (corps premier) - essentiel pour RSA et Shamir
  \item $\F_2[X]/(m(X)) \simeq \F_{2^8}$ pour AES
  \item $\Z_\ell \simeq \langle B \rangle$ pour Ed25519 - isomorphisme entre scalaires et points du sous-groupe
\end{itemize}
Ils garantissent que différentes représentations d'une même structure algébrique sont équivalentes, ce qui permet de choisir la représentation la plus efficace pour l'implémentation.
\end{remark}

\subsection{Corps finis et extensions}

\begin{theorem}[Unicité du corps à $p$ éléments]
\label{thm:unicite-corps-premier}
Soit $p$ un nombre premier. Alors :
\begin{enumerate}
  \item $\F_p = \Z/p\Z$ est un corps à $p$ éléments.
  \item Tout corps $K$ de cardinal $p$ est isomorphe à $\F_p$.
  \item Cet isomorphisme est unique : si $\phi_1, \phi_2 : K \to \F_p$ sont deux isomorphismes, alors $\phi_1 = \phi_2$.
\end{enumerate}
\end{theorem}

\begin{proof}
(1) Puisque $p$ est premier, tout élément non nul de $\Z/p\Z$ est inversible modulo $p$, donc $\Z/p\Z$ est un corps.

(2) Soit $K$ un corps de cardinal $p$. Puisque $K$ est fini, sa caractéristique est un nombre premier. Comme $p \cdot 1_K = 0$ (d'après le théorème de Lagrange (\ref{thm:lagrange-groupes}) appliqué au groupe additif), la caractéristique divise $p$, donc est égale à $p$.

Considérons l'homomorphisme d'anneaux canonique :
\[
\iota : \Z \to K,\quad n \mapsto n \cdot 1_K
\]
Son noyau est un idéal de $\Z$. Comme tout idéal de $\Z$ est principal, il existe un entier $m \ge 0$ tel que $\ker\iota = m\Z$. Puisque $\iota(p) = p \cdot 1_K = 0$, on a $p \in \ker\iota$, donc $m$ divise $p$. Comme $\iota$ n'est pas l'application nulle (car $\iota(1) = 1_K \neq 0$), on a $m = p$.

Ainsi $\ker\iota = p\Z$. Par le théorème fondamental d'isomorphisme (Théorème~\ref{thm:iso-anneaux}), on obtient un homomorphisme injectif :
\[
\overline{\iota} : \Z/p\Z \hookrightarrow K
\]
Puisque les deux ensembles ont le même cardinal fini $p$, $\overline{\iota}$ est un isomorphisme.

(3) Soient $\phi_1, \phi_2 : K \to \F_p$ deux isomorphismes. Alors $\psi = \phi_2^{-1} \circ \phi_1$ est un automorphisme de $K$.

Montrons que $K$ est un $\F_p$-espace vectoriel de dimension $1$. D'abord, comme $K$ est de caractéristique $p$, le sous-corps premier (voir \ref{sec:sous-corps-premier}) de $K$ est isomorphe à $\F_p$. On peut donc identifier $\F_p$ au sous-corps de $K$ engendré par $1_K$, et définir une structure de $\F_p$-espace vectoriel sur $K$ par la multiplication interne de $K$.

Pour la dimension : si $\dim_{\F_p} K = d$, alors $K$ est isomorphe à $\F_p^d$ comme espace vectoriel, donc $|K| = p^d$. Or $|K| = p$, donc $p^d = p$ et $d = 1$. Ainsi, $K$ est un $\F_p$-espace vectoriel de dimension $1$.

Un automorphisme d'anneaux de $K$ est en particulier un automorphisme de $\F_p$-espaces vectoriels. Tout endomorphisme d'un espace vectoriel de dimension $1$ est la multiplication par un scalaire. Il existe donc $\lambda \in \F_p^*$ tel que $\psi(x) = \lambda \cdot x$ pour tout $x \in K$.

En particulier, $\psi(1_K) = \lambda \cdot 1_K = \lambda$. Comme $\psi$ est un isomorphisme d'anneaux, on a $\psi(1_K) = 1_K$, donc $\lambda = 1_K = 1$ (dans $\F_p$). Ainsi $\psi = \mathrm{id}_K$, ce qui implique $\phi_1 = \phi_2$.
\end{proof}

\begin{definition}[Corps fini premier]
Soit $p$ un nombre premier. On note
\[
  \F_p = \Z/p\Z
\]
le corps fini à $p$ éléments. Les opérations arithmétiques dans $\F_p$ sont effectuées modulo $p$. Plus précisément, pour $a, b \in \F_p$ :
\begin{itemize}
  \item $a + b = (a + b) \bmod p$
  \item $a \cdot b = (a \cdot b) \bmod p$
  \item L'inverse additif de $a$ est $p - a$ (modulo $p$)
  \item L'inverse multiplicatif de $a \neq 0$ est l'unique élément $a^{-1} \in \F_p$ tel que $a \cdot a^{-1} \equiv 1 \pmod{p}$
\end{itemize}
\end{definition}

\begin{example}[Corps $\F_5$]
Le corps $\F_5 = \{0,1,2,3,4\}$ avec les opérations modulo 5.

Tables d'addition et de multiplication :
\[
\begin{array}{c|ccccc}
+ & 0 & 1 & 2 & 3 & 4 \\ \hline
0 & 0 & 1 & 2 & 3 & 4 \\
1 & 1 & 2 & 3 & 4 & 0 \\
2 & 2 & 3 & 4 & 0 & 1 \\
3 & 3 & 4 & 0 & 1 & 2 \\
4 & 4 & 0 & 1 & 2 & 3
\end{array}
\qquad
\begin{array}{c|ccccc}
\times & 0 & 1 & 2 & 3 & 4 \\ \hline
0 & 0 & 0 & 0 & 0 & 0 \\
1 & 0 & 1 & 2 & 3 & 4 \\
2 & 0 & 2 & 4 & 1 & 3 \\
3 & 0 & 3 & 1 & 4 & 2 \\
4 & 0 & 4 & 3 & 2 & 1
\end{array}
\]

Calcul de l'inverse de 3 modulo 5 : on cherche $x$ tel que $3x \equiv 1 \pmod{5}$. En inspectant la table, $3 \times 2 = 6 \equiv 1 \pmod{5}$, donc $3^{-1} = 2$.
\end{example}

\begin{definition}[Corps $\F_P$ pour le partage de Shamir]
Dans le cadre du schéma $k$ sur $n$, on utilise un corps fini premier particulier de cardinal 
\[
P = 2^{521} - 1
\]
qui est un nombre premier de Mersenne. Ce choix est motivé par :
\begin{itemize}
  \item Sa taille (521 bits) est suffisamment grande pour garantir la sécurité du partage de secret.
  \item Les opérations modulo $P$ peuvent être optimisées grâce à la forme $2^{521} - 1$ (réduction rapide).
  \item Le corps $\F_P$ permet de représenter de manière injective un secret maître $S \in \bin^{256}$ (car $P > 2^{256}$).
\end{itemize}
Ce corps sera le support algébrique des polynômes de Shamir utilisés pour le partage du secret maître.
\end{definition}

\begin{definition}[Anneau de polynômes]
Soit $\mathbb{K}$ un corps commutatif. L'anneau des polynômes à coefficients dans $\mathbb{K}$ est l'ensemble des suites $(a_0, a_1, a_2, \dots)$ d'éléments de $\mathbb{K}$ qui sont presque toutes nulles (c'est-à-dire qu'il existe un rang $N$ tel que $a_n = 0$ pour tout $n \geq N$). Un tel polynôme s'écrit usuellement $P(X) = a_0 + a_1X + a_2X^2 + \dots + a_dX^d$ où $d$ est le plus grand indice tel que $a_d \neq 0$ (degré). 

\medskip

\textbf{Cas particulier :} Le polynôme nul $(0,0,0,\dots)$ est noté $0$. Par convention, on pose $\deg(0) = -\infty$ (avec les conventions $-\infty < n$ pour tout $n \in \mathbb{N}$ et $-\infty + n = -\infty$).

\medskip

Les opérations sont :
\begin{itemize}
  \item Addition : $(a_n) + (b_n) = (a_n + b_n)$
  \item Multiplication : $(a_n) \cdot (b_n) = (c_n)$ avec $c_n = \sum_{i+j=n} a_i b_j$
\end{itemize}
On note cet anneau $\mathbb{K}[X]$.
\end{definition}

\begin{lemma}[Division euclidienne dans l'anneau $\Kpolys$]
Soient $A(X), B(X) \in \Kpolys$ avec $B(X) \neq 0$. Il existe un unique couple $(Q(X), R(X)) \in \Kpolys^2$ tel que :
\[
A(X) = B(X)Q(X) + R(X) \quad \text{avec} \quad \deg(R(X)) < \deg(B(X)) \quad \text{ou} \quad R(X) = 0.
\]
\end{lemma}

\begin{proof}
\textbf{Existence.} On procède par récurrence forte sur $\deg(A)$.

- Si $A = 0$ ou $\deg(A) < \deg(B)$, on pose $Q = 0$ et $R = A$, et on a bien $A = B \cdot 0 + R$ avec $\deg(R) < \deg(B)$ ou $R=0$.

- Supposons $\deg(A) \geq \deg(B)$. Écrivons :
\[
A(X) = a_n X^n + \dots + a_0, \quad B(X) = b_m X^m + \dots + b_0,
\]
avec $a_n \neq 0$, $b_m \neq 0$ et $n \geq m$. Formons le polynôme :
\[
A_1(X) = A(X) - \frac{a_n}{b_m} X^{n-m} B(X).
\]
Le terme de degré $n$ s'annule, donc $\deg(A_1) < n$ ou $A_1 = 0$. Par hypothèse de récurrence forte, il existe $Q_1, R_1$ tels que :
\[
A_1 = B Q_1 + R_1, \quad \text{avec } \deg(R_1) < \deg(B) \text{ ou } R_1 = 0.
\]
Alors :
\[
A = \frac{a_n}{b_m} X^{n-m} B + A_1 = B \left( \frac{a_n}{b_m} X^{n-m} + Q_1 \right) + R_1,
\]
ce qui donne l'existence avec $Q = \frac{a_n}{b_m} X^{n-m} + Q_1$ et $R = R_1$.

\medskip

\textbf{Unicité.} Supposons deux décompositions :
\[
A = BQ + R = BQ' + R',
\]
avec $\deg(R), \deg(R') < \deg(B)$ ou $R,R'=0$. Alors :
\[
B(Q - Q') = R' - R.
\]
Si $Q \neq Q'$, alors $\deg(B(Q-Q')) \geq \deg(B)$ (car $\mathbb{K}[X]$ est intègre). Mais $\deg(R' - R) < \deg(B)$ (car $\deg(R' - R) \leq \max(\deg(R), \deg(R')) < \deg(B)$). Contradiction. Donc $Q = Q'$, et par suite $R = R'$.
\end{proof}

\begin{lemma}[Nombre de racines d'un polynôme]
\label{lem:racines-poly}
Soit $\mathbb{K}$ un corps et soit $f\in\Kpolys$ un polynôme non nul de degré $d\ge 0$. Alors $f$ admet au plus $d$ racines dans $\mathbb{K}$.
\end{lemma}

\begin{proof}
Par récurrence sur $d$. Le cas $d=0$ est immédiat (un polynôme constant non nul n'a aucune racine). Pour $d\ge 1$, si $f$ a une racine $a\in\mathbb{K}$, alors par division euclidienne dans $\Kpolys$, on peut écrire $f(X) = (X-a)g(X)$ avec $g\in\Kpolys$ de degré $d-1$.

Soit maintenant $b\neq a$ une autre racine de $f$. Alors $0=f(b)=(b-a)g(b)$. Comme $b-a\neq 0$ et que $\mathbb{K}$ est un corps (donc intègre), on en déduit $g(b)=0$. Ainsi, toutes les racines de $f$ distinctes de $a$ sont des racines de $g$. Par hypothèse de récurrence, $g$ a au plus $d-1$ racines, donc $f$ a au plus $d$ racines.
\end{proof}

\begin{proposition}[Anneau principal des polynômes]
\label{prop:anneau-principal}
Soit $\mathbb{K}$ un corps. Alors $\Kpolys$ est un anneau principal, c'est-à-dire que tout idéal de $\Kpolys$ est engendré par un unique polynôme unitaire (le générateur unitaire de l'idéal).
\end{proposition}

\begin{proof}
Soit $J$ un idéal non nul de $\Kpolys$. Considérons l'ensemble :
\[
D = \{\deg(P(X)) \mid P(X) \in J,\ P(X) \neq 0\}.
\]
Comme $J$ est non nul, $D$ est une partie non vide de $\mathbb{N}$. Soit $d_0$ le plus petit élément de $D$, et soit $P_0(X) \in J$ non nul de degré $d_0$. On peut supposer $P_0(X)$ unitaire (quitte à le normaliser). Montrons que $J = (P_0(X))$.

Soit $A(X) \in J$. Par division euclidienne, il existe $Q(X), R(X) \in \Kpolys$ tels que :
\[
A(X) = P_0(X)Q(X) + R(X) \quad \text{avec} \quad \deg(R(X)) < \deg(P_0(X)) \quad \text{ou} \quad R(X) = 0.
\]
Or $R(X) = A(X) - P_0(X)Q(X) \in J$ (car $A(X), P_0(X) \in J$). Si $R(X) \neq 0$, alors $\deg(R(X)) < d_0$, ce qui contredit la minimalité de $d_0$. Donc $R(X) = 0$ et $A(X) = P_0(X)Q(X) \in (P_0(X))$. Ainsi $J \subset (P_0(X))$. L'inclusion inverse est évidente car $P_0(X) \in J$. Donc $J = (P_0(X))$.
\end{proof}

\begin{definition}[Idéal maximal]
Soit $A$ un anneau commutatif unitaire. Un idéal $I$ de $A$ est dit \emph{maximal} si $I \neq A$ et si pour tout idéal $J$ de $A$ tel que $I \subseteq J \subseteq A$, on a soit $J = I$, soit $J = A$.
\end{definition}

\begin{proposition}[Quotient par un idéal maximal]
\label{prop:quotient-maximal}
Soit $A$ un anneau commutatif unitaire et $I$ un idéal maximal de $A$. Alors l'anneau quotient $A/I$ est un corps.
\end{proposition}

\begin{proof}
Soit $\overline{x} \neq 0$ dans $A/I$. Alors $x \notin I$. Considérons l'idéal $J = I + (x)$ (l'idéal engendré par $I$ et $x$). Puisque $I$ est maximal et $I \subsetneq J$ (car $x \in J$ mais $x \notin I$), on a nécessairement $J = A$.

Ainsi, il existe $i \in I$ et $a \in A$ tels que :
\[
1 = i + a \cdot x
\]
En passant au quotient dans $A/I$, on obtient :
\[
\overline{1} = \overline{i} + \overline{a} \cdot \overline{x} = 0 + \overline{a} \cdot \overline{x} = \overline{a} \cdot \overline{x}
\]
Donc $\overline{a}$ est l'inverse de $\overline{x}$ dans $A/I$. Ainsi, tout élément non nul de $A/I$ est inversible, et $A/I$ est un corps.
\end{proof}

\begin{corollary}[Construction de corps par quotient avec un polynôme irréductible]
\label{prop:corps-quotient}
Soit $\mathbb{K}$ un corps commutatif et soit $m(X) \in \Kpolys$ un polynôme irréductible. Alors l'anneau quotient $\Kpolys/(m(X))$ est un corps.
\end{corollary}

\begin{proof}
Soit $I = (m(X))$ l'idéal engendré par $m(X)$. 

Puisque $\Kpolys$ est principal (Proposition~\ref{prop:anneau-principal}), et que $m(X)$ est irréductible, l'idéal $I$ est maximal. En effet, soit $J$ un idéal tel que $I \subset J \subset \Kpolys$. Alors $J = (p(X))$ pour un certain $p(X) \in \Kpolys$. Puisque $m(X) \in J$, on a $p(X) \mid m(X)$. Mais $m(X)$ est irréductible, donc soit $p(X)$ est une constante non nulle (auquel cas $J = \mathbb{K}[X]$), soit $p(X)$ est associé à $m(X)$ (auquel cas $J = I$). Ainsi, $I$ est maximal.

Par la Proposition~\ref{prop:quotient-maximal}, le quotient $\Kpolys/I$ est un corps.
\end{proof}

\begin{theorem}[Théorème de Moore]
\label{thm:moore}
Pour tout $q = p^n$ avec $p$ premier et $n \ge 1$, il existe un corps fini de
cardinal $q$, unique à isomorphisme près. On note alors $\F_{p^n}$ n'importe
quel corps fini de cardinal $p^n$.

Ce théorème est essentiellement là pour justifier que la notation $\F_{p^n}$
(en particulier $\F_{2^n}$) n'est pas ambiguë : tous les corps finis de
cardinal $p^n$ sont isomorphes, quel que soit le modèle concret choisi.
\end{theorem}

\begin{proof}[Commentaire]
\textbf{Existence.}
En pratique, on construit un corps de cardinal $p^n$ comme quotient
$\F_p[X]/(m(X))$, où $m(X) \in \F_p[X]$ est un polynôme irréductible de degré $n$
(on admet ici l'existence d'un tel polynôme). Par la
Proposition~\ref{prop:corps-quotient}, ce quotient est un corps. Vu comme
$\F_p$-espace vectoriel de base $1,\overline{X},\dots,\overline{X}^{n-1}$, il a
donc exactement $p^n$ éléments. C'est ce modèle concret que nous utiliserons
pour la construction de $\F_{p^n}$ (par exemple $\F_{2^8}$ pour AES).

\medskip
\noindent\textbf{Unicité.}
Une preuve complète du fait que tout corps fini de cardinal $p^n$ est isomorphe
à tout autre repose sur quelques notions de théorie des corps que nous ne
développons pas dans le corps du texte. Ces éléments sont développés en détail dans l'Annexe~\ref{sec:annexe-moore},
où l'on donne une preuve complète du théorème de Moore.
\end{proof}
\begin{remark}[Construction pratique]
En pratique, pour construire $\F_{p^n}$, on choisit un polynôme irréductible $m(X) \in \F_p[X]$ de degré $n$ et on pose :
\[
\F_{p^n} = \F_p[X]/(m(X))
\]
Les éléments sont les polynômes de degré au plus $n-1$ à coefficients dans $\F_p$, et les opérations sont effectuées modulo $m(X)$.

Cette construction est fondamentale pour de nombreux schémas cryptographiques, par exemple AES utilise $\F_{2^8} = \F_2[X]/(X^8 + X^4 + X^3 + X + 1)$.
\end{remark}

\begin{example}[Corps $\F_4$ comme $\FdeuxQuot$]
Le polynôme $X^2 + X + 1$ est irréductible sur $\F_2$ (il n'a pas de racine dans $\F_2$ : $0^2+0+1=1$, $1^2+1+1=1$). On a $\F_4 \simeq \FdeuxQuot$.

Les éléments de ce corps sont les polynômes de degré au plus 1 : $0, 1, X, X+1$. Notons $\alpha$ la classe de $X$ modulo $X^2+X+1$, donc $\alpha^2 + \alpha + 1 = 0$, soit $\alpha^2 = \alpha + 1$ (car $-1 = 1$ dans $\F_2$).

Tables d'opérations (en notant les éléments comme $0,1,\alpha,\alpha+1$) :
\[
\begin{array}{c|cccc}
+ & 0 & 1 & \alpha & \alpha+1 \\ \hline
0 & 0 & 1 & \alpha & \alpha+1 \\
1 & 1 & 0 & \alpha+1 & \alpha \\
\alpha & \alpha & \alpha+1 & 0 & 1 \\
\alpha+1 & \alpha+1 & \alpha & 1 & 0
\end{array}
\qquad
\begin{array}{c|cccc}
\times & 0 & 1 & \alpha & \alpha+1 \\ \hline
0 & 0 & 0 & 0 & 0 \\
1 & 0 & 1 & \alpha & \alpha+1 \\
\alpha & 0 & \alpha & \alpha+1 & 1 \\
\alpha+1 & 0 & \alpha+1 & 1 & \alpha
\end{array}
\]

\textbf{Calcul de l'inverse de $\alpha$ par l'algorithme d'Euclide étendu :}

Dans $\F_2[X]$, on cherche l'inverse de $X$ modulo $X^2+X+1$, c'est-à-dire un polynôme $u(X) \in \F_2[X]$ de degré au plus 1 tel que :
\[
X \cdot u(X) \equiv 1 \pmod{X^2+X+1}
\]

Appliquons l'algorithme d'Euclide étendu à $A(X) = X^2+X+1$ et $B(X) = X$ :

\begin{enumerate}
\item Division de $A(X)$ par $B(X)$ :
\[
X^2+X+1 = X \cdot (X+1) + 1
\]
Donc $Q_1(X) = X+1$ et $R_1(X) = 1$.

\item Division de $B(X)$ par $R_1(X)$ :
\[
X = 1 \cdot X + 0
\]
Le pgcd est donc $1 = R_1(X)$.

\item Remontons l'algorithme pour exprimer 1 comme combinaison de $X^2+X+1$ et $X$ :
\[
1 = (X^2+X+1) - X \cdot (X+1)
\]
Ainsi, modulo $X^2+X+1$, on a :
\[
X \cdot (X+1) \equiv -1 \equiv 1 \pmod{X^2+X+1}
\]
car dans $\F_2$, $-1 = 1$.
\end{enumerate}

Donc l'inverse de $X$ modulo $X^2+X+1$ est $X+1$. En termes d'éléments de $\F_4$, cela donne $\alpha^{-1} = \alpha+1$.

Vérification dans la table : $\alpha \times (\alpha+1) = 1$, donc $\alpha^{-1} = \alpha+1$.
\end{example}

\begin{remark}[À retenir sur les corps finis]\leavevmode\\[0.3em]
\begin{itemize}
    \item $\mathbb{F}_p = \mathbb{Z}/p\mathbb{Z}$ est un corps si et seulement si $p$ est premier.
    \item Pour tout $a \in \mathbb{F}_p$, $a \neq 0$, il existe un unique inverse $a^{-1} \in \mathbb{F}_p$.
    \item Un polynôme irréductible $m(X)$ de degré $d$ sur $\mathbb{F}_2$ donne un corps $\mathbb{F}_{2^d} \simeq \mathbb{F}_2[X]/(m(X))$.
    \item Tout corps fini de cardinal $q = p^n$ est isomorphe à $\mathbb{F}_p[X]/(m(X))$ pour un polynôme irréductible $m(X)$ de degré $n$ sur $\mathbb{F}_p$.
\end{itemize}
\end{remark}

\subsection{Mots binaires et conventions d'encodage}

Les primitives cryptographiques sont spécifiées en termes de mots binaires (octets, séquences d'octets) tandis que nous raisonnons souvent dans des corps finis $\F_n$. Cette section fixe les conventions d'encodage qui permettent de passer de l'un à l'autre sans ambiguïté.

\begin{definition}[Mots binaires]
Pour $t\in\N$, on note
\[
  \bin^t 
\]
l'ensemble des suites $(b_{t-1},\dots,b_0)$ de bits, avec la convention que $\bin^0 = \{\varepsilon\}$ contient le mot vide. On pose
\[
  \bin^* = \bigcup_{t\ge 0}\bin^t,
\]
et pour $x\in\bin^*$, on note $\lVert x\rVert$ sa longueur (en bits).
\end{definition}

\begin{definition}[Concaténation et XOR]
La concaténation est l'application
\[
  \concat : \bin^a \times \bin^b \to \bin^{a+b}
\]
qui à $(x,y)$ associe la suite obtenue en juxtaposant $x$ et $y$.

Le XOR est l'application
\[
  \xor : \bin^t \times \bin^t \to \bin^t
\]
définie par $(x,y) \mapsto (x_0 \oplus y_0, \dots, x_{t-1} \oplus y_{t-1})$, où $\oplus$ désigne l'addition dans $\F_2$.
\end{definition}

\begin{definition}[Encodage big-endian]
Pour $t\in\N$ et $b=(b_{t-1},\dots,b_0)\in\bin^t$, on définit
\[
  \mathrm{val}_{\mathrm{be}}(b) = \sum_{j=0}^{t-1} b_j\,2^{t-1-j}
  \in \{0,\dots,2^t-1\}.
\]
Cet encodage fournit une bijection canonique entre $\bin^t$ et
$\{0,\dots,2^t-1\}$.
\end{definition}

\begin{definition}[Encodage little-endian]
Pour $t\in\N$ et $b=(b_{t-1},\dots,b_0)\in\bin^t$, on définit
\[
  \mathrm{val}_{\mathrm{le}}(b) = \sum_{j=0}^{t-1} b_j\,2^{j}
  \in \{0,\dots,2^t-1\}.
\]
Cet encodage est utilisé dans les standards Ed25519.
\end{definition}

\begin{remark}[Convention d'écriture]
Dans la suite du document :
\begin{itemize}
\item L'encodage big-endian est utilisé pour :
  \begin{itemize}
    \item Le partage de Shamir (représentation des éléments de $\F_P$)
    \item Les représentations internes dans $\F_p$ pour RSA
    \item Les compteurs AES-GCM
  \end{itemize}
\item L'encodage little-endian est utilisé pour :
  \begin{itemize}
    \item Ed25519 (scalaires et points)
    \item Certaines opérations internes d'AES
  \end{itemize}
\item Le contexte déterminera clairement quel encodage est employé
\end{itemize}
\end{remark}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Secret maître et schéma de Shamir}

\subsection{Secret maître}

\begin{definition}[Secret maître]
On fixe un entier
\[
  P = 2^{521} - 1
\]
et le corps $\F_P$. Le secret maître est un mot binaire
\[
  S\in\bin^{256}
\]
tiré uniformément. On définit
\[
  s_0 = \mathrm{val}_{\mathrm{be}}(S) \in \{0,\dots,2^{256}-1\},\qquad
  s = s_0 \bmod P \in \F_P.
\]
Comme $P > 2^{256}-1$, on a $s = s_0$ dans $\F_P$, ce qui garantit que l'application $S \mapsto s$ est une injection de $\bin^{256}$ dans $\F_P$.
\end{definition}

Ainsi, $S$ est la représentation binaire utilisée pour la dérivation de
clés, et $s\in\F_P$ est la représentation dans le corps fini utilisée pour
le partage de secret.

\subsection{Schéma $(k,n)$ de Shamir}

\begin{definition}[Partage de Shamir]
Soient des entiers $n,k$ vérifiant $2\le k\le n$ et $n < P$. On définit le schéma
$(k,n)$ de Shamir sur $\F_P$ comme suit.
\begin{itemize}[leftmargin=2em]
  \item À partir de $s\in\F_P$, on choisit indépendamment et uniformément
        $a_1,\dots,a_{k-1}\in\F_P$.
  \item On définit
  \[
    f(X) = s + a_1X + a_2X^2 + \dots + a_{k-1}X^{k-1}\in\mathcal{P}_{<k}.
  \]
  \item Pour $i\in\{1,\dots,n\}$, on fixe $x_i=i\in\F_P$ (en identifiant l'entier $i$ à son image dans $\F_P$) et on pose
  \[
    y_i = f(x_i)\in\F_P.
  \]
  \item La part $i$-ème est le couple $(x_i,y_i)\in\F_P^2$.
\end{itemize}
\end{definition}

\begin{definition}[Algorithmes Share et Reconstruct]
On définit formellement les applications :
\begin{itemize}
\item $\mathrm{Share}: \F_P \to (\F_P^2)^n$ qui à $s$ associe la famille $((x_i,y_i))_{1\le i\le n}$.
\item $\mathrm{Reconstruct}: (\F_P^2)^k \to \F_P$ qui, à $k$ points distincts $(x_{i_j},y_{i_j})$, associe $s=f(0)$ obtenu par interpolation de Lagrange.
\end{itemize}
\end{definition}

\begin{theorem}[Unicité de l'interpolation]
\label{thm:lagrange}
Soient $x_1,\dots,x_k \in \F_P$ deux à deux distincts et
$y_1,\dots,y_k\in\F_P$. Il existe un unique $f\in\mathcal{P}_{<k}$ tel que
$f(x_j)=y_j$ pour tout $j\in\{1,\dots,k\}$.
\end{theorem}

\begin{proof}
Par le lemme~\ref{lem:racines-poly} sur le nombre de racines, deux polynômes de degré $<k$
coïncidant en $k$ points distincts sont égaux. L'existence s'obtient par la
formule d'interpolation de Lagrange :
\[
  f(X) = \sum_{j=1}^k y_j \ell_j(X),\qquad
  \ell_j(X) = \prod_{\substack{m=1\\ m\neq j}}^k
  \frac{X-x_m}{x_j-x_m}\in\F_P[X].
\]
Les dénominateurs $x_j-x_m$ sont inversibles dans $\F_P$ car les $x_j$ sont distincts. On vérifie $\ell_j(x_i)=\delta_{ij}$, d'où $f(x_j)=y_j$.
\end{proof}

\begin{propriete}[Reconstruction du secret]
\label{prop:reconstruction}
Soit $I=\{i_1,\dots,i_k\}$ avec $i_1<\dots<i_k$. Soit $f$ le polynôme
défini par le schéma de Shamir. Alors
\[
  s = f(0)
  = \sum_{j=1}^k y_{i_j}\,\lambda_j,\qquad
  \lambda_j = \ell_j(0) = \prod_{\substack{m=1\\ m\neq j}}^k
   \frac{-x_{i_m}}{x_{i_j}-x_{i_m}} \in \F_P.
\]
\end{propriete}

\begin{proof}
On applique le théorème~\ref{thm:lagrange} avec
$(x_j,y_j)=(x_{i_j},y_{i_j})$. On obtient
\[
  f(X) = \sum_{j=1}^k y_{i_j}\,\ell_j(X).
\]
Comme $f(X)=s + a_1X + \dots + a_{k-1}X^{k-1}$, on a $f(0)=s$. En évaluant en $X=0$, on obtient
\[
  s=f(0)=\sum_{j=1}^k y_{i_j}\ell_j(0),
\]
avec $\lambda_j=\ell_j(0)$.
\end{proof}

\subsection{Confidentialité parfaite du schéma de Shamir}

\begin{proposition}
\label{prop:perfect-secrecy}
Soit $t<k$ et $I=\{i_1,\dots,i_t\}\subset\{1,\dots,n\}$. On suppose que
$(s,a_1,\dots,a_{k-1})$ est uniforme dans $\F_P^k$. Alors, pour toute réalisation
fixée des parts $\bigl( (x_{i_j},y_{i_j}) \bigr)_{1\le j\le t}$ et pour
tous $s_0,s_1\in\F_P$,
\[
  \mathbb{P}[s = s_0 \mid (x_{i_j},y_{i_j})]
  = \mathbb{P}[s = s_1 \mid (x_{i_j},y_{i_j})].
\]
En particulier, la loi a posteriori de $s$ conditionnellement à $t<k$ parts
reste uniforme sur $\F_P$.
\end{proposition}

\begin{proof}
Les $t$ équations $f(x_{i_j})=y_{i_j}$ forment un système linéaire de rang $t$ (la matrice de Vandermonde partielle est de rang plein car les $x_{i_j}$ sont distincts). Ce système impose $t$ contraintes indépendantes sur les $k$ variables $(s,a_1,\dots,a_{k-1})$.

Pour toute valeur fixée $s_0 \in \F_P$, le système restreint aux $(a_1,\dots,a_{k-1})$ a $t$ équations indépendantes sur $k-1$ variables, donc admet exactement $P^{k-1-t}$ solutions. Ce nombre est indépendant de $s_0$.

Par Bayes et l'uniformité a priori sur $\F_P^k$ :
\[
\mathbb{P}[s = s_0 \mid \text{parts}] = \frac{\mathbb{P}[\text{parts} \mid s = s_0] \cdot \mathbb{P}[s = s_0]}{\mathbb{P}[\text{parts}]} = \frac{P^{-t} \cdot P^{-1}}{P^{-t}} = \frac{1}{P}.
\]
Ainsi, la loi conditionnelle reste uniforme sur $\F_P$.
\end{proof}

%=========================================================
\section{Fonctions de hachage, HMAC, HKDF, PBKDF2}

\subsection{Fonction de hachage}

\begin{definition}[Fonction de hachage cryptographique]
Une fonction de hachage cryptographique est une application
\[
  h : \bin^* \to \bin^d,
\]
pour un $d$ fixé, qui doit satisfaire les propriétés suivantes :
\begin{itemize}
  \item \textbf{Résistance à la préimage} : Étant donné $y \in \bin^d$, il est difficile de trouver $x$ tel que $h(x) = y$.
  \item \textbf{Résistance à la seconde préimage} : Étant donné $x$, il est difficile de trouver $x' \neq x$ tel que $h(x) = h(x')$.
  \item \textbf{Résistance aux collisions} : Il est difficile de trouver $x \neq x'$ tels que $h(x) = h(x')$.
\end{itemize}
Dans ce document, $h$ désigne une telle fonction fixée une fois pour toutes (typiquement SHA-256 avec $d=256$).
\end{definition}

\subsection{Fonction de hachage cryptographique SHA-256}

\begin{definition}[SHA-256 selon FIPS 180-4 \cite{fips180-4}]
SHA-256 est une fonction de hachage cryptographique de la famille SHA-2 qui produit une empreinte de 256 bits. Elle opère sur des blocs de 512 bits en utilisant une structure de Merkle-Damgård avec renforcement de Merkle.

Soit $M \in \bin^*$ un message de longueur $L$ bits. L'algorithme procède comme suit :
\begin{enumerate}
  \item \textbf{Préparation du message} : Ajout d'un bit $1$, de $k$ bits $0$, et de la longueur $L$ encodée sur 64 bits (big-endian), où $k$ est le plus petit entier non négatif tel que la longueur totale soit un multiple de 512.
  \item \textbf{Découpage} : Division du message préparé en $N$ blocs de 512 bits : $M^{(1)}, M^{(2)}, \dots, M^{(N)}$.
  \item \textbf{Initialisation} : Définition de 8 variables de 32 bits initialisées avec des constantes spécifiques (les racines carrées des 8 premiers nombres premiers).
  \item \textbf{Boucle de compression} : Application itérative d'une fonction de compression $C$ à chaque bloc, mettant à jour les 8 variables.
  \item \textbf{Sortie} : Concaténation des 8 variables finales (chacune de 32 bits) pour former l'empreinte de 256 bits.
\end{enumerate}
\end{definition}

\paragraph{Préparation du message et découpage}

\begin{definition}[Padding SHA-256]
Soit $M \in \bin^*$ un message de longueur $L$ bits. On construit le message préparé $M'$ comme suit :
\[
M' = M \parallel 1 \parallel 0^k \parallel \mathrm{len}_{64}(L)
\]
où :
\begin{itemize}
  \item $1$ est un bit unique de valeur $1$,
  \item $0^k$ est une suite de $k$ bits $0$, avec $k$ choisi tel que $L + 1 + k + 64 \equiv 0 \pmod{512}$,
  \item $\mathrm{len}_{64}(L)$ est la représentation binaire de $L$ sur 64 bits en convention \emph{big-endian}.
\end{itemize}
Le message $M'$ a ainsi une longueur multiple de 512 bits.
\end{definition}

\begin{definition}[Découpage en blocs de 512 bits]
Le message préparé $M'$ est divisé en $N$ blocs de 512 bits :
\[
M' = M^{(1)} \parallel M^{(2)} \parallel \dots \parallel M^{(N)}.
\]
Chaque bloc $M^{(i)}$ est interprété comme 16 mots de 32 bits $M_0^{(i)}, M_1^{(i)}, \dots, M_{15}^{(i)}$ en lecture \emph{big-endian} :
\[
M^{(i)} = M_0^{(i)} \parallel M_1^{(i)} \parallel \dots \parallel M_{15}^{(i)}.
\]
\end{definition}

\paragraph{Constantes et fonctions internes}

\begin{definition}[Constantes initiales SHA-256]
Les 8 variables initiales (registres) sont définies par les constantes suivantes (en hexadécimal) :
\begin{align*}
H_0^{(0)} &= \mathtt{6a09e667} & H_1^{(0)} &= \mathtt{bb67ae85} \\
H_2^{(0)} &= \mathtt{3c6ef372} & H_3^{(0)} &= \mathtt{a54ff53a} \\
H_4^{(0)} &= \mathtt{510e527f} & H_5^{(0)} &= \mathtt{9b05688c} \\
H_6^{(0)} &= \mathtt{1f83d9ab} & H_7^{(0)} &= \mathtt{5be0cd19}
\end{align*}
Ces valeurs correspondent aux 32 bits de poids fort des parties fractionnaires des racines carrées des 8 premiers nombres premiers.
\end{definition}

\begin{definition}[Constantes de tour SHA-256]
Chaque tour $t$ (avec $0 \leq t \leq 63$) utilise une constante $K_t$ de 32 bits, définie comme les 32 bits de poids fort des parties fractionnaires des racines cubiques des 64 premiers nombres premiers. Les premières constantes sont :
\begin{align*}
K_0 &= \mathtt{428a2f98} & K_1 &= \mathtt{71374491} & K_2 &= \mathtt{b5c0fbcf} & K_3 &= \mathtt{e9b5dba5} \\
K_4 &= \mathtt{3956c25b} & K_5 &= \mathtt{59f111f1} & K_6 &= \mathtt{923f82a4} & K_7 &= \mathtt{ab1c5ed5} \\
K_8 &= \mathtt{d807aa98} & K_9 &= \mathtt{12835b01} & K_{10} &= \mathtt{243185be} & K_{11} &= \mathtt{550c7dc3} \\
K_{12} &= \mathtt{72be5d74} & K_{13} &= \mathtt{80deb1fe} & K_{14} &= \mathtt{9bdc06a7} & K_{15} &= \mathtt{c19bf174} \\
& \vdots & & \vdots & & \vdots & & \vdots
\end{align*}
\end{definition}

\begin{definition}[Fonctions internes SHA-256]
Pour des mots de 32 bits $x, y, z$, on définit les fonctions suivantes :
\begin{align*}
\mathrm{Ch}(x,y,z) &= (x \land y) \oplus (\neg x \land z) & &\text{(choix)} \\
\mathrm{Maj}(x,y,z) &= (x \land y) \oplus (x \land z) \oplus (y \land z) & &\text{(majorité)} \\
\Sigma_0(x) &= \mathrm{ROTR}^{2}(x) \oplus \mathrm{ROTR}^{13}(x) \oplus \mathrm{ROTR}^{22}(x) \\
\Sigma_1(x) &= \mathrm{ROTR}^{6}(x) \oplus \mathrm{ROTR}^{11}(x) \oplus \mathrm{ROTR}^{25}(x) \\
\sigma_0(x) &= \mathrm{ROTR}^{7}(x) \oplus \mathrm{ROTR}^{18}(x) \oplus \mathrm{SHR}^{3}(x) \\
\sigma_1(x) &= \mathrm{ROTR}^{17}(x) \oplus \mathrm{ROTR}^{19}(x) \oplus \mathrm{SHR}^{10}(x)
\end{align*}
où $\mathrm{ROTR}^n$ désigne la rotation vers la droite de $n$ bits, $\mathrm{SHR}^n$ le décalage vers la droite de $n$ bits (remplissage par des zéros), $\land$ le ET bit à bit, $\oplus$ le XOR, et $\neg$ la négation bit à bit.
\end{definition}

\paragraph{Planning des mots}

\begin{definition}[Planning des mots]
Pour chaque bloc $M^{(i)}$, on construit 64 mots de 32 bits $W_0, \dots, W_{63}$ appelés planning des mots. Les 16 premiers mots sont les 16 mots du bloc courant :
\[
W_t = M_t^{(i)} \quad \text{pour } 0 \leq t \leq 15.
\]
Les 48 mots suivants sont calculés récursivement pour $16 \leq t \leq 63$ :
\[
W_t = \sigma_1(W_{t-2}) \boxplus W_{t-7} \boxplus \sigma_0(W_{t-15}) \boxplus W_{t-16},
\]
où $\boxplus$ désigne l'addition modulo $2^{32}$.
\end{definition}

\paragraph{Fonction de compression}

\begin{definition}[Fonction de compression SHA-256]
La fonction de compression $C$ prend en entrée un état de 256 bits (représenté par 8 mots de 32 bits $H^{(i-1)} = (H_0^{(i-1)}, \dots, H_7^{(i-1)})$) et un bloc de message $M^{(i)}$ de 512 bits, et produit un nouvel état $H^{(i)}$ de 256 bits.

\medskip

\textbf{Algorithme de la fonction de compression} :
\begin{enumerate}
  \item Préparer le planning des mots $W_0, \dots, W_{63}$ à partir de $M^{(i)}$.
  \item Initialiser 8 variables de travail $(a,b,c,d,e,f,g,h)$ avec l'état courant :
        \[
        \begin{aligned}
        a &\gets H_0^{(i-1)}, \quad b \gets H_1^{(i-1)}, \quad c \gets H_2^{(i-1)}, \quad d \gets H_3^{(i-1)}, \\
        e &\gets H_4^{(i-1)}, \quad f \gets H_5^{(i-1)}, \quad g \gets H_6^{(i-1)}, \quad h \gets H_7^{(i-1)}.
        \end{aligned}
        \]
  \item Pour $t = 0$ à $63$ :
        \begin{align*}
        T_1 &\gets h \boxplus \Sigma_1(e) \boxplus \mathrm{Ch}(e,f,g) \boxplus K_t \boxplus W_t, \\
        T_2 &\gets \Sigma_0(a) \boxplus \mathrm{Maj}(a,b,c), \\
        h &\gets g, \quad g \gets f, \quad f \gets e, \quad e \gets d \boxplus T_1, \\
        d &\gets c, \quad c \gets b, \quad b \gets a, \quad a \gets T_1 \boxplus T_2.
        \end{align*}
  \item Mettre à jour l'état par addition modulo $2^{32}$ :
        \[
        \begin{aligned}
        H_0^{(i)} &\gets H_0^{(i-1)} \boxplus a, \quad H_1^{(i)} \gets H_1^{(i-1)} \boxplus b, \\
        H_2^{(i)} &\gets H_2^{(i-1)} \boxplus c, \quad H_3^{(i)} \gets H_3^{(i-1)} \boxplus d, \\
        H_4^{(i)} &\gets H_4^{(i-1)} \boxplus e, \quad H_5^{(i)} \gets H_5^{(i-1)} \boxplus f, \\
        H_6^{(i)} &\gets H_6^{(i-1)} \boxplus g, \quad H_7^{(i)} \gets H_7^{(i-1)} \boxplus h.
        \end{aligned}
        \]
\end{enumerate}
\end{definition}

\paragraph{Algorithme complet et sortie}

\begin{definition}[Algorithme SHA-256]
Les étapes sont :
\begin{enumerate}
  \item \textbf{Préparation} : Construire $M'$ à partir du message $M$ en appliquant le padding.
  \item \textbf{Découpage} : Diviser $M'$ en $N$ blocs de 512 bits $M^{(1)}, \dots, M^{(N)}$.
  \item \textbf{Initialisation} : Initialiser l'état $H^{(0)}$ avec les 8 constantes initiales.
  \item \textbf{Boucle sur les blocs} : Pour $i = 1$ à $N$, appliquer la fonction de compression $C$ :
        \[
        H^{(i)} = C(H^{(i-1)}, M^{(i)}).
        \]
  \item \textbf{Sortie} : L'empreinte finale de 256 bits est la concaténation des 8 mots de 32 bits de l'état final $H^{(N)}$ en ordre \emph{big-endian} :
        \[
        \text{SHA-256}(M) = H_0^{(N)} \parallel H_1^{(N)} \parallel H_2^{(N)} \parallel H_3^{(N)} \parallel H_4^{(N)} \parallel H_5^{(N)} \parallel H_6^{(N)} \parallel H_7^{(N)}.
        \]
\end{enumerate}
\end{definition}



\subsection{HMAC}

\begin{definition}[Longueur de bloc et masques internes]
On fixe un entier $k_{\mathrm{blk}}\in\mathbb{N}^*$, appelé longueur de bloc
de HMAC. On se donne deux mots binaires
\[
  \mathsf{ipad},\,\mathsf{opad} \in \{0,1\}^{k_{\mathrm{blk}}}
\]
appelés respectivement masque interne et masque externe. Dans
les spécifications usuelles \cite{rfc2104}, ce sont les octets $0x36$ (pour \(\mathsf{ipad}\))
et $0x5C$ (pour \(\mathsf{opad}\)) répétés de façon à obtenir $k_{\mathrm{blk}}$
bits.
\end{definition}

\begin{definition}[Normalisation de clé pour HMAC]
On définit une application
\[
  \mathrm{NormKey} : \{0,1\}^* \to \{0,1\}^{k_{\mathrm{blk}}}
\]
qui, pour toute clé $K\in\{0,1\}^*$,
\begin{itemize}[leftmargin=2em]
  \item si $\lVert K\rVert > k_{\mathrm{blk}}$, alors $K_{\mathrm{blk}} = \mathrm{troncature}(h(K))$ aux $k_{\mathrm{blk}}$ premiers bits ;
  \item si $\lVert K\rVert < k_{\mathrm{blk}}$, alors $K_{\mathrm{blk}} = K \concat 0^{k_{\mathrm{blk}} - \lVert K\rVert}$ ;
  \item si $\lVert K\rVert = k_{\mathrm{blk}}$, alors $K_{\mathrm{blk}} = K$.
\end{itemize}
Ainsi, pour tout $K\in\{0,1\}^*$, la valeur $\mathrm{NormKey}(K)$ est un mot
binaire de longueur exactement $k_{\mathrm{blk}}$.
\end{definition}

\begin{definition}[HMAC basé sur $h$]
On fixe une fonction de hachage
\[
  h : \{0,1\}^* \to \{0,1\}^d.
\]
On définit la fonction
\[
  \HMAC_h : \{0,1\}^* \times \{0,1\}^* \to \{0,1\}^d
\]
par la formule :
\[
  \HMAC_h(K,M)
  = h\bigl( (\mathrm{NormKey}(K) \xor \mathsf{opad}) \concat
           h\bigl( (\mathrm{NormKey}(K) \xor \mathsf{ipad}) \concat M \bigr)
      \bigr).
\]
\end{definition}

\subsection{Fonction d'encodage d'entier}

\begin{definition}[Fonction $\mathrm{INT}_4$]
On définit l'application
\[
  \mathrm{INT}_4 : \{0,\dots,2^{32}-1\} \to \bin^{32}
\]
qui à un entier $i$ associe son encodage big-endian sur 4~octets (32~bits) :
\[
\mathrm{INT}_4(i) = (b_{31}b_{30}\dots b_0) \text{ où } i = \sum_{j=0}^{31} b_j 2^{31-j}.
\]
\end{definition}

\begin{remark}[Lien avec la RFC~5869]
Dans la spécification HKDF de la RFC~5869 \cite{rfc5869}, le compteur de bloc $i$ est encodé sur
\emph{un seul octet} (valeurs $0x01,\dots,0xFF$), noté usuellement $\mathrm{INT}(i)$, et
l'on impose $L \le 255\cdot\text{hashLen}$.

Dans ce texte, nous écrivons $\mathrm{INT}_4(i)$ comme une formalisation générique
\og sur 4 octets \fg. Dans le cas concret de HKDF, cela ne change rien au comportement :
le compteur reste borné par $1 \le i \le 255$, si bien que l'encodage sur 1 octet
(conforme à la RFC) ou sur 4 octets est conceptuellement équivalent. En pratique,
l'implémentation Python utilisée suit strictement la RFC et encode $i$ sur un seul octet.
\end{remark}

\subsection{HKDF}
\label{sec:hkdf}

\begin{definition}[HKDF (HMAC-based Key Derivation Function) \cite{rfc5869}]
Soit $h:\bin^*\to\bin^d$ une fonction de hachage. On définit la fonction de dérivation de clé HKDF selon RFC~5869 :
\[
  \HKDF_h : \bin^* \times \bin^* \times \bin^* \times \N \to \bin^L
\]
comme suit. Soient $\mathrm{IKM}\in\bin^*$ (input keying material), $\mathrm{salt}\in\bin^*$, $\mathrm{info}\in\bin^*$, et $L\in\N$ (longueur de sortie en octets). On pose :
\begin{itemize}
\item \textbf{Étape d'extraction} : 
  \[
    \mathrm{PRK} = \HMAC_h(\mathrm{salt}, \mathrm{IKM}) \in \bin^d.
  \]
\item \textbf{Étape d'expansion} : on définit itérativement, pour $i = 1,2,\dots$ jusqu'à obtenir $L$ octets,
  \begin{align*}
  T_1 &= \HMAC_h\bigl(\mathrm{PRK},\ \mathrm{info} \concat \mathrm{INT}_4(1)\bigr), \\
  T_2 &= \HMAC_h\bigl(\mathrm{PRK},\ T_1 \concat \mathrm{info} \concat \mathrm{INT}_4(2)\bigr), \\
      &\ \vdots \\
  T_i &= \HMAC_h\bigl(\mathrm{PRK},\ T_{i-1} \concat \mathrm{info} \concat \mathrm{INT}_4(i)\bigr).
  \end{align*}
\item \textbf{Sortie} : la clé dérivée est le préfixe aux $L$ octets de la concaténation
  \[
    T_1 \concat T_2 \concat \dots
  \]
  avec la contrainte $L \le 255\cdot d$ comme dans la RFC~5869.
\end{itemize}
Dans le cas standard où l'on suit la RFC, le compteur $i$ est encodé sur \emph{un octet}
($\mathrm{INT}(i)$) et non sur 4~octets ; la notation $\mathrm{INT}_4(i)$ ci-dessus doit se
lire comme une écriture générique, valable aussi pour d'autres constructions où un
compteur sur 32~bits est utile.
\end{definition}

\subsection{PBKDF2}

\begin{definition}[PBKDF2 (Password-Based Key Derivation Function 2) \cite{rfc8018}]
On fixe un paramètre d'itération $c\in\N^*$ et un hachage $h$. On définit
\[
  \PBKDF_h : \bin^* \times \bin^* \times \N^* \times \N \to \bin^{8L}
\]
où $L$ est le nombre d'octets souhaités. Pour un mot de passe $P\in\bin^*$, un sel $S\in\bin^*$ et un entier $L\ge 1$, on
définit, pour $i\ge 1$ :
\[
  U_1 = \HMAC_h(P,\,S\concat \mathrm{INT}_4(i)),
\]
\[
  U_j = \HMAC_h(P,\,U_{j-1})\quad(2\le j\le c),
\]
puis
\[
  F(P,S,c,i) = U_1 \xor U_2 \xor \dots \xor U_c.
\]
La sortie de PBKDF2 est le préfixe aux $8L$ bits de la concaténation
\[
  F(P,S,c,1)\concat F(P,S,c,2)\concat \dots
\]
\end{definition}

\begin{remark}[Résumé des fonctions de hachage utilisées]
Dans toute la suite, on distingue clairement deux fonctions de hachage :

\begin{itemize}
  \item $\mathrm{SHA\text{-}256}$ sert de fonction $h$ pour HKDF, PBKDF2, MGF1 et RSA-OAEP
        (sections~\ref{sec:hkdf} et~\ref{sec:rsa-oaep}), ainsi que pour les empreintes
        génériques de fichiers et d'identifiants publics.
  \item $\mathrm{SHA\text{-}512}$ est utilisée exclusivement à l'intérieur du schéma
        Ed25519 :
        d'une part pour dériver la clé secrète étendue à partir de $K_{\mathrm{Ed}}$~\ref{sec:init},
        et d'autre part pour incorporer le message $M$ dans la signature~\ref{sec:sig-ed} via
        les valeurs intermédiaires $r = \mathrm{SHA\text{-}512}(\text{prefix} \,\|\, M)$
        et $k = \mathrm{SHA\text{-}512}(R \,\|\, A \,\|\, M)$.
\end{itemize}

Cette séparation évite toute ambiguïté : sauf mention explicite contraire, $h$ désigne
$\mathrm{SHA\text{-}256}$, tandis que les appels à $\mathrm{SHA\text{-}512}$ sont toujours
associés à Ed25519.
\end{remark}


%=========================================================

\section{Structure de groupe et signature Ed25519}
\label{sec:ed25519}

\subsection{Courbe elliptique Ed25519}

\begin{definition}[Courbe elliptique Ed25519 (Edwards-curve Digital Signature Algorithm) \cite{rfc8032}]
Soit $q = 2^{255} - 19$ et $\F_q$ le corps fini correspondant. La courbe elliptique Ed25519 est définie par l'équation de Twisted Edwards :
\[
E: -x^2 + y^2 = 1 + dx^2y^2 \quad \text{sur } \F_q
\]
où $d = -\frac{121665}{121666} \in \F_q$, avec la division interprétée comme la multiplication par l'inverse modulo $q$.
\end{definition}

\begin{definition}[Loi de groupe sur $E(\F_q)$]
Soient $P_1 = (x_1, y_1)$ et $P_2 = (x_2, y_2)$ deux points de $E(\F_q)$. L'addition est définie par :
\[
P_1 + P_2 = (x_3, y_3) = \left(
\frac{x_1y_2 + y_1x_2}{1 + dx_1x_2y_1y_2},
\frac{y_1y_2 + x_1x_2}{1 - dx_1x_2y_1y_2}
\right)
\]
où toutes les opérations arithmétiques sont effectuées dans $\F_q$. L'élément neutre est le point $\mathcal{O} = (0, 1)$.
\end{definition}

\begin{proposition}[Cardinal du groupe]
Le groupe $E(\F_q)$ est abélien fini de cardinal :
\[
\#E(\F_q) = 8\ell
\]
où $\ell$ est le nombre premier $\ell = 2^{252} + 27742317777372353535851937790883648493$.
\end{proposition}

\begin{remark}[Admission du cardinal]
Le calcul du cardinal de la courbe Ed25519 est admis. Il peut être obtenu par l'algorithme de Schoof-Elkies-Atkin (SEA) et a été vérifié de manière indépendante par plusieurs implémentations.
\end{remark}

\begin{definition}[Point de base standard Ed25519]
On fixe le point de base standard $B \in E(\F_q)$ d'ordre $\ell$, dont les coordonnées affines sont :
\begin{align*}
y_B &= 46316835694926478169428394003475163141307993866256225615783033603165251855960 \\
x_B &= 15112221349535400772501151409588531511454012693041857206046113283949847762202
\end{align*}
Ces valeurs satisfont l'équation de la courbe.
\end{definition}

\begin{remark}[Admission de l'ordre du point de base]
L'ordre premier $\ell$ du point de base $B$ est admis. Cette propriété essentielle pour la sécurité cryptographique a été vérifiée par la communauté.
\end{remark}

\begin{definition}[Sous-groupe cyclique principal]
Le sous-groupe cyclique d'ordre $\ell$ est :
\[
\langle B \rangle = \{aB \mid a \in \mathbb{Z}_\ell\}
\]
où $aB$ désigne l'addition $B$ avec elle-même $a$ fois (avec la convention $0B = \mathcal{O}$).
\end{definition}

\begin{proposition}[Isomorphisme $\Z_\ell \simeq \langle B \rangle$]
\label{prop:iso-z-ell-b}
L'application
\[
\psi : \Z_\ell \to \langle B \rangle, \quad a \mapsto aB
\]
est un isomorphisme de groupes. Plus précisément :
\begin{enumerate}
  \item $\psi$ est un homomorphisme de groupes.
  \item $\ker(\psi) = \{0\}$ (injectivité).
  \item $\psi$ est surjectif par définition de $\langle B \rangle$.
\end{enumerate}
\end{proposition}

\begin{proof}
Vérifions les propriétés :
\begin{enumerate}
  \item \textbf{Homomorphisme} : Pour tous $a, b \in \Z_\ell$, on a 
        \[
        \psi(a + b) = (a + b)B = aB + bB = \psi(a) + \psi(b),
        \]
        où l'addition dans $\Z_\ell$ est modulo $\ell$ et l'addition dans $\langle B \rangle$ est l'addition de points sur la courbe elliptique.
  
  \item \textbf{Noyau} : Soit $a \in \Z_\ell$ tel que $\psi(a) = \mathcal{O}$ (élément neutre). Alors $aB = \mathcal{O}$. Puisque $B$ est d'ordre $\ell$, cela implique que $\ell$ divise $a$. Comme $a \in \{0, \dots, \ell-1\}$, on a nécessairement $a = 0$. Donc $\ker(\psi) = \{0\}$.
  
  \item \textbf{Surjectivité} : Par définition, $\langle B \rangle = \{aB \mid a \in \Z_\ell\}$, donc tout élément de $\langle B \rangle$ est de la forme $aB$ pour un certain $a \in \Z_\ell$, c'est-à-dire $\psi(a)$.
\end{enumerate}
Ainsi, $\psi$ est un isomorphisme de groupes.
\end{proof}

\begin{remark}[Interprétation du premier théorème d'isomorphisme]
Le premier théorème d'isomorphisme pour les groupes (Théorème~\ref{thm:iso-groupes}) permet d'interpréter cet isomorphisme. Pour $G = \Z_\ell$, $H = \langle B \rangle$, et $f = \psi$, on a :
\begin{itemize}
  \item $\ker(\psi) = \{0\}$ qui est un sous-groupe distingué de $\Z_\ell$
  \item $\mathrm{Im}(\psi) = \langle B \rangle$
  \item Par le théorème : $\Z_\ell/\ker(\psi) \simeq \mathrm{Im}(\psi)$, c'est-à-dire $\Z_\ell/\{0\} \simeq \langle B \rangle$.
\end{itemize}
Comme le quotient $\Z_\ell/\{0\}$ est canoniquement isomorphe à $\Z_\ell$ lui-même, on retrouve bien l'isomorphisme $\Z_\ell \simeq \langle B \rangle$.
\end{remark}

\begin{remark}[Utilisation cryptographique]
Seuls les points du sous-groupe $\langle B \rangle$ d'ordre premier $\ell$ sont utilisés pour la cryptographie. Le clampage dans Ed25519 garantit que les scalaires appartiennent à $\mathbb{Z}_\ell$, et l'isomorphisme $\Z_\ell \simeq \langle B \rangle$ assure que chaque scalaire correspond à un unique point du sous-groupe, et réciproquement.
\end{remark}

\subsection{Encodage des points et scalaires}

\begin{definition}[Encodage des points et scalaires]
L'encodage canonique d'un point $P = (x, y) \in E(\F_q)$ est défini par :
\[
\mathrm{enc}(P) = \mathrm{bytes}_{\mathrm{le}}(y) \concat p \in \bin^{256}
\]
où $\mathrm{bytes}_{\mathrm{le}}(y)$ est la représentation little-endian de $y$ sur 255 bits (32 octets, le bit de poids fort ignoré), et $p$ est le bit de parité de $x$, c'est-à-dire le bit le moins significatif de $x$.

L'encodage d'un scalaire $s \in \mathbb{Z}_\ell$ est sa représentation little-endian sur 32 octets.
\end{definition}

\begin{remark}[Encodage compressé]
L'encodage utilisé pour Ed25519 est l'encodage compressé standard où seul le coordonnée $y$ est stockée avec un bit de parité pour permettre la reconstruction de $x$. L'encodage est en little-endian conformément au standard \cite{rfc8032}.
\end{remark}

\subsection{Décodage des points Ed25519}

\begin{definition}[Symbole de Legendre]
Soit $p$ un nombre premier impair et $a$ un entier. Le symbole de Legendre $\left(\frac{a}{p}\right)$ est défini par :
\[
\left(\frac{a}{p}\right) = \begin{cases}
0 & \text{si } p \mid a \\
1 & \text{si } a \text{ est un carré modulo } p \\
-1 & \text{sinon}
\end{cases}
\]
\end{definition}

\begin{theorem}[Critère d'Euler]
\label{thm:euler-critere}
Soit $p$ un nombre premier impair et $a$ un entier non divisible par $p$. Alors :
\[
a^{(p-1)/2} \equiv \left(\frac{a}{p}\right) \pmod{p}
\]
En particulier, $a^{(p-1)/2} \equiv 1 \pmod{p}$ si et seulement si $a$ est un carré modulo $p$, et \\
$a^{(p-1)/2} \equiv -1 \pmod{p}$ si et seulement si $a$ n'est pas un carré modulo $p$.
\end{theorem}

\begin{proof}
Si $a$ est un carré modulo $p$, alors $a \equiv b^2 \pmod{p}$ pour un $b$ non divisible par $p$, donc $a^{(p-1)/2} \equiv b^{p-1} \equiv 1 \pmod{p}$ par le théorème de Fermat (\ref{thm:fermat}).

Réciproquement, dans $\F_p^*$ qui est cyclique d'ordre $p-1$, considérons l'homomorphisme $\phi: x \mapsto x^2$. Son noyau est $\{\pm 1\}$ d'ordre 2, donc son image (les carrés) est d'ordre $(p-1)/2$. L'équation $x^{(p-1)/2} = 1$ a au plus $(p-1)/2$ solutions, et tous les carrés la vérifient. Donc les non-carrés vérifient $a^{(p-1)/2} = -1$.
\end{proof}

\begin{lemma}[Lemme de Gauss pour les résidus quadratiques]
\label{lem:gauss-quadratic}
Soit $p$ un nombre premier impair et $a$ un entier non divisible par $p$. Considérons l'ensemble :
\[
A = \{a, 2a, 3a, \dots, \tfrac{p-1}{2}a\}
\]
Pour chaque élément $ka \in A$, on considère son \emph{résidu modulo $p$}, c'est-à-dire l'unique entier $r_k$ tel que $1 \leq r_k \leq p-1$ et $r_k \equiv ka \pmod{p}$.

On sépare ces résidus en deux groupes :
\begin{itemize}
\item Les résidus $r_1, \dots, r_k$ qui sont inférieurs ou égaux à $p/2$
\item Les résidus $s_1, \dots, s_\mu$ qui sont supérieurs à $p/2$
\end{itemize}
où $k$ est le nombre de résidus dans le premier groupe et $\mu$ est le nombre de résidus dans le second groupe. Alors :
\[
\left(\frac{a}{p}\right) = (-1)^\mu
\]
\end{lemma}

\begin{proof}
\textbf{Étape 1 : Les nombres $r_1, \dots, r_k, p-s_1, \dots, p-s_\mu$ sont distincts}

Les $r_i$ sont par définition dans $\{1, \dots, \lfloor p/2 \rfloor\}$. Pour les $s_j$, comme $s_j > p/2$, on a $p-s_j \in \{1, \dots, \lfloor p/2 \rfloor\}$.

Supposons par l'absurde qu'il existe $i,j$ tels que $r_i = p-s_j$. Alors :
\[
r_i + s_j = p
\]
Mais $r_i \equiv \alpha a \pmod{p}$ et $s_j \equiv \beta a \pmod{p}$ pour certains $\alpha, \beta \in \{1, \dots, \tfrac{p-1}{2}\}$. Donc :
\[
\alpha a + \beta a \equiv 0 \pmod{p} \quad \Rightarrow \quad (\alpha + \beta)a \equiv 0 \pmod{p}
\]
Puisque $p \nmid a$, on doit avoir $p \mid (\alpha + \beta)$. Mais $2 \leq \alpha + \beta \leq p-1$, contradiction.

Ainsi, ces $k + \mu = \tfrac{p-1}{2}$ nombres forment une permutation de $\{1, 2, \dots, \tfrac{p-1}{2}\}$.

\textbf{Étape 2 : Relations produits}

Le produit de tous les éléments de $\{1, 2, \dots, \tfrac{p-1}{2}\}$ est $\left(\tfrac{p-1}{2}\right)!$. Donc :
\[
r_1 \cdots r_k (p-s_1) \cdots (p-s_\mu) = \left(\frac{p-1}{2}\right)!
\]

Modulo $p$, on a $p-s_j \equiv -s_j \pmod{p}$, donc :
\[
r_1 \cdots r_k (p-s_1) \cdots (p-s_\mu) \equiv r_1 \cdots r_k (-s_1) \cdots (-s_\mu) = (-1)^\mu r_1 \cdots r_k s_1 \cdots s_\mu \pmod{p}
\]

Ainsi :
\[
(-1)^\mu r_1 \cdots r_k s_1 \cdots s_\mu \equiv \left(\frac{p-1}{2}\right)! \pmod{p} \tag{1}
\]

D'autre part, le produit des éléments de $A$ est :
\[
a \cdot 2a \cdot 3a \cdots \tfrac{p-1}{2}a = a^{(p-1)/2} \left(\frac{p-1}{2}\right)!
\]

Modulo $p$, ce produit est congru au produit des résidus des éléments de $A$, c'est-à-dire $r_1 \cdots r_k s_1 \cdots s_\mu$. Donc :
\[
a^{(p-1)/2} \left(\frac{p-1}{2}\right)! \equiv r_1 \cdots r_k s_1 \cdots s_\mu \pmod{p} \tag{2}
\]

\textbf{Étape 3 : Conclusion}

En substituant (2) dans (1), on obtient :
\[
(-1)^\mu a^{(p-1)/2} \left(\frac{p-1}{2}\right)! \equiv \left(\frac{p-1}{2}\right)! \pmod{p}
\]

Puisque $\left(\tfrac{p-1}{2}\right)!$ n'est pas divisible par $p$, on peut simplifier :
\[
(-1)^\mu a^{(p-1)/2} \equiv 1 \pmod{p} \quad \Rightarrow \quad a^{(p-1)/2} \equiv (-1)^\mu \pmod{p}
\]

Par le critère d'Euler (Théorème~\ref{thm:euler-critere}), on a $a^{(p-1)/2} \equiv \left(\frac{a}{p}\right) \pmod{p}$, donc :
\[
\left(\frac{a}{p}\right) = (-1)^\mu
\]
\end{proof}

\begin{lemma}[Caractère quadratique de 2]
Soit $q$ un nombre premier impair. Alors :
\[
\left(\frac{2}{q}\right) = (-1)^{\frac{q^2-1}{8}}
\]
En particulier, pour $q \equiv 5 \pmod{8}$, on a $\left(\frac{2}{q}\right) = -1$.
\end{lemma}

\begin{proof}
Nous appliquons le lemme~\ref{lem:gauss-quadratic} avec $a = 2$. Soit 
\[
A = \{2, 4, 6, \dots, 2\cdot\frac{q-1}{2}\} = \{2, 4, \dots, q-1\}
\]
Soit $\mu$ le nombre d'éléments de $A$ dont le reste modulo $q$ est supérieur à $q/2$. Alors par le lemme de Gauss :
\[
\left(\frac{2}{q}\right) = (-1)^\mu
\]

Les éléments de $A$ sont tous dans l'intervalle $[2, q-1]$. Un élément $2k$ (avec $1 \leq k \leq \frac{q-1}{2}$) a un reste modulo $q$ supérieur à $q/2$ si et seulement si $2k > q/2$, c'est-à-dire $k > q/4$.

Le nombre de tels $k$ est donc :
\[
\mu = \left\lfloor \frac{q-1}{2} \right\rfloor - \left\lfloor \frac{q}{4} \right\rfloor
\]

Écrivons $q = 8m + r$ avec $r \in \{1, 3, 5, 7\}$. Alors :
\[
\frac{q^2 - 1}{8} = \frac{(8m+r)^2 - 1}{8} = 8m^2 + 2mr + \frac{r^2 - 1}{8}
\]

D'autre part, calculons $\mu$ pour chaque cas :

\begin{itemize}
\item Si $q = 8m+1$, alors $\mu = 4m - 2m = 2m$ (pair)
\item Si $q = 8m+3$, alors $\mu = 4m+1 - 2m = 2m+1$ (impair)  
\item Si $q = 8m+5$, alors $\mu = 4m+2 - (2m+1) = 2m+1$ (impair)
\item Si $q = 8m+7$, alors $\mu = 4m+3 - (2m+1) = 2m+2$ (pair)
\end{itemize}

Donc $\left(\frac{2}{q}\right) = (-1)^\mu = (-1)^{\frac{q^2-1}{8}}$.

Pour $q \equiv 5 \pmod{8}$, on a $q = 8m+5$, donc $\frac{q^2-1}{8} = 8m^2 + 10m + 3$ qui est impair, donc $\left(\frac{2}{q}\right) = -1$.
\end{proof}

\begin{theorem}[Structure des racines carrées dans $\F_q$ pour $q \equiv 5 \pmod{8}$]
Soit $q = 2^{255} - 19$ et $a \in \F_q$ un élément non nul. Si $a$ est un carré dans $\F_q$, alors l'ensemble de ses racines carrées est $\{x, -x\}$ où :
\[
x = a^{(q+3)/8} \quad \text{ou} \quad x = a^{(q+3)/8} \cdot 2^{(q-1)/4}
\]
De plus, ces deux racines carrées ont des bits de parité opposés.
\end{theorem}

\begin{proof}
Soit $q = 2^{255} - 19 \equiv 5 \pmod{8}$. On peut écrire $q = 8k + 5$ avec $k \in \mathbb{Z}$, donc $(q+3)/8 = k+1$ est un entier.

Supposons que $a$ est un carré dans $\F_q$. Calculons $x_0 = a^{(q+3)/8}$ :
\[
x_0^2 = \left(a^{(q+3)/8}\right)^2 = a^{(q+3)/4} = a \cdot a^{(q-1)/4}
\]
Soit $b = a^{(q-1)/4}$. Puisque $a$ est un carré, le critère d'Euler (Théorème~\ref{thm:euler-critere}) donne $a^{(q-1)/2} = 1$, donc $b^2 = a^{(q-1)/2} = 1$, ce qui implique $b = \pm 1$.

On distingue deux cas :
\begin{itemize}
\item Si $b = 1$, alors $x_0^2 = a \cdot 1 = a$, donc $x_0$ est une racine carrée de $a$.
\item Si $b = -1$, alors $x_0^2 = a \cdot (-1) = -a$. Soit $i = 2^{(q-1)/4}$. Alors :
\[
i^2 = (2^{(q-1)/4})^2 = 2^{(q-1)/2}
\]
Par le lemme précédent, pour $q \equiv 5 \pmod{8}$, on a $\left(\frac{2}{q}\right) = -1$, donc par le critère d'Euler (Théorème~\ref{thm:euler-critere}), $2^{(q-1)/2} = -1$. Ainsi $i^2 = -1$ et $x = x_0 \cdot i$ vérifie $x^2 = x_0^2 \cdot i^2 = (-a) \cdot (-1) = a$, donc $x$ est une racine carrée de $a$.
\end{itemize}

Dans les deux cas, on obtient une racine carrée $x$ de $a$. L'autre racine carrée est $-x$. Puisque la caractéristique de $\F_q$ est différente de 2, on a $x \neq -x$. En effet, si $x = -x$, alors $2x = 0$, ce qui impliquerait $x = 0$, mais $a = x^2 = 0$, contradiction avec $a$ non nul.

De plus, les bits de parité de $x$ et $-x$ sont opposés. En effet, si on représente les éléments de $\F_q$ par des entiers entre $0$ et $q-1$, alors $-x$ est représenté par $q - x$. Comme $q$ est impair, $q - x$ a la parité opposée à $x$.
\end{proof}

\begin{definition}[Décodage des points Ed25519]
Le décodage d'un point compressé est l'application :
\[
\mathrm{dec}: \bin^{256} \to E(\F_q) \cup \{\perp\}
\]
définie comme suit. Soit $P_{\mathrm{enc}} \in \bin^{256}$ un point encodé :
\begin{enumerate}[leftmargin=2em]
  \item Interpréter $P_{\mathrm{enc}}$ comme un entier en little-endian $0 \le N < 2^{256}$. Noter $p$ le bit de poids fort de $N$ (bit d'indice 255), et $y$ l'entier obtenu en annulant ce bit, c'est-à-dire en prenant les 255 bits de poids faible. On identifie alors $y$ avec un élément de $\bin^{255}$ et $p \in \bin$.
  \item Interpréter $y$ (les 255 bits de poids faible) comme un élément de $\F_q$ (en little-endian) et le noter $y_P$.
  \item Calculer $x_P^2 = \frac{y_P^2 - 1}{d y_P^2 + 1}$ dans $\F_q$.
  \item Si $x_P^2$ n'est pas un carré dans $\F_q$, retourner $\perp$.
  \item Calculer une racine carrée $x_P$ de $x_P^2$ en utilisant le théorème précédent.
  \item Parmi les deux racines carrées $\{x_P, -x_P\}$, choisir celle dont le bit de parité (bit le moins significatif) est égal à $p$.
  \item Retourner le point $P = (x_P, y_P)$.
\end{enumerate}
\end{definition}

\begin{remark}[Implémentation efficace de la racine carrée]
En pratique, on calcule d'abord :
\[
x = a^{(q+3)/8}
\]
puis on vérifie :
\begin{itemize}
\item Si $x^2 = a$, alors $x$ est une racine carrée de $a$.
\item Si $x^2 = -a$, alors $x \cdot 2^{(q-1)/4}$ est une racine carrée de $a$.
\item Sinon, $a$ n'est pas un carré dans $\F_q$.
\end{itemize}
On ajuste ensuite la parité en choisissant entre la racine obtenue et son opposée selon le bit $p$ stocké dans l'encodage.
\end{remark}

\subsection{Clés Ed25519}

\begin{definition}[Clampage Ed25519]
Soit $H_1 \in \bin^{256}$, que l'on interprète comme une suite de 32 octets $(h_0, h_1, \dots, h_{31})$ en little-endian. Le clampage Ed25519 est l'application :
\[
\mathrm{clamp}: \bin^{256} \to \mathbb{Z}_\ell
\]
définie par les opérations suivantes sur les octets :
\begin{align*}
h_0 &\gets h_0 \land \mathtt{0xF8} \quad \text{(bits 0-2 à 0)}, \\
h_{31} &\gets (h_{31} \land \mathtt{0x7F}) \lor \mathtt{0x40} \quad \text{(bit 255 à 0, bit 254 à 1)},
\end{align*}
puis on pose
\[
a = \mathrm{val}_{\mathrm{le}}(h_0, h_1, \dots, h_{31}) \bmod \ell.
\]
\end{definition}

\begin{definition}[Génération de clés Ed25519]
Soit $K_{\mathrm{Ed}} \in \bin^{256}$ (voir \ref{sec:init}). On calcule :
\[
H = \mathrm{SHA\text{-}512}(K_{\mathrm{Ed}}) = H_1 \concat H_2 \quad \text{avec } H_1, H_2 \in \bin^{256}
\]
La clé privée est :
\[
a = \mathrm{clamp}(H_1) \in \mathbb{Z}_\ell
\]
La clé publique est :
\[
A = aB \in E(\F_q)
\]
\end{definition}

\subsection{Algorithme de signature Ed25519}
\label{sec:sig-ed}

\begin{definition}[Signature Ed25519 \cite{rfc8032}]
L'algorithme de signature $\mathrm{Sign}: \mathbb{Z}_\ell \times \bin^* \to \bin^{512}$ est défini comme suit :

Pour $(a, M) \in \mathbb{Z}_\ell \times \bin^*$ :
\begin{enumerate}[leftmargin=2em]
\item Calculer $H = \mathrm{SHA\text{-}512}(K_{\mathrm{Ed}}) = H_1 \concat H_2$
\item Définir $r = \mathrm{val}_{\mathrm{le}}(\mathrm{SHA\text{-}512}(H_2 \concat M)) \bmod \ell$
\item Calculer $R = rB \in E(\F_q)$
\item Calculer $k = \mathrm{val}_{\mathrm{le}}(\mathrm{SHA\text{-}512}(\mathrm{enc}(R) \concat \mathrm{enc}(A) \concat M)) \bmod \ell$
\item Calculer $s = (r + k \cdot a) \bmod \ell$
\item La signature est $\sigma = \mathrm{enc}(R) \concat \mathrm{bytes}_{\mathrm{le}}(s)$
\end{enumerate}
\end{definition}

\subsection{Algorithme de vérification Ed25519}

\begin{definition}[Vérification Ed25519 \cite{rfc8032}]
L'algorithme de vérification $\mathrm{Verify}: E(\F_q) \times \bin^* \times \bin^{512} \to \{\mathrm{OK}, \perp\}$ est défini comme suit :

Pour $(A, M, \sigma) \in E(\F_q) \times \bin^* \times \bin^{512}$ :
\begin{enumerate}[leftmargin=2em]
\item Parser $\sigma = R_{enc} \concat s_{enc}$ avec $R_{enc}, s_{enc} \in \bin^{256}$
\item Décoder $R = \mathrm{dec}(R_{enc}) \in E(\F_q)$
\item Décoder $s = \mathrm{val}_{\mathrm{le}}(s_{enc}) \in \mathbb{Z}_\ell$
\item Vérifier que $A$ et $R$ sont des points valides sur $E(\F_q)$
\item Vérifier que $s \in \{0, \dots, \ell-1\}$
\item Calculer $k = \mathrm{val}_{\mathrm{le}}(\mathrm{SHA\text{-}512}(R_{enc} \concat \mathrm{enc}(A) \concat M)) \bmod \ell$
\item Vérifier l'équation :
\[
sB = R + kA
\]
Si toutes les vérifications réussissent, retourner $\mathrm{OK}$, sinon $\perp$.
\end{enumerate}
\end{definition}

\begin{theorem}[Correction de la vérification Ed25519]
Pour toute paire $(a,A)$ générée valide et tout message $M$,
\[
\mathrm{Verify}(A, M, \mathrm{Sign}(a, M)) = \mathrm{OK}
\]
\end{theorem}

\begin{proof}
Soit $\sigma = (R, s)$ une signature valide. Alors :
\begin{align*}
sB &= (r + k \cdot a)B \\
   &= rB + k \cdot (aB) \\
   &= R + kA
\end{align*}
L'équation de vérification est donc satisfaite.
\end{proof}

\begin{remark}[Signature contextuelle dans le schéma $k$ sur $n$]
Dans notre implémentation, on signe non pas $M$ directement mais le message contextualisé :
\[
M' = \texttt{"kofn-ed25519-v1"} \concat \mathrm{SHA256}(A) \concat M
\]
où $A$ est la clé publique Ed25519. Cela empêche la réutilisation des signatures hors contexte et garantit la liaison avec la clé maîtresse du schéma.
\end{remark}

\begin{remark}[Sécurité des signatures]
La sécurité d'Ed25519 repose sur la difficulté du problème du logarithme discret dans le groupe $\langle B \rangle$ et sur les propriétés de résistance aux collisions de SHA-512. Le clampage empêche les attaques par canaux auxiliaires et garantit que le scalaire est dans le sous-groupe principal.
\end{remark}

%=========================================================
\section{RSA, MGF1 et OAEP}



\subsection{Chiffrement asymétrique RSA}

\begin{definition}[Clés RSA (Rivest--Shamir--Adleman)]
On choisit deux nombres premiers $p,q$ de taille comparable (typiquement $p,q \approx 2^{2048}$ pour un module de 4096 bits) et on pose $n = pq$. 

On calcule $\varphi(n) = (p-1)(q-1)$ (voir Proposition~\ref{prop:phi-pq}).

On choisit un exposant public $e$ tel que $\gcd(e,\varphi(n)) = 1$ (typiquement $e = 65537$). L'exposant privé $d$ est l'inverse de $e$ modulo $\varphi(n)$ :
\[
d \equiv e^{-1} \pmod{\varphi(n)}.
\]
La clé publique est $(n,e)$ et la clé privée est $(n,d)$.
\end{definition}

\begin{remark}[Taille, primalité et génération concrète d'une clé RSA de 4096 bits]
Lorsque l'on parle d'une \og clé RSA de 4096 bits \fg, on fait référence à la taille du module $n = pq$, c'est-à-dire au nombre de bits de son écriture binaire. Par convention, un module RSA de 4096 bits vérifie
\[
2^{4095} \leq n < 2^{4096},
\]
ce qui équivaut à dire que $n$ a exactement $4096$ bits en binaire.

\medskip
\noindent\textbf{Taille exacte du module.}
En pratique, les bibliothèques cryptographiques génèrent deux nombres premiers $p$ et $q$ de 2048 bits (avec le bit de poids fort forcé à $1$ pour garantir la taille), puis calculent $n = pq$. Si l'on modélise $p$ et $q$ comme uniformément répartis parmi les entiers de 2048 bits, on peut écrire
\[
p = 2^{2047} u,\quad q = 2^{2047} v,\quad \text{avec } u,v \in [1,2[.
\]
On obtient alors $n = pq = 2^{4094} uv$. Le module $n$ a 4095 bits si et seulement si $uv < 2$, ce qui conduit à
\[
\mathbb{P}(\text{$n$ a 4095 bits}) = \mathbb{P}(uv < 2)
= \int_{1}^{2} \left(\frac{2}{u} - 1\right)\,du
= 2 \ln 2 - 1 \approx 0{,}386,
\]
et donc
\[
\mathbb{P}(\text{$n$ a 4096 bits}) = 1 - (2 \ln 2 - 1)
= 2 - 2 \ln 2 \approx 0{,}614.
\]
Autrement dit, si l'on se contentait de choisir $p$ et $q$ de 2048 bits puis de prendre $n = pq$, on obtiendrait un module de 4096 bits dans un peu plus de 60\,\% des cas.

Pour garantir que le module a bien 4096 bits, on utilise en pratique l'une des deux stratégies suivantes :
\begin{itemize}
  \item soit on applique un \emph{rejection sampling} : on génère $p$ et $q$ (premiers de 2048 bits), on calcule $n = pq$, puis on rejette les couples pour lesquels $n$ n'a que 4095 bits, jusqu'à obtenir un $n$ vérifiant $\lfloor \log_2 n \rfloor + 1 = 4096$ ;
  \item soit on contraint légèrement la forme de $p$ et de $q$ (en fixant notamment quelques bits de poids fort et la taille minimale) de manière à ce que le produit $pq$ soit, sauf cas exceptionnel, automatiquement dans l'intervalle $[2^{4095},2^{4096})$, tout en rejetant les rares cas restants où la longueur ne serait pas exactement 4096 bits.
\end{itemize}
Dans les deux cas, la taille annoncée de la clé (4096 bits) correspond effectivement à la taille mathématique du module. Dans notre implémentation, qui s'appuie sur la bibliothèque Python \texttt{cryptography} et donc sur OpenSSL, c'est essentiellement la seconde stratégie qui est utilisée : $p$ et $q$ sont générés avec une forme légèrement contrainte, puis la génération est répétée tant que le module $n = pq$ n'a pas exactement 4096 bits.



\medskip
\noindent\textbf{Génération pratique de premiers de 2048 bits.}
En pratique, les bibliothèques cryptographiques génèrent $p$ et $q$ de la manière suivante :
\begin{enumerate}
  \item \emph{Tirage d'un candidat impair de 2048 bits.} On tire aléatoirement un entier $N$ de 2048 bits à l'aide d'un générateur pseudo-aléatoire cryptographiquement sûr, on force le bit de poids fort à $1$ (pour garantir la taille) et le bit de poids faible à $1$ (pour que $N$ soit impair).
  \item \emph{Filtrage par petits premiers.} On élimine rapidement les candidats manifestement composés en testant la divisibilité de $N$ par une liste de petits nombres premiers (par exemple les premiers $\leq 1000$).
  \item \emph{Test de primalité probabiliste (Miller--Rabin voir \ref{sec:annexe-miller-rabin}).} Pour les candidats survivants, on applique plusieurs itérations du test de Miller--Rabin. On écrit $N-1 = 2^s d$ avec $d$ impair, puis, pour chaque base $a$ choisie (aléatoire ou selon une liste standard), on examine la suite
  \[
    a^d,\; a^{2d},\; a^{4d},\; \dots,\; a^{2^{s-1}d} \pmod{N}.
  \]
  Si, pour une base donnée, cette suite ne se comporte pas comme elle le ferait modulo un nombre premier, on peut conclure que $N$ est composé et rejeter ce candidat. Si $N$ passe le test pour toutes les bases choisies, on le déclare \emph{premier probable}.
\end{enumerate}
On montre que, pour un entier impair composé $N$, la proportion de bases $a$ pour lesquelles le test de Miller--Rabin échoue à détecter la composité est au plus $1/4$. Ainsi, si l'on utilise $k$ bases indépendantes, la probabilité qu'un nombre \emph{composé} passe tous les tests est majorée par $(1/4)^k = 2^{-2k}$. Avec un nombre raisonnable de bases (quelques dizaines au plus), la probabilité de déclarer \og premier \fg{} un entier en réalité composé devient négligeable (par exemple $\le 2^{-128}$), ce qui est largement suffisant pour les usages cryptographiques.

\medskip
\noindent\textbf{Ordre de grandeur du nombre de premiers disponibles.}
Le nombre de nombres premiers de 2048 bits est colossal : le théorème des nombres premiers donne l'approximation
\[
\#\{\text{premiers de 2048 bits}\} \approx \frac{2^{2047}}{2048 \ln 2} \approx 10^{613}.
\]
Même en rejetant une fraction non négligeable des couples $(p,q)$ pour des raisons de taille du module ou de tests de primalité, l'espace de recherche reste astronomique, et ces contraintes n'affaiblissent pas la sécurité de RSA.
\end{remark}

\begin{theorem}[Correction du chiffrement RSA]
\label{thm:rsa-correct}
Pour tout message $M \in \{0,\dots,n-1\}$ et toute clé RSA valide $(n,e,d)$, on a :
\[
(M^e)^d \equiv M \pmod{n}.
\]
\end{theorem}

\begin{proof}
Puisque $ed \equiv 1 \pmod{\varphi(n)}$, il existe $k$ tel que $ed = 1 + k(p-1)(q-1)$.

\textbf{Modulo $p$} :
\begin{itemize}
\item Si $p \mid M$ : alors $M \equiv 0 \pmod{p}$, donc $M^{ed} \equiv 0 \equiv M \pmod{p}$.
\item Si $p \nmid M$ : par le petit théorème de Fermat (théorème \ref{thm:fermat}), $M^{p-1} \equiv 1 \pmod{p}$, donc
  \[
  M^{ed} = M^{1 + k(p-1)(q-1)} = M \cdot (M^{p-1})^{k(q-1)} \equiv M \cdot 1^{k(q-1)} = M \pmod{p}.
  \]
\end{itemize}

Ainsi, dans tous les cas, $M^{ed} \equiv M \pmod{p}$, donc $p \mid (M^{ed} - M)$.

\textbf{Modulo $q$} :
\begin{itemize}
\item Si $q \mid M$ : alors $M \equiv 0 \pmod{q}$, donc $M^{ed} \equiv 0 \equiv M \pmod{q}$.
\item Si $q \nmid M$ : par le petit théorème de Fermat (théorème \ref{thm:fermat}), $M^{q-1} \equiv 1 \pmod{q}$, donc
  \[
  M^{ed} = M^{1 + k(p-1)(q-1)} = M \cdot (M^{q-1})^{k(p-1)} \equiv M \cdot 1^{k(p-1)} = M \pmod{q}.
  \]
\end{itemize}

Ainsi, dans tous les cas, $M^{ed} \equiv M \pmod{q}$, donc $q \mid (M^{ed} - M)$.

Soit $N = M^{ed} - M$. Nous avons montré que $p \mid N$ et $q \mid N$. Puisque $p$ et $q$ sont premiers distincts, ils sont premiers entre eux.

Comme $p \mid N$, on peut écrire $N = p \cdot K$ pour un certain entier $K$.
Puisque $q \mid N = p \cdot K$ et que $\gcd(p,q) = 1$, par le théorème de Gauss (théorème \ref{thm:gauss-div}), $q \mid K$.
Donc $K = q \cdot L$ pour un certain entier $L$, et ainsi :
\[
N = p \cdot K = p \cdot q \cdot L = n \cdot L,
\]
ce qui montre que $n \mid N$, c'est-à-dire :
\[
M^{ed} \equiv M \pmod{n}.
\]
\end{proof}

\begin{remark}[Risque lorsque $\gcd(M,n) \neq 1$]
Si $\gcd(M,n) \neq 1$, alors $M$ est divisible par $p$ ou par $q$, ce qui permettrait à un attaquant de factoriser $n$ en calculant $\gcd(M,n)$.

Bien que théoriquement possible, cette attaque est pratiquement irréalisable :

\begin{itemize}
\item Pour un module RSA de 4096 bits, la probabilité qu'un message aléatoire $M$ (de 4096 bits après encodage OAEP) ait un facteur commun avec $n$ est d'environ $2^{-2048}$.
\item Cette probabilité est bien inférieure à l'inverse du nombre estimé de particules dans l'univers observable ($\approx 10^{80} \approx 2^{266}$).
\item Même en chiffrant un milliard de messages par seconde pendant l'âge de l'univers ($\approx 4 \times 10^{17}$ secondes), le nombre total de messages serait d'environ $10^{26} \approx 2^{86}$, et l'espérance du nombre de messages \og vulnérables \fg{} serait de $2^{86} \cdot 2^{-2048} = 2^{-1962}$, ce qui reste bien inférieur à 1.
\item Si un tel événement se produisait par miracle, le chiffrement et le déchiffrement fonctionneraient parfaitement normalement, et personne ne s'en rendrait compte sans calculer explicitement $\gcd(M,n)$.
\end{itemize}

En pratique, cette attaque n'est donc pas une préoccupation réaliste pour la sécurité de RSA avec des paramètres standard.
\end{remark}

\begin{definition}[Paramètres concrets pour le schéma $k$ sur $n$]
Dans notre implémentation :
\begin{itemize}[leftmargin=2em]
  \item Module $n$ : 4096 bits ;
  \item Exposant public $e = 65537$ ;
  \item Exposant privé $d \equiv e^{-1} \pmod{\varphi(n)}$.
\end{itemize}
\end{definition}

\begin{remark}[Sécurité RSA]
La sécurité de RSA repose sur la difficulté de la factorisation du module $n$. Pour un module de 4096 bits, construit comme indiqué ci-dessus, cela offre une sécurité suffisante selon les standards actuels.
\end{remark}







\subsection{MGF1}

\begin{definition}[Fonction de génération de masque MGF1 (Mask Generation Function 1) \cite{rfc8017}]
Soit $h:\bin^*\to\bin^d$ une fonction de hachage. On définit
\[
  \MGF_h : \bin^* \times \N \to \bin^\ell
\]
par :
\[
  \MGF_h(Z,\ell) = T_1 \concat T_2 \concat \dots \concat T_{\lceil \ell/d \rceil} \quad \text{tronqué à $\ell$ bits}
\]
où 
\[
T_i = h(Z \concat \mathrm{INT}_4(i-1)) \quad \text{pour } i = 1, 2, \dots, \lceil \ell/d \rceil
\]
et $\mathrm{INT}_4(j)$ est l'encodage big-endian de $j$ sur 4 octets.
\end{definition}

\begin{propriete}[Propriétés de MGF1]
MGF1 est déterministe et peut générer des masques de longueur arbitraire. Sa sécurité repose sur les propriétés de résistance aux collisions et de préimage de la fonction de hachage sous-jacente $h$.
\end{propriete}

\begin{remark}[Rôle crucial de MGF1 dans OAEP]
MGF1 joue un rôle essentiel dans OAEP en empêchant les attaques par blocs indépendants :

\begin{itemize}
\item \textbf{Transformation de taille} : Passer d'une entrée fixe à une sortie de longueur arbitraire
\item \textbf{Distribution uniforme} : Garantir que le masque n'a pas de motifs détectables  
\item \textbf{Non-corrélation} : Assurer que chaque partie du masque est unique grâce au compteur
\item \textbf{Entrelacement cryptographique} : Créer des dépendances non linéaires entre \texttt{maskedSeed} et \texttt{maskedDB} via la structure :
  \[
  \begin{cases}
  \texttt{maskedDB} = \texttt{DB} \oplus \MGF_h(\texttt{seed}) \\
  \texttt{maskedSeed} = \texttt{seed} \oplus \MGF_h(\texttt{maskedDB})
  \end{cases}
  \]
\item \textbf{Prévention d'attaques par blocs} : Toute modification d'un bit dans une partie affecte de manière imprévisible l'ensemble du message, rendant impossible les attaques ciblées sur des blocs individuels
\item \textbf{Sécurité prouvée} : Permettre les preuves formelles de sécurité d'OAEP contre les attaques adaptatives (IND-CCA2)
\end{itemize}

Sans MGF1, un attaquant pourrait manipuler séparément les différentes parties du message encodé, réduisant la sécurité à celle de schémas de padding vulnérables comme PKCS\#1 v1.5. MGF1 est donc la \og colle cryptographique \fg{} qui assure l'indissociabilité des composants d'OAEP.
\end{remark}

\subsection{RSA-OAEP}
\label{sec:rsa-oaep}

\begin{definition}[Paramètres RSA-OAEP (Optimal Asymmetric Encryption Padding) \cite{rfc8017}]
Soient $k$ la taille en octets du module $n$ (pour $n$ de 4096 bits, $k = 512$), et $hLen$ la taille de sortie de la fonction de hachage en octets (pour SHA-256, $hLen = 32$). On fixe :
\[
k_0 = k - 2hLen - 2,\quad k_1 = hLen
\]
où $k_0$ est la longueur maximale du message en octets et $k_1$ la longueur de l'aléa $r$.
\end{definition}

\begin{definition}[Encodage OAEP]
L'encodage OAEP pour un message $M\in\bin^{8k_0}$, un label $L\in\bin^*$ et un aléa $r\in\bin^{8k_1}$ est défini comme suit :
\begin{enumerate}[leftmargin=2em]
  \item Calculer $lHash = h(L)$
  \item Former la chaîne $PS = 0^{8(k - k_0 - 2hLen - 2)}$ (padding de zéros)
  \item Construire le bloc $DB = lHash \concat PS \concat 0x01 \concat M$
  \item Calculer $maskedDB = DB \xor \MGF_h(r, 8(k - hLen - 1))$
  \item Calculer $maskedSeed = r \xor \MGF_h(maskedDB, 8hLen)$
  \item Le message encodé est $EM = maskedSeed \concat maskedDB \in \bin^{8k}$
\end{enumerate}
\end{definition}

\begin{definition}[Chiffrement RSA-OAEP]
Soient $(n,e)$ une clé publique RSA, $k_0,k_1$ les paramètres de taille définis ci-dessus. On définit :
\begin{align*}
  \RSAOAEP_{(n,e)} &: \bin^{8k_0} \times \bin^{8k_1} \to \{0,\dots,n-1\} \\
  \RSAOAEP_{(n,e)}(M;r) &= \mathrm{val}_{\mathrm{be}}(EM)^e \bmod n
\end{align*}
où $EM$ est le résultat de l'encodage OAEP de $M$ avec l'aléa $r$.
\end{definition}

\begin{definition}[Déchiffrement RSA-OAEP]
Soient $(n,d)$ une clé privée RSA. On définit :
\begin{align*}
  \RSAOAEP^{-1}_{(n,d)} &: \{0,\dots,n-1\} \to \bin^{8k_0} \cup \{\perp\} \\
  \RSAOAEP^{-1}_{(n,d)}(C) &= 
  \begin{cases}
    M & \text{si le décodage réussit} \\
    \perp & \text{sinon}
  \end{cases}
\end{align*}
où $C \in \{0,\dots,n-1\}$ est le \textbf{texte chiffré} (ciphertext) obtenu par $\RSAOAEP_{(n,e)}(M;r)$.

Le déchiffrement procède comme suit :
\begin{enumerate}[leftmargin=2em]
  \item Calculer $EM = C^d \bmod n$ et convertir en binary sur $8k$ bits
  \item Parser $EM = maskedSeed \concat maskedDB$ avec $maskedSeed \in \bin^{8hLen}$
  \item Calculer $seed = maskedSeed \xor \MGF_h(maskedDB, 8hLen)$
  \item Calculer $DB = maskedDB \xor \MGF_h(seed, 8(k - hLen - 1))$
  \item Parser $DB = lHash' \concat PS \concat 0x01 \concat M$ où $PS$ est une suite de zéros
  \item Vérifier que $lHash' = h(L)$ et que $PS$ contient bien que des zéros
  \item Si toutes les vérifications passent, retourner $M$, sinon $\perp$
\end{enumerate}
\end{definition}

\begin{remark}[Statut de l'aléa $r$ dans OAEP]
Contrairement aux sels publics utilisés dans HKDF ou PBKDF2, l'aléa $r$ dans OAEP est \og cryptographiquement protégé \fg{} :
\begin{itemize}
\item \textbf{Non public} : $r$ n'est pas stocké en clair ni transmis publiquement
\item \textbf{Masqué cryptographiquement} : Il est caché dans le chiffré via $\texttt{maskedSeed} = r \oplus \MGF_h(\texttt{maskedDB})$
\item \textbf{Récupération au déchiffrement} : Seul le possesseur de la clé privée peut retrouver $r$ 
\item \textbf{Rôle éphémère} : $r$ est utilisé une seule fois puis \og jeté \fg{}
\end{itemize}
La sécurité d'OAEP repose sur le fait que $r$ reste \og imprévisible \fg{} pour un attaquant au moment du chiffrement.
\end{remark}

\begin{remark}[Paramètres numériques pour RSA-4096 et SHA-256]
Pour un module RSA de 4096 bits ($k = 512$ octets) avec SHA-256 ($hLen = 32$ octets), on a :
\[
k_0 = 512 - 2\times 32 - 2 = 446 \text{ octets}
\]
Cette capacité de 446 octets est amplement suffisante pour une clé AES-256 de 32 octets, avec une marge importante pour les données de padding.
\end{remark}

\begin{theorem}[Correction de RSA-OAEP]
Pour toute clé $(n,e,d)$ valide, pour tout message $M$ de longueur $8k_0$ bits et pour tout aléa $r\in\bin^{8k_1}$,
\[
  \RSAOAEP^{-1}_{(n,d)}\bigl(\RSAOAEP_{(n,e)}(M;r)\bigr) = M.
\]
\end{theorem}

\begin{proof}
La correction découle de la structure réversible de l'encodage OAEP. Les opérations de masquage utilisant MGF sont réversibles car déterministe, et les vérifications assurent l'intégrité du message.
\end{proof}

\begin{remark}[Propriétés de sécurité]
RSA-OAEP offre une sécurité prouvée dans le modèle de l'oracle aléatoire contre les attaques adaptatives à chiffrés choisis (IND-CCA2). Le padding OAEP prévient les attaques par canal auxiliaire et garantit l'intégrité du message.
\end{remark}

\begin{definition}[Utilisation dans le schéma $k$ sur $n$]
Dans notre contexte, RSA-OAEP est utilisé pour chiffrer des clés AES-256 de 32 octets. Pour un module RSA de 4096 bits ($k=512$) avec SHA-256 ($hLen=32$), on a :
\[
k_0 = 512 - 2\times 32 - 2 = 446 \text{ octets}
\]
Ce qui est amplement suffisant pour une clé AES-256 de 32 octets, avec une marge importante de 414 octets pour le padding OAEP.
\end{definition}

\addtocontents{toc}{\protect\newpage}

%=========================================================
\section{AES-GCM}

\subsection{AES comme permutation de bloc}

\begin{definition}[AES-256 (Advanced Encryption Standard) selon FIPS 197 \cite{fips197}]
On fixe une taille de bloc de $128$ bits et une taille de clé de $256$ bits.
Pour chaque clé $K \in \bin^{256}$, on dispose d'une permutation de blocs
\[
  E_K : \bin^{128} \to \bin^{128},
\]
bijective, avec réciproque notée $D_K = E_K^{-1}$.

L'algorithme AES-256 opère sur un \emph{état} (state) représenté comme une matrice $4 \times 4$ d'octets, notée:
\[
\text{state} = 
\begin{bmatrix}
s_{0,0} & s_{0,1} & s_{0,2} & s_{0,3} \\
s_{1,0} & s_{1,1} & s_{1,2} & s_{1,3} \\
s_{2,0} & s_{2,1} & s_{2,2} & s_{2,3} \\
s_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}
\end{bmatrix}
\]
où chaque $s_{r,c}$ est un octet ($0 \leq r < 4$, $0 \leq c < 4$).

\textbf{Note :} L'algorithme complet de chiffrement (fonction CIPHER) sera détaillé à la section~\ref{sec:aes-cipher}.
\end{definition}

\begin{definition}[Mapping entrée-état selon FIPS 197]
Le mapping entre le bloc d'entrée $in \in \bin^{128}$ et l'état suit l'ordre \emph{colonne-major} :
\[
s[r,c] = in[8 \cdot (4c + r) \ldots 8 \cdot (4c + r) + 7] \quad \text{pour } 0 \leq r < 4, 0 \leq c < 4
\]
En représentation octet, cela équivaut à :
\[
s[r,c] = in[4c + r] \quad \text{pour } 0 \leq r < 4, 0 \leq c < 4
\]
où $in$ est vu comme un tableau de 16 octets $in[0] \ldots in[15]$.
\end{definition}

\begin{definition}[Paramètres AES-256]
Pour AES-256, on a les paramètres fixes suivants:
\begin{itemize}
\item $Nk = 8$ (nombre de mots de 32 bits dans la clé)
\item $Nb = 4$ (nombre de mots de 32 bits dans le bloc/état)  
\item $Nr = 14$ (nombre de tours)
\end{itemize}
\end{definition}

\subsection{Correspondance des corps finis}

\begin{remark}[Corps GF($2^8$) d'AES]
Le corps GF($2^8$) utilisé dans AES correspond à la construction suivante dans notre formalisme :
\[
\F_{2^8} = \F_2[X]/(X^8 + X^4 + X^3 + X + 1)
\]
où :
\begin{itemize}
\item $\F_2$ est le corps à 2 éléments (corps premier)
\item Le polynôme $m(X) = X^8 + X^4 + X^3 + X + 1$ est irréductible sur $\F_2$
\item Chaque élément de $\F_{2^8}$ est un polynôme de degré $\leq 7$ à coefficients dans $\F_2$
\item Un octet $\{b_7b_6b_5b_4b_3b_2b_1b_0\}$ représente le polynôme $b_7X^7 + b_6X^6 + \cdots + b_1X + b_0$
\end{itemize}
\end{remark}

\begin{remark}[Différence avec le corps de Shamir]
Le corps $\F_P$ utilisé pour le partage de Shamir (avec $P = 2^{521}-1$) est de caractéristique différente :
\begin{itemize}
\item $\F_P$ : corps premier de caractéristique $P$ (premier)
\item $\F_{2^8}$ : corps de caractéristique 2
\end{itemize}
Cette différence est fondamentale et explique pourquoi les opérations arithmétiques (addition, multiplication) diffèrent radicalement entre Shamir et AES.
\end{remark}

\begin{proposition}[Opérations dans les corps de caractéristique 2]
Dans $\F_{2^8}$ :
\begin{itemize}
\item \textbf{Addition} : équivaut au XOR bit-à-bit
\item \textbf{Soustraction} : identique à l'addition ($a - b = a + b$)
\item \textbf{Multiplication} : multiplication polynomiale suivie de réduction modulo le polynôme irréductible
\end{itemize}
\end{proposition}

\subsection{Transformations de base}

\begin{definition}[S-box AES]
La S-box (table de substitution) AES est une table fixe de 256 octets définie dans le standard FIPS 197. Pour un octet d'entrée $xy$ en hexadécimal (où $x$ est le nibble de poids fort et $y$ le nibble de poids faible), la valeur de substitution est donnée par la table suivante:

\[
\renewcommand{\arraystretch}{1.2}
\begin{array}{c|cccccccccccccccc}
 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & a & b & c & d & e & f \\
\hline
0 & 63 & 7c & 77 & 7b & f2 & 6b & 6f & c5 & 30 & 01 & 67 & 2b & fe & d7 & ab & 76 \\
1 & ca & 82 & c9 & 7d & fa & 59 & 47 & f0 & ad & d4 & a2 & af & 9c & a4 & 72 & c0 \\
2 & b7 & fd & 93 & 26 & 36 & 3f & f7 & cc & 34 & a5 & e5 & f1 & 71 & d8 & 31 & 15 \\
3 & 04 & c7 & 23 & c3 & 18 & 96 & 05 & 9a & 07 & 12 & 80 & e2 & eb & 27 & b2 & 75 \\
4 & 09 & 83 & 2c & 1a & 1b & 6e & 5a & a0 & 52 & 3b & d6 & b3 & 29 & e3 & 2f & 84 \\
5 & 53 & d1 & 00 & ed & 20 & fc & b1 & 5b & 6a & cb & be & 39 & 4a & 4c & 58 & cf \\
6 & d0 & ef & aa & fb & 43 & 4d & 33 & 85 & 45 & f9 & 02 & 7f & 50 & 3c & 9f & a8 \\
7 & 51 & a3 & 40 & 8f & 92 & 9d & 38 & f5 & bc & b6 & da & 21 & 10 & ff & f3 & d2 \\
8 & cd & 0c & 13 & ec & 5f & 97 & 44 & 17 & c4 & a7 & 7e & 3d & 64 & 5d & 19 & 73 \\
9 & 60 & 81 & 4f & dc & 22 & 2a & 90 & 88 & 46 & ee & b8 & 14 & de & 5e & 0b & db \\
a & e0 & 32 & 3a & 0a & 49 & 06 & 24 & 5c & c2 & d3 & ac & 62 & 91 & 95 & e4 & 79 \\
b & e7 & c8 & 37 & 6d & 8d & d5 & 4e & a9 & 6c & 56 & f4 & ea & 65 & 7a & ae & 08 \\
c & ba & 78 & 25 & 2e & 1c & a6 & b4 & c6 & e8 & dd & 74 & 1f & 4b & bd & 8b & 8a \\
d & 70 & 3e & b5 & 66 & 48 & 03 & f6 & 0e & 61 & 35 & 57 & b9 & 86 & c1 & 1d & 9e \\
e & e1 & f8 & 98 & 11 & 69 & d9 & 8e & 94 & 9b & 1e & 87 & e9 & ce & 55 & 28 & df \\
f & 8c & a1 & 89 & 0d & bf & e6 & 42 & 68 & 41 & 99 & 2d & 0f & b0 & 54 & bb & 16 \\
\end{array}
\]

Cette table est notée $\mathrm{SBox} : \bin^8 \to \bin^8$.
\end{definition}

\begin{definition}[SUBBYTES()]
La transformation SUBBYTES() applique la S-box à chaque octet de l'état:
\[
s'_{r,c} = \mathrm{SBox}(s_{r,c}) \quad \text{pour } 0 \leq r < 4, 0 \leq c < 4
\]

Bien que la S-box soit définie par un algorithme (inversion dans GF($2^8$) suivie d'une transformation affine), dans la pratique elle est implémentée comme une table de consultation fixe pour des raisons de performance.
\end{definition}

\begin{remark}[Construction algorithmique de la S-box]
La S-box peut être générée algorithmiquement pour tout octet $b \neq 0$ par:
\begin{enumerate}
\item Calculer l'inverse multiplicatif $b^{-1}$ dans GF($2^8$) modulo $m(x) = x^8 + x^4 + x^3 + x + 1$
\item Appliquer la transformation affine:
\[
b_i' = b_i \oplus b_{(i+4)\mod 8} \oplus b_{(i+5)\mod 8} \oplus b_{(i+6)\mod 8} \oplus b_{(i+7)\mod 8} \oplus c_i
\]
où $c = \mathtt{0x63} = \{01100011\}$.
\end{enumerate}
Pour $b = 0$, on utilise $0^{-1} = 0$ par convention.
\end{remark}

\begin{definition}[SHIFTROWS()]
La transformation SHIFTROWS() décale cycliquement les lignes de l'état:
\begin{itemize}
\item Ligne 0: pas de décalage
\item Ligne 1: décalage de 1 position vers la gauche  
\item Ligne 2: décalage de 2 positions vers la gauche
\item Ligne 3: décalage de 3 positions vers la gauche
\end{itemize}
Formellement: $s'_{r,c} = s_{r,(c+r)\mod 4}$ pour $0 \leq r < 4$, $0 \leq c < 4$.
\end{definition}

\begin{definition}[MIXCOLUMNS()]
La transformation MIXCOLUMNS() traite chaque colonne de l'état comme un polynôme sur GF($2^8$) et le multiplie modulo $x^4 + 1$ par le polynôme fixe:
\[
a(x) = \{03\}x^3 + \{01\}x^2 + \{01\}x + \{02\}
\]
Ceci équivaut à la multiplication matricielle:
\[
\begin{bmatrix}
s'_{0,c} \\
s'_{1,c} \\
s'_{2,c} \\
s'_{3,c}
\end{bmatrix}
=
\begin{bmatrix}
02 & 03 & 01 & 01 \\
01 & 02 & 03 & 01 \\
01 & 01 & 02 & 03 \\
03 & 01 & 01 & 02
\end{bmatrix}
\begin{bmatrix}
s_{0,c} \\
s_{1,c} \\
s_{2,c} \\
s_{3,c}
\end{bmatrix}
\quad\text{pour } 0 \leq c < 4
\]
\end{definition}

\subsection{Expansion de clé AES-256}

\begin{definition}[Structure des mots de clé]
Un mot $w[i]$ est une séquence de 32 bits interprétée comme 4 octets:
\[
w[i] = (w[i]_0, w[i]_1, w[i]_2, w[i]_3)
\]
où $w[i]_0$ est l'octet de poids fort et $w[i]_3$ l'octet de poids faible.
\end{definition}

\begin{definition}[KEYEXPANSION() pour AES-256]
L'expansion de clé génère $4 \times (Nr + 1) = 60$ mots de 32 bits à partir de la clé initiale.

Soit $key[0..7]$ les 8 mots initiaux de la clé. Pour $i = 0$ à $59$:
\begin{itemize}
\item Si $i < 8$: $w[i] = key[i]$
\item Si $i \geq 8$ et $i \mod 8 = 0$: 
  \[
  w[i] = w[i-8] \oplus \text{SubWord}(\text{RotWord}(w[i-1])) \oplus \text{Rcon}[i/8]
  \]
\item Si $i \geq 8$ et $i \mod 8 = 4$:
  \[
  w[i] = w[i-8] \oplus \text{SubWord}(w[i-1])
  \]
\item Sinon:
  \[
  w[i] = w[i-8] \oplus w[i-1]
  \]
\end{itemize}
où:
\begin{itemize}
\item $\text{RotWord}([a,b,c,d]) = [b,c,d,a]$
\item $\text{SubWord}([a,b,c,d]) = [\text{SBox}(a), \text{SBox}(b), \text{SBox}(c), \text{SBox}(d)]$
\item $\text{Rcon}[j] = [x^{j-1}, \{00\}, \{00\}, \{00\}]$ avec $x = \{02\}$
\end{itemize}
\end{definition}

\begin{definition}[ADDROUNDKEY()]
La transformation ADDROUNDKEY() combine l'état avec la clé de tour par XOR. Pour chaque colonne $c$ ($0 \leq c < 4$), on a:
\[
[s'_{0,c}, s'_{1,c}, s'_{2,c}, s'_{3,c}] = [s_{0,c}, s_{1,c}, s_{2,c}, s_{3,c}] \oplus w[4 \times round + c]
\]
où $w[i]$ est le $i$-ème mot du schedule de clés et $round$ est le numéro du tour.
\end{definition}

\subsection{Algorithme de chiffrement complet}
\label{sec:aes-cipher}

\begin{definition}[CIPHER() pour AES-256]
L'algorithme de chiffrement complet est:
\begin{enumerate}
\item $\text{state} \leftarrow \text{in}$ (copie de l'entrée dans l'état selon le mapping colonne-major)
\item $\text{state} \leftarrow \text{ADDROUNDKEY}(\text{state}, w[0..3])$
\item Pour $round = 1$ à $Nr-1$:
  \begin{enumerate}
  \item $\text{state} \leftarrow \text{SUBBYTES}(\text{state})$
  \item $\text{state} \leftarrow \text{SHIFTROWS}(\text{state})$
  \item $\text{state} \leftarrow \text{MIXCOLUMNS}(\text{state})$
  \item $\text{state} \leftarrow \text{ADDROUNDKEY}(\text{state}, w[4 \times round..4 \times round + 3])$
  \end{enumerate}
\item $\text{state} \leftarrow \text{SUBBYTES}(\text{state})$
\item $\text{state} \leftarrow \text{SHIFTROWS}(\text{state})$
\item $\text{state} \leftarrow \text{ADDROUNDKEY}(\text{state}, w[4 \times Nr..4 \times Nr + 3])$
\item $\text{out} \leftarrow \text{state}$ (conversion selon le mapping colonne-major inverse)
\end{enumerate}
\end{definition}

\begin{definition}[Arithmétique dans GF($2^8$)]
Le corps fini GF($2^8$) est défini par le polynôme irréductible:
\[
m(x) = x^8 + x^4 + x^3 + x + 1
\]
Chaque octet $\{b_7b_6b_5b_4b_3b_2b_1b_0\}$ représente le polynôme:
\[
b(x) = b_7x^7 + b_6x^6 + b_5x^5 + b_4x^4 + b_3x^3 + b_2x^2 + b_1x + b_0
\]
L'addition est le XOR bit-à-bit. La multiplication est la multiplication polynomiale modulo $m(x)$.
\end{definition}

\begin{remark}[Implémentation efficace]
La multiplication par $\{02\}$ (notée $\text{XTIMES}()$) peut être implémentée efficacement:
\[
\text{XTIMES}(b) = 
\begin{cases}
(b \ll 1) & \text{si } b_7 = 0 \\
(b \ll 1) \oplus \{1b\} & \text{si } b_7 = 1
\end{cases}
\]
Cette opération est utilisée dans MIXCOLUMNS() et KEYEXPANSION().
\end{remark}

\subsection{Corps $\F_{2^{128}}$ et GHASH}

\begin{definition}[Corps $\F_{2^{128}}$]
On fixe un polynôme irréductible $P(X)\in\F_2[X]$ de degré $128$ (par
exemple $X^{128}+X^7+X^2+X+1$) et on définit
\[
  \F_{2^{128}} = \F_2[X]/(P(X)).
\]
On fixe une bijection entre $\bin^{128}$ et $\F_{2^{128}}$ en identifiant le bloc $(b_{127},\dots,b_0)$ au polynôme $\sum_{i=0}^{127} b_iX^i \bmod P(X)$.
\end{definition}

\begin{definition}[Sous-clé de hachage $H$]
Pour une clé AES $K$, on définit
\[
  H = E_K(0^{128}) \in \bin^{128},
\]
que l'on identifie à un élément de $\F_{2^{128}}$.
\end{definition}

\begin{definition}[GHASH (Galois Hash) selon SP 800-38D \cite{nist-sp800-38d}]
Soit $H\in\F_{2^{128}}$. Pour une séquence de blocs $X_1, \dots, X_m \in \bin^{128}$, la fonction GHASH est définie récursivement par:
\[
Y_0 = 0^{128}, \quad Y_i = (Y_{i-1} \oplus X_i) \cdot H \quad \text{pour } i = 1, \dots, m
\]
Le résultat est $Y_m$. Cette définition est équivalente à:
\[
\mathrm{GHASH}_H(X_1, \dots, X_m) = \sum_{j=1}^m X_j \cdot H^{m-j+1}
\]
\end{definition}


\subsection{Mode AES-GCM}

\begin{definition}[AES-GCM (Galois/Counter Mode) selon SP 800-38D \cite{nist-sp800-38d}]
Pour une clé $K\in\bin^{256}$, on modélise AES-GCM comme un couple
d'applications
\begin{align*}
  \AESGCM_K &: \bin^{96} \times \bin^* \times \bin^* \to \bin^* \times \bin^{128} \\
  \AESGCM_K^{-1} &: \bin^{96} \times \bin^* \times \bin^* \times \bin^{128} \to \bin^* \cup\{\perp\}
\end{align*}
où:
\begin{itemize}
\item Le premier argument est un nonce $N\in\bin^{96}$
\item Le deuxième argument est les données authentifiées associées (AAD) $A\in\bin^*$
\item Le troisième argument est le message $M\in\bin^*$
\item La sortie est un couple $(C,T)$ avec $C$ le texte chiffré et $T$ le tag (128 bits)
\end{itemize}
\end{definition}

\begin{remark}[Rôle d'AES dans AES-GCM]
Le chiffrement AES est utilisé à deux endroits essentiels dans GCM :
\begin{enumerate}
\item \textbf{Dans GCTR} : Pour générer la séquence de masquage en chiffrant les compteurs $J_i$ :
\[
E_K(J_i) \quad \text{servant de masque pour } M_i \xor E_K(J_i)
\]

\item \textbf{Pour calculer $H$} : La sous-clé de hachage est obtenue par :
\[
H = E_K(0^{128})
\]
qui est utilisée dans toutes les multiplications GHASH.
\end{enumerate}
Ainsi, AES fournit à la fois la confidentialité (via GCTR) et la base de l'authentification (via $H$).
\end{remark}

\begin{definition}[Structure mathématique de GCM]
Le mode GCM combine :
\begin{itemize}
\item Le chiffrement en mode compteur (GCTR) utilisant $E_K$ pour la confidentialité
\item La fonction d'authentification GHASH dans $\F_{2^{128}}$ utilisant $H = E_K(0^{128})$ pour l'intégrité
\end{itemize}
Soit le polynôme irréductible :
\[
P(X) = X^{128} + X^7 + X^2 + X + 1 \in \F_2[X]
\]
qui définit le corps $\F_{2^{128}} = \F_2[X]/(P(X))$.
\end{definition}

\begin{definition}[Sous-clé de hachage $H$]
Pour une clé AES $K$, on définit la sous-clé de hachage :
\[
H = E_K(0^{128}) \in \bin^{128}
\]
Cette valeur est identifiée à un élément de $\F_{2^{128}}$ et utilisée dans toutes les multiplications GHASH.
\end{definition}

\begin{definition}[Fonction d'incrémentation GCM]
Soit $\mathrm{incr}_s : \bin^{128} \to \bin^{128}$ qui incrémente les $s$ bits de droite comme un entier big-endian.
Pour GCM, $s = 32$ :
\[
\mathrm{incr}_{32}(X) = \mathrm{MSB}_{96}(X) \concat \mathrm{INT}_4^{-1}((\mathrm{val}_{\mathrm{be}}(\mathrm{LSB}_{32}(X)) + 1) \bmod 2^{32})
\]
\end{definition}

\begin{definition}[Génération des compteurs]
À partir du nonce $N\in\bin^{96}$, on définit :
\[
J_0 = 
\begin{cases}
N \concat 0^{31}1 & \text{si } \lVert N\rVert = 96 \\
\mathrm{GHASH}_H(\varepsilon, N) & \text{sinon}
\end{cases}
\]
Les compteurs successifs sont :
\[
J_i = \mathrm{incr}_{32}(J_{i-1}) \quad \text{pour } i = 1, 2, \dots
\]
\end{definition}

\begin{definition}[Fonction GCTR utilisant AES]
Pour une clé $K$, un compteur initial $ICB\in\bin^{128}$, et une entrée $X\in\bin^*$ :
\begin{align*}
\text{GCTR}_K(ICB, X) = & \\
\text{Si } X = \varepsilon &: \varepsilon \\
\text{Sinon } &: \text{Soit } m = \lceil \lVert X\rVert/128 \rceil \\
& \text{Pour } i = 1 \text{ à } m-1: \\
& \quad CB_i = \mathrm{incr}_{32}(CB_{i-1}) \text{ avec } CB_0 = ICB \\
& \quad Y_i = X_i \xor \mathbf{E_K(CB_i)} \quad \text{\textbf{AES utilisé ici}} \\
& CB_m = \mathrm{incr}_{32}(CB_{m-1}) \\
& Y_m = X_m \xor \mathrm{MSB}_{\lVert X_m\rVert}(\mathbf{E_K(CB_m)}) \quad \text{\textbf{AES utilisé ici}} \\
& \text{Résultat } Y_1 \concat \dots \concat Y_m
\end{align*}
\end{definition}

\begin{definition}[Fonction GHASH utilisant $H = E_K(0^{128})$]
Soit $H = \mathbf{E_K(0^{128})} \in \F_{2^{128}}$. Pour des données $X\in\bin^*$ :
\begin{align*}
\text{GHASH}_H(X) = & \\
\text{Soit } & X_1, \dots, X_m \leftarrow \text{Partition}_{128}(X) \\
& Y_0 = 0^{128} \\
& \text{Pour } i = 1 \text{ à } m: \\
& \quad Y_i = (Y_{i-1} \xor X_i) \cdot H \quad \text{dans } \F_{2^{128}} \\
& \text{Résultat } Y_m
\end{align*}
Équivalent polynomial :
\[
\text{GHASH}_H(X_1, \dots, X_m) = X_1 \cdot H^m \xor X_2 \cdot H^{m-1} \xor \dots \xor X_m \cdot H
\]
\end{definition}

\begin{definition}[Algorithme de chiffrement GCM]
Pour $K, N, A, M$ :
\begin{enumerate}[leftmargin=2em]
  \item $H = \mathbf{E_K(0^{128})}$ \quad \textbf{AES utilisé ici}
  \item $J_0 = \begin{cases} 
        N \concat 0^{31}1 & \text{si } \lVert N\rVert = 96 \\
        \mathrm{GHASH}_H(\varepsilon, N) & \text{sinon}
        \end{cases}$
  \item $C = \mathrm{GCTR}_K(\mathrm{incr}_{32}(J_0), M)$ \quad \textbf{AES utilisé dans GCTR}
  \item $u = 128 \cdot \lceil \lVert C\rVert/128 \rceil - \lVert C\rVert$
  \item $v = 128 \cdot \lceil \lVert A\rVert/128 \rceil - \lVert A\rVert$
  \item $S = \mathrm{GHASH}_H(A \concat 0^v \concat C \concat 0^u \concat \mathrm{len}_{64}(A) \concat \mathrm{len}_{64}(C))$
  \item $T = \mathrm{MSB}_t(\mathrm{GCTR}_K(J_0, S))$ \quad \textbf{AES utilisé dans GCTR}
  \item Retourner $(C, T)$
\end{enumerate}
où $\mathrm{len}_{64}(X)$ représente la longueur de $X$ en bits sur 64 bits.
\end{definition}

\begin{definition}[Algorithme de déchiffrement GCM]
Pour $K, N, A, C, T$ :
\begin{enumerate}[leftmargin=2em]
  \item $H = \mathbf{E_K(0^{128})}$ \quad \textbf{AES utilisé ici}
  \item $J_0 = \begin{cases} 
        N \concat 0^{31}1 & \text{si } \lVert N\rVert = 96 \\
        \mathrm{GHASH}_H(\varepsilon, N) & \text{sinon}
        \end{cases}$
  \item $P = \mathrm{GCTR}_K(\mathrm{incr}_{32}(J_0), C)$ \quad \textbf{AES utilisé dans GCTR}
  \item $u = 128 \cdot \lceil \lVert C\rVert/128 \rceil - \lVert C\rVert$
  \item $v = 128 \cdot \lceil \lVert A\rVert/128 \rceil - \lVert A\rVert$
  \item $S = \mathrm{GHASH}_H(A \concat 0^v \concat C \concat 0^u \concat \mathrm{len}_{64}(A) \concat \mathrm{len}_{64}(C))$
  \item $T' = \mathrm{MSB}_t(\mathrm{GCTR}_K(J_0, S))$ \quad \textbf{AES utilisé dans GCTR}
  \item Si $T' = T$ retourner $P$, sinon $\perp$
\end{enumerate}
\end{definition}

\begin{remark}[Données associées dans AES-GCM]
Dans la notation $\AESGCM_K(N, A, M)$, $A$ désigne les \emph{données associées}
(\emph{Additional Authenticated Data}, AAD) dont l'intégrité est authentifiée
par le tag GCM mais qui ne sont pas chiffrées.

Dans la procédure Tails étudiée ici, nous prenons systématiquement
\[
  A = \varepsilon
\]
(le mot vide) pour le chiffrement des parts, pour le chiffrement de la clé RSA
privée, et pour les autres usages d'AES-GCM. Cette simplification n'affecte pas
la sécurité du schéma : toute l'authentification repose alors sur le couple
$(N,C)$ chiffré et sur le tag GCM.
\end{remark}

\begin{theorem}[Correction d'AES-GCM]
Pour toute clé $K$, tout nonce $N$, toutes données $A$, et tout message $M$ :
\[
\AESGCM_K^{-1}(N, A, \AESGCM_K(N, A, M)) = M
\]
\end{theorem}

\begin{proof}[Esquisse]
La correction découle de :
\begin{itemize}
\item La réversibilité de GCTR qui utilise $E_K$ de façon déterministe
\item La linéarité de GHASH dans $\F_{2^{128}}$ utilisant $H = E_K(0^{128})$
\item L'utilisation cohérente des mêmes compteurs $J_i$ et de la même clé $K$
\end{itemize}
\end{proof}

\begin{remark}[Double usage d'AES dans GCM]
AES est utilisé de deux manières différentes :
\begin{enumerate}
\item \textbf{Confidentialité} : Dans GCTR, $E_K(J_i)$ génère une séquence de masquage pour chiffrer le message
\item \textbf{Authentification} : $E_K(0^{128})$ produit $H$, la base de toutes les opérations GHASH
\end{enumerate}
Cette dualité fait de GCM un mode authentifié efficace utilisant une seule primitive cryptographique.
\end{remark}

\begin{remark}[Sécurité GCM]
La sécurité d'AES-GCM repose sur :
\begin{itemize}
\item L'indistinguabilité de $E_K$ comme permutation pseudo-aléatoire (PRP)
\item L'unicité des nonces (pour éviter la réutilisation des compteurs)
\item La résistance aux collisions de GHASH dans $\F_{2^{128}}$
\end{itemize}
\end{remark}

\begin{remark}[Utilisation dans le schéma $k$ sur $n$]
Dans notre contexte :
\begin{itemize}
\item AES-256 est utilisé avec des clés de 256 bits
\item Nonces de 96 bits garantissant $J_0 = N \concat 0^{31}1$
\item Données authentifiées associées généralement vides : $A = \varepsilon$
\item Tags de 128 bits ($t = 128$)
\end{itemize}
\end{remark}


\subsection{Dénombrement des permutations vs. clés}

\begin{remark}[Injectivité pratique de l'application clé$\to$permutation]
L'espace des blocs possibles est $\bin^{128}$, qui contient
\[
  N = 2^{128}
\]
éléments. L'ensemble de toutes les permutations de $\bin^{128}$ est donc
le groupe symétrique
\[
  \mathrm{Sym}(\bin^{128}) \simeq \mathfrak{S}_{2^{128}},
\]
qui contient
\[
  \bigl|\mathrm{Sym}(\bin^{128})\bigr| = (2^{128})!
\]
permutations possibles.

L'espace des clés AES-256 contient $ |\mathcal{K}| = 2^{256}$ clés possibles. L'application
\[
  \Phi : \mathcal{K} \to \mathrm{Sym}(\bin^{128}), \qquad K \mapsto E_K
\]
ne peut donc, au plus, réaliser que $2^{256}$ permutations parmi les $(2^{128})!$
permutations théoriquement possibles sur $\bin^{128}$.

En utilisant l'approximation de Stirling $\log_2(n!) \approx n(\log_2 n - \log_2 e)$,
\[
  \log_2\bigl((2^{128})!\bigr)
  \approx 2^{128} (\log_2(2^{128}) - \log_2 e)
  = 2^{128}(128 - \log_2 e)
  \approx 2^{128} \cdot 126{,}56,
\]
alors que
\[
  \log_2 |\mathcal{K}| = \log_2(2^{256}) = 256.
\]
On a donc
\[
  \log_2 \bigl|\mathrm{Sym}(\bin^{128})\bigr| \;\approx\; 126{,}56 \cdot 2^{128}
  \;\gg\; 256 = \log_2 |\mathcal{K}|,
\]
ce qui signifie que le nombre de permutations de blocs possibles est
astronomiquement plus grand que le nombre de clés AES-256 possibles.

Si l'on modélise AES-256 comme une \emph{permutation pseudo-aléatoire} (PRP),
la probabilité de collision (existence de $K \neq K'$ tels que $E_K = E_{K'}$)
est majorée par une quantité de l'ordre de
\[
  2^{-2^{128}},
\]
ce qui est totalement négligeable à toute échelle pratique.
\end{remark}

%=========================================================
\section{Construction globale du schéma $k$ sur $n$}

\subsection{Paramètres et constantes}

\begin{definition}[Paramètres globaux]
On fixe :
\begin{itemize}[leftmargin=2em]
  \item un entier $n\ge 2$ (nombre de participants) ;
  \item un entier $k$ avec $2\le k\le n$ (seuil) ;
  \item le corps $\F_P$ avec $P=2^{521}-1$ ;
  \item la fonction de hachage $h$ (SHA-256) ;
  \item les fonctions dérivées $\HMAC_h$, $\HKDF_h$, $\PBKDF_h$ ;
  \item un schéma de signature Ed25519 sur $(E(\F_q),\langle B\rangle)$ ;
  \item un schéma RSA-OAEP pour des modules de taille $4096$ bits ;
  \item AES-GCM avec blocs de 128 bits et clés de 256 bits.
\end{itemize}
\end{definition}

\begin{definition}[Constantes de contexte et sels]
On fixe les constantes suivantes une fois pour toutes :
\begin{itemize}[leftmargin=2em]
  \item $\mathrm{info}_{\mathrm{Ed}} := \texttt{"ed25519-master-key"} \in\bin^*$ (chaîne ASCII) ;
  \item $\mathrm{info}_{\mathrm{RSA}} := \texttt{"rsa-wrap-key"} \in\bin^*$ (chaîne ASCII) ;
  \item un sel HKDF public pour Ed25519,
        $\mathrm{saltEd} := \texttt{"ed25519-salt"} \in\bin^*$ (chaîne ASCII) ;
  \item une longueur de sel pour le \emph{wrap} RSA
        $\ell_{\mathrm{wrap}} := 128$ bits, et, pour chaque cérémonie,
        un sel HKDF public pour RSA $W\in\bin^{\ell_{\mathrm{wrap}}}$ tiré uniformément ;
  \item une longueur de sel PBKDF2 fixée à $\ell_S := 128$ bits et,
        pour chaque participant $i$, un sel individuel
        $S_i\in\bin^{\ell_S}$ tiré uniformément ;
  \item un nombre d'itérations PBKDF2 fixé à $c := 501000$ ;
  \item pour RSA-OAEP, un label fixé à la chaîne vide
        $L := \varepsilon \in\bin^*$.
\end{itemize}
\end{definition}

\subsection{Cérémonie initiale}
\label{sec:init}

\begin{definition}[Encodage des éléments de $\F_P$]
Soit $\phi: \F_P \to \bin^{521}$ l'isomorphisme qui à $a \in \F_P$
associe sa représentation binaire big-endian sur
$\lceil \log_2 P \rceil = 521$ bits.
\end{definition}

\begin{definition}[Étape de génération]
La cérémonie initiale réalise les étapes suivantes :
\begin{enumerate}[leftmargin=2em,label=\arabic*)]
  \item Tirer $S\in\bin^{256}$ uniformément et définir
        $s = \mathrm{val}_{\mathrm{be}}(S) \bmod P \in \F_P$.
  \item Appliquer $\mathrm{Share}(s)$ pour obtenir les parts
        $(x_i,y_i)_{1\le i\le n}$.
  \item Dériver la clé
  \[
    K_{\mathrm{Ed}} = \HKDF_h(S,\mathrm{saltEd},
    \mathrm{info}_{\mathrm{Ed}},32) \in \bin^{256}.
  \]
  \item Dériver à partir de $K_{\mathrm{Ed}}$ la paire de clés Ed25519
        $(a,A)$.
  \item Générer une paire RSA $(n,e,d)$ avec $n$ de 4096 bits.
  \item Tirer $W\in\bin^{\ell_{\mathrm{wrap}}}$ et dériver la clé
  \[
    K_{\mathrm{RSA}} = \HKDF_h(S,W,
    \mathrm{info}_{\mathrm{RSA}},L_{\mathrm{RSA}}) \in \bin^{8L_{\mathrm{RSA}}}
  \]
  avec $L_{\mathrm{RSA}}=32$ (clé AES-256 de 32 octets).
  \item Encoder la clé privée RSA en un mot binaire
        $M_{\mathrm{RSA}}$ au format PEM, puis calculer
  \[
    (C_{\mathrm{RSA}}, T_{\mathrm{RSA}}) =
      \AESGCM_{K_{\mathrm{RSA}}}(N_{\mathrm{RSA}}, M_{\mathrm{RSA}})
  \]
  pour un nonce $N_{\mathrm{RSA}}\in\bin^{96}$.
  \item Stocker $(W,N_{\mathrm{RSA}},C_{\mathrm{RSA}},T_{\mathrm{RSA}})$
        dans \texttt{rsa\_wrapped.json}.
\end{enumerate}
\end{definition}

\subsection{Format des parts chiffrées et champ \texttt{pub\_hash}}
\label{subsec:format-parts}

Les parts Shamir $(x_i,y_i)$ sont finalement encapsulées dans une structure chiffrée à deux niveaux : un objet JSON interne (contenant les métadonnées et la part) est chiffré par AES-GCM, puis placé dans une enveloppe JSON externe contenant les paramètres nécessaires au déchiffrement.

L'objet JSON interne, qui sera chiffré, a la forme suivante :

\begin{itemize}[leftmargin=2em]
  \item \texttt{"version"} : chaîne de version du format de part (par exemple
        \texttt{"kofn-shamir-v1"}).
  \item \texttt{"k"} et \texttt{"n"} : paramètres entiers du schéma de Shamir.
  \item \texttt{"index"} : entier $i$ identifiant la part $(x_i,y_i)$.
  \item \texttt{"x"} : entier $i$ identifiant la part, stocké directement comme entier JSON.
  \item \texttt{"y"} : coordonnée $y_i = f(i) \in \F_P$, encodée en hexadécimal big-endian
        (chaîne hexadécimale) pour représenter cet élément de $\F_P$ sur 521 bits.
  \item \texttt{"pub\_hash"} : identifiant public du secret maître, commun à toutes les parts
        issues d'une même cérémonie (voir ci-dessous).
  \item \texttt{"holder"} : \emph{(facultatif, purement documentaire)} chaîne libre indiquant
        le nom du porteur de la part. Ce champ n'intervient dans aucun calcul cryptographique.
\end{itemize}

\begin{remark}[Structure d'enveloppe chiffrée]
Dans l'implémentation, l'objet JSON interne est chiffré par AES-GCM avec une clé dérivée du mot de passe du porteur via PBKDF2. Le résultat est ensuite encapsulé dans une enveloppe JSON externe qui contient les éléments nécessaires au déchiffrement, tous en clair (encodés en Base64) :

\begin{itemize}[leftmargin=2em]
  \item \texttt{"salt"} : le sel $S_i$ utilisé par PBKDF2 pour dériver la clé de chiffrement. Ce sel est stocké en clair car il est nécessaire pour la dérivation de la clé à partir du mot de passe.
  \item \texttt{"nonce"} : le nonce $N_i$ utilisé par AES-GCM. Il est également en clair, comme requis par le mode GCM.
  \item \texttt{"ct"} : le texte chiffré AES-GCM, c'est-à-dire l'objet JSON interne chiffré.
\end{itemize}

Ainsi, lors du déverrouillage d'une part, le script lit d'abord l'enveloppe externe, décode le sel $S_i$ et le nonce $N_i$, dérive la clé AES $K_i = \PBKDF_h(P_i, S_i, c, 32)$ à partir du mot de passe $P_i$ et du sel $S_i$, puis déchiffre le contenu de \texttt{ct} avec $K_i$ et $N_i$ pour obtenir l'objet JSON interne contenant les coordonnées $(x_i, y_i)$ et les métadonnées de la part.
\end{remark}

\begin{definition}[Empreinte publique \texttt{pub\_hash}]
Soit $A$ la clé publique Ed25519 du maître (section~\ref{sec:ed25519}). On définit
\[
  \textsf{pub\_hash} = \mathrm{SHA256}(\mathrm{enc}(A)) \in \bin^{256},
\]
et l'on stocke sa représentation hexadécimale dans le champ JSON \texttt{"pub\_hash"}.

Toutes les parts produites lors d'une même cérémonie (c'est-à-dire pour un même secret maître
$S$ et une même clé publique $A$) portent exactement la même valeur \texttt{pub\_hash}. Ce champ
permet au code de reconstruction de vérifier rapidement que les parts fournies proviennent bien
du même secret maître, et de rejeter immédiatement toute combinaison mélangeant des parts
issues de cérémonies différentes.
\end{definition}

Dans le script de reconstruction des signatures (\texttt{kofn\_sign.py}), une vérification
explicite est effectuée : toutes les valeurs \texttt{pub\_hash} des parts entrantes doivent
coïncider, faute de quoi la procédure s'arrête avec une erreur. Cette vérification explicite
complète la sécurité du schéma de Shamir décrite à la Proposition~\ref{prop:perfect-secrecy}.

\subsection{Déverrouillage de la clé RSA privée et cohérence des parts}
\label{subsec:kofn-rsa-decrypt}

Dans le cas du déchiffrement RSA (script \texttt{kofn\_rsa\_decrypt.py}), les parts Shamir sont
utilisées pour reconstruire le secret maître $S$, puis pour dériver, via HKDF, la clé symétrique
$K_{\mathrm{RSA}}$ qui déchiffre la clé RSA privée en AES-256-GCM.

On note que, contrairement au script de signature \texttt{kofn\_sign.py}, le script
\texttt{kofn\_rsa\_decrypt.py} ne vérifie pas explicitement que toutes les parts d'entrée portent
le même champ \texttt{pub\_hash}. La cohérence des parts est cependant implicitement contrôlée
par l'étape de déchiffrement AES-GCM :

\begin{itemize}[leftmargin=2em]
  \item une combinaison incohérente de parts conduit à une valeur erronée de $S$,
        donc à une clé dérivée $K_{\mathrm{RSA}}$ incorrecte ;
  \item le déchiffrement de la clé RSA privée chiffrée échoue alors avec un tag AES-GCM invalide :
        la sortie est rejetée (symbole $\perp$) et aucune clé RSA privée exploitable n'est produite.
\end{itemize}

On dispose donc de deux mécanismes logiquement équivalents pour détecter des combinaisons
de parts incohérentes :
\begin{enumerate}
  \item comparaison explicite des champs \texttt{pub\_hash} (cas de \texttt{kofn\_sign.py}) ;
  \item échec du déverrouillage AES-GCM de la clé RSA privée lorsque $S$ a été mal reconstruit
        (cas de \texttt{kofn\_rsa\_decrypt.py}).
\end{enumerate}

Dans les deux cas, aucune combinaison de parts appartenant à des cérémonies différentes
ne peut passer inaperçue : soit elle est rejetée dès la vérification de \texttt{pub\_hash},
soit elle conduit à un échec cryptographique explicite (tag AES-GCM invalide) lors de la
reconstruction de la clé RSA privée.

\subsection{Chiffrement hybride des fichiers}

\begin{definition}[Chiffrement hybride d'un fichier]
Soit un fichier $F\in\bin^*$. On procède comme suit :
\begin{enumerate}[leftmargin=2em,label=\arabic*)]
  \item Tirer une clé de session $K_{\mathrm{AES}}\in\bin^{256}$.
  \item Tirer un nonce $N\in\bin^{96}$.
  \item Calculer $(C,T)=\AESGCM_{K_{\mathrm{AES}}}(N,F)$.
  \item Calculer $E_K = \RSAOAEP_{(n,e)}(K_{\mathrm{AES}};r)$ pour un
        aléa $r\in\bin^{k_1}$ et le label fixé $L=\varepsilon$.
\end{enumerate}
Le quadruplet $(E_K,N,C,T)$ est le chiffrement hybride de $F$.
\end{definition}

%=========================================================
\section{Correspondance avec les scripts Tails v1}

Cette section établit la correspondance entre les objets formalisés
ci-dessus et les éléments concrets (scripts, fichiers) de la procédure
Tails v1.

\subsection{Secret maître et partage Shamir}

\begin{itemize}[leftmargin=2em]
  \item Le secret $S\in\bin^{256}$ est généré par
        \verb|os.urandom(32)| dans le script
        \texttt{ceremony\_generate.py} (variable \verb|S_int|).
  \item La conversion $s = \mathrm{val}_{\mathrm{be}}(S) \bmod P \in \F_P$
        est implicite dans l'implémentation Python.
  \item Les partages $(x_i,y_i)$ sont obtenus par évaluation d'un
        polynôme $f\in\mathcal{P}_{<k}$ via la fonction
        \verb|shamir_split|.
  \item La reconstruction utilise l'interpolation de Lagrange dans
        \verb|shamir_reconstruct| avec calcul explicite des coefficients
        $\lambda_j$.
\end{itemize}

\subsection{Clés dérivées, sels HKDF et Ed25519}

\begin{itemize}[leftmargin=2em]
  \item La clé
        $K_{\mathrm{Ed}} = \HKDF_h(S,\mathrm{saltEd},
        \mathrm{info}_{\mathrm{Ed}},32)$ est instanciée via :
\begin{verbatim}
hkdf_ed = HKDF(
    algorithm=SHA256(),
    length=32,
    salt=b"ed25519-salt",
    info=b"ed25519-master-key",
)
K_Ed = hkdf_ed.derive(S)
\end{verbatim}

  \item De même,
        $K_{\mathrm{RSA}} = \HKDF_h(S,W,
        \mathrm{info}_{\mathrm{RSA}},32)$ utilise
        \verb|info=b"rsa-wrap-key"| avec un sel aléatoire $W$
        stocké dans \texttt{rsa\_wrapped.json}. En API, on écrit par exemple :
\begin{verbatim}
hkdf_rsa = HKDF(
    algorithm=SHA256(),
    length=32,
    salt=W,
    info=b"rsa-wrap-key",
)
K_RSA = hkdf_rsa.derive(S)
\end{verbatim}

  \item La paire $(a,A)$ est construite via
        \verb|Ed25519PrivateKey.from_private_bytes(ed_seed)|,
        où \texttt{ed\_seed} est $K_{\mathrm{Ed}}$. L'API effectue le
        \emph{clampage} et calcule $A = aB$.
\end{itemize}
\subsection{PBKDF2, sels $S_i$ et chiffrement des parts}

\begin{itemize}[leftmargin=2em]
  \item Pour chaque participant $i$, le script tire un sel $S_i$
        de 16 octets (128 bits) et dérive
        $K_i = \PBKDF_h(P_i,S_i,c,32)$ avec $c=501000$ itérations.
  \item Les parts sont sérialisées en JSON avec les champs
        \texttt{x}, \texttt{y}, \texttt{k}, \texttt{n}, et
        \texttt{pub\_hash}, puis chiffrées par AES-GCM.
  \item L'enveloppe chiffrée inclut les métadonnées nécessaires pour la
        vérification lors de la reconstruction.
\end{itemize}

\subsection{RSA, OAEP et chiffrement hybride}

\begin{itemize}[leftmargin=2em]
  \item La paire RSA $(n,e,d)$ est générée avec $n=4096$ bits
        et $e=65537$.
  \item La clé privée RSA est sérialisée en PEM puis chiffrée sous
        AES-GCM avec $K_{\mathrm{RSA}}$, produisant
        \texttt{rsa\_wrapped.json}.
  \item Le script \texttt{rsa\_hybrid\_encrypt.py} implémente le
        chiffrement hybride :
        \begin{itemize}
        \item génération de $K_{\mathrm{AES}} \in \bin^{256}$ ;
        \item chiffrement de $F$ par $\AESGCM_{K_{\mathrm{AES}}}(N,F)$
              avec un nonce de 96 bits ;
        \item chiffrement de $K_{\mathrm{AES}}$ par $\RSAOAEP_{(n,e)}$
              avec $L=\varepsilon$.
        \end{itemize}
  \item Le déchiffrement dans \texttt{kofn\_rsa\_decrypt.py} inverse ces
        étapes après reconstruction de $S$ et déverrouillage de la clé RSA.
\end{itemize}

\subsection{Signature Ed25519 avec contexte}

\begin{itemize}[leftmargin=2em]
  \item Les signatures utilisent un contexte déterministe :
        \[
        \mathrm{contexte} = \texttt{"kofn-ed25519-v1"} \concat
        \mathrm{SHA256}(A) \concat M
        \]
        pour éviter la réutilisation hors contexte.
  \item La vérification dans \texttt{verify\_ed25519.py} utilise le même
        contexte, assurant l'authenticité même avec la même clé publique.
\end{itemize}

\subsection{Gestion sécurisée de la mémoire}

\begin{itemize}[leftmargin=2em]
  \item Les secrets éphémères ($S$, graines Ed25519) sont stockés dans des 
        \texttt{bytearray} pour permettre l'effacement explicite via
        \verb|secure_wipe|.
  \item Cette mesure atténue les risques d'exposition en RAM après usage.
\end{itemize}

\subsection{Résumé sur les sels publics}

\begin{itemize}[leftmargin=2em]
  \item Sel HKDF Ed25519 $\mathrm{saltEd}$ :
        \begin{itemize}
          \item valeur : chaîne ASCII constante
                \verb|"ed25519-salt"| ;
          \item génération : aucun tirage, valeur codée en dur
                dans le script ;
          \item stockage : implicite dans le code, public et identique
                pour toutes les cérémonies.
        \end{itemize}
  \item Sel HKDF RSA (wrap salt) $W$ :
        \begin{itemize}
          \item valeur : bitstring aléatoire de 128 bits
                \verb|wrap_salt| généré par
                \verb|os.urandom(WRAP_SALT_SIZE)| ;
          \item génération : une fois par cérémonie de génération
                de la clé RSA ;
          \item stockage : champ \verb|"salt"| dans
                \texttt{rsa\_wrapped.json}, encodé en Base64, public.
        \end{itemize}
  \item Sels PBKDF2 $S_i$ :
        \begin{itemize}
          \item valeur : bitstrings aléatoires individuels
                de 128 bits, un par participant, générés par
                \verb|os.urandom(SALT_SIZE)| ;
          \item génération : lors de la création ou de la mise à jour de la
                protection de la part du participant $i$ ;
          \item stockage : dans la partie personnelle du coffre du participant,
                aux côtés de $(N_i,C_i,T_i)$, public mais lié au participant.
        \end{itemize}
\end{itemize}

%=========================================================
\section{Résumé des propriétés de sécurité}

\begin{definition}[Modèle de sécurité]
On considère un adversaire $\mathcal{A}$ ayant accès aux oracles :
\begin{itemize}
\item $\mathcal{O}_{\mathrm{Share}}$ : renvoie jusqu'à $t < k$ parts ;
\item $\mathcal{O}_{\mathrm{Sign}}$ : signe des messages avec la clé Ed25519 ;
\item $\mathcal{O}_{\mathrm{Decrypt}}$ : déchiffre des textes chiffrés.
\end{itemize}
\end{definition}

\begin{theorem}[Confidentialité conditionnelle]
Soit $\mathcal{A}$ un adversaire polynomial n'ayant accès qu'à $t < k$ parts.
Alors pour toute fonction $f$ calculable en temps polynomial :
\[
\left|\mathbb{P}[\mathcal{A}(f(S)) = 1] - \mathbb{P}[\mathcal{A}(f(U)) = 1]\right|
\leq \epsilon(\lambda)
\]
où $U$ est uniforme dans $\bin^{256}$ et $\epsilon$ est négligeable dans
le paramètre de sécurité $\lambda$.
\end{theorem}

\begin{theorem}[Intégrité des signatures et des chiffrés]
Sous les hypothèses que HKDF, PBKDF2, AES-GCM et RSA-OAEP sont
cryptographiquement sûrs, il est computationnellement difficile pour un
adversaire polynomial de forger une signature Ed25519 valide ou de
modifier un texte chiffré AES-GCM sans être détecté.
\end{theorem}

\begin{remark}
Une preuve complète de sécurité nécessiterait un modèle d'adversaire
précis (oracles, ressources de calcul) et l'utilisation de techniques de
réduction dans des modèles comme l'oracle aléatoire. On ne la développe
pas ici.
\end{remark}

%=========================================================
% RÉFÉRENCES
%=========================================================

\newpage


\appendix

\section{Annexe A --- Corps finis et notation $\F_{2^n}$}
\label{sec:annexe-moore}
Cette annexe rassemble les compléments d'algèbre nécessaires pour justifier entièrement
l'utilisation de la notation $\F_{2^n}$ (et, plus généralement, $\F_{p^n}$) dans le reste
du document. Toutes les démonstrations reposent sur des arguments élémentaires portant sur
des objets finis : polynômes sur $\F_p$, groupes abéliens finis, dénombrements.
Dans cette annexe, on détaille les éléments de théorie des corps finis
qui justifient complètement le Théorème~\ref{thm:moore}. On travaille
toujours avec un nombre premier $p$ et des corps de caractéristique $p$.

\subsection{Caractéristique et sous-corps premier}
\label{sec:sous-corps-premier}

\begin{definition}[Caractéristique d'un corps]
Soit $K$ un corps. La \emph{caractéristique} de $K$ est le plus petit entier
$p \ge 1$ tel que
\[
\underbrace{1 + 1 + \cdots + 1}_{p\ \text{fois}} = 0
\]
s'il existe, et $0$ sinon.
\end{definition}

\begin{proposition}
\label{prop:caract-prime}
Si $K$ est un corps fini, alors sa caractéristique est un nombre premier $p$.
\end{proposition}

\begin{proof}
Comme $K$ est fini, le sous-groupe additif engendré par $1$ est lui aussi fini.
Il existe donc un entier $p \ge 1$ minimal tel que $p \cdot 1 = 0$. On montre
que $p$ est premier : si $p=ab$ avec $1<a,b<p$, on a
\[
0 = p\cdot 1 = (ab)\cdot 1 = a \cdot (b\cdot 1),
\]
et comme $K$ est sans diviseur de zéro (c'est un corps), cela implique
$b\cdot 1 = 0$ ou $a\cdot 1 = 0$, en contradiction avec la minimalité de $p$.
\end{proof}

\begin{proposition}[Sous-corps premier]
\label{prop:sous-corps-premier}
Soit $K$ un corps de caractéristique $p>0$. L'application
\[
\varphi : \F_p \longrightarrow K,\quad \overline{n} \longmapsto n\cdot 1_K
\]
est un homomorphisme injectif de corps. Son image est un sous-corps de $K$,
appelé \emph{sous-corps premier} de $K$, isomorphe à $\F_p$.
\end{proposition}

\begin{proof}
L'application est bien définie : dans $\F_p$, on a $\overline{n}=\overline{m}$
si et seulement si $p$ divise $n-m$. Dans ce cas, il existe $q\in\Z$ tel que
$n-m = pq$, et donc dans $K$,
\[
(n-m)\cdot 1_K = pq\cdot 1_K = p\cdot (q\cdot 1_K) = 0
\]
puisque $K$ est de caractéristique $p$. On a donc bien $n\cdot 1_K = m\cdot 1_K$,
ce qui montre que $\varphi$ ne dépend pas du représentant choisi.

Pour tout $\overline{n},\overline{m}\in\F_p$, on vérifie directement
\[
varphi(\overline{n}+\overline{m})
= (n+m)\cdot 1_K
= n\cdot 1_K + m\cdot 1_K
= \varphi(\overline{n}) + \varphi(\overline{m}),
\]
et
\[
\varphi(\overline{n}\,\overline{m})
= (nm)\cdot 1_K
= (n\cdot 1_K)(m\cdot 1_K)
= \varphi(\overline{n})\,\varphi(\overline{m}),
\]
ainsi que $\varphi(1)=1_K$. L'application $\varphi$ est donc un homomorphisme
de corps.

Pour l'injectivité, supposons $\varphi(\overline{n}) = 0$. Alors
$n\cdot 1_K = 0$. Par définition de la caractéristique $p$, cela implique que
$p$ divise $n$, donc $\overline{n} = 0$ dans $\F_p$. Ainsi, $\ker(\varphi) =
\{0\}$ et $\varphi$ est injective. Son image est donc un sous-corps de $K$
isomorphe à $\F_p$, appelé sous-corps premier de $K$.
\end{proof}

Ainsi, tout corps fini $K$ contient un sous-corps isomorphe à $\F_p$, et on
peut voir $K$ comme une extension finie de $\F_p$.

\subsection{Cardinal d'un corps fini}

\begin{proposition}
\label{prop:cardinal-pn}
Soit $K$ un corps fini de caractéristique $p$, et soit $k$ le sous-corps
premier de $K$ (isomorphe à $\F_p$). Alors $K$ est un $k$-espace vectoriel
de dimension finie $n$, et
\[
|K| = p^n.
\]
\end{proposition}

\begin{proof}
Par la Proposition~\ref{prop:sous-corps-premier}, $k$ est un sous-corps de $K$,
isomorphe à $\F_p$. On définit sur $K$ une structure de $k$-espace vectoriel
en posant :
\begin{itemize}
  \item pour $x,y \in K$, la somme vectorielle est l'addition dans $K$ ;
  \item pour $\lambda \in k$ (donc $\lambda \in K$) et $x \in K$, la
        multiplication scalaire est donnée par
        \[
        \lambda \cdot x := \lambda x,
        \]
        où le produit est celui de $K$.
\end{itemize}
Les axiomes d'espace vectoriel se vérifient alors directement à partir des
axiomes de corps dans $K$ :
\begin{itemize}
  \item la distributivité de la multiplication dans $K$ donne
        $\lambda\cdot(x+y) = \lambda x + \lambda y$ et
        $(\lambda+\mu)\cdot x = \lambda x + \mu x$ ;
  \item l'associativité de la multiplication donne
        $(\lambda\mu)\cdot x = \lambda\cdot(\mu\cdot x)$ ;
  \item l'élément neutre $1_k = 1_K$ vérifie $1_k\cdot x = x$ pour tout $x\in K$.
\end{itemize}
Ainsi, $K$ est bien un $k$-espace vectoriel.

Comme $K$ est fini, il existe une base finie $(e_1,\dots,e_n)$ de $K$ sur $k$.
Tout élément $x\in K$ s'écrit alors de manière unique comme combinaison linéaire
\[
x = \lambda_1 e_1 + \cdots + \lambda_n e_n,\quad \lambda_i \in k.
\]
Il y a exactement $p^n$ $n$-uplets $(\lambda_1,\dots,\lambda_n)$ puisque
$|k|=p$. Donc $|K| = p^n$.
\end{proof}

Cela justifie l'écriture \og $|K|=p^n$ \fg{} et le fait de noter un corps fini
$K$ de cardinal $p^n$ par $\F_{p^n}$.

\subsection{Frobenius et polynôme $X^{p^n}-X$}

\begin{theorem}[Théorème fondamental de l'arithmétique]
\label{lem:thm-fond-arith}
Tout entier $n \ge 2$ peut s'écrire comme un produit fini de nombres premiers.
De plus, cette écriture est unique à l'ordre près des facteurs.
\end{theorem}

\begin{proof}
Nous divisons la preuve en deux parties : existence puis unicité.

\medskip
\noindent\textbf{Existence.}
Nous montrons par récurrence sur $n \ge 2$ que tout entier $n$ s'écrit comme un
produit de nombres premiers (en autorisant le cas d'un seul facteur premier).

\begin{itemize}
  \item Pour $n=2$, l'entier $2$ est premier, la propriété est donc vraie.
  \item Supposons la propriété vraie pour tous les entiers $m$ tels que
        $2 \le m < n$, et montrons-la pour $n$.
        \begin{itemize}
          \item Si $n$ est premier, alors $n$ est déjà un produit de nombres
                premiers (un seul facteur).
          \item Si $n$ n'est pas premier, il existe des entiers $a,b$ tels que
                $1 < a < n$, $1 < b < n$ et $n = ab$. Par hypothèse de
                récurrence, $a$ et $b$ s'écrivent chacun comme produit de
                nombres premiers. Le produit $n = ab$ est alors lui-même un
                produit de nombres premiers.
        \end{itemize}
\end{itemize}
Par récurrence, tout entier $n \ge 2$ s'écrit comme produit de nombres premiers.

\medskip
\noindent\textbf{Unicité.}
Supposons que l'on ait deux écritures de $n$ en produit de nombres premiers :
\[
n = p_1 p_2 \cdots p_r = q_1 q_2 \cdots q_s,
\]
où les $p_i$ et les $q_j$ sont des nombres premiers (pas nécessairement
distincts). Nous allons montrer que $r=s$ et, à permutation près, $p_i = q_i$
pour tout $i$.

Comme $p_1$ est premier et divise le produit $q_1 \cdots q_s$, le
Théorème~\ref{thm:gauss-div} (lemme d'Euclide) implique que $p_1$ divise l'un
des $q_j$. Or chacun des $q_j$ est premier, donc si un nombre premier $p_1$
divise $q_j$, on a nécessairement $p_1 = q_j$. En renommant si besoin les
$q_j$, on peut supposer $p_1 = q_1$.

En simplifiant par $p_1 = q_1$ (qui est non nul), on obtient
\[
\frac{n}{p_1} = p_2 \cdots p_r = q_2 \cdots q_s.
\]
Si $r=1$, alors $n = p_1$ est premier et il n'y a rien d'autre à prouver.
Sinon, l'entier $n/p_1$ est $\ge 2$ et strictement plus petit que $n$. On
applique le même raisonnement à $n/p_1$ (récurrence sur le nombre total de
facteurs premiers) et on conclut que $r=s$ et que, à réordonnement près,
$p_i = q_i$ pour tout $i$.

Ainsi, la décomposition de $n$ en produit de nombres premiers est unique à
l'ordre près des facteurs.
\end{proof}

\begin{proposition}[Endomorphisme de Frobenius]
\label{prop:frobenius}
Soit $K$ un corps de caractéristique $p$. L'application
\[
\varphi : K \longrightarrow K,\quad x \longmapsto x^p
\]
est un homomorphisme de corps, appelé \emph{endomorphisme de Frobenius}.
\end{proposition}

\begin{proof}
Pour $x,y \in K$, on a dans $\Z$
\[
(x+y)^p = \sum_{k=0}^p \binom{p}{k} x^k y^{p-k}.
\]

Pour $0<k<p$, montrons que le coefficient binomial $\binom{p}{k}$ est multiple
de $p$. Dans $\Z$, on dispose de l'égalité
\[
\binom{p}{k}\,k! \;=\; p(p-1)(p-2)\cdots(p-k+1).
\]
Le produit du membre de droite contient le facteur $p$, donc $p$ divise
$\binom{p}{k}\,k!$.

Montrons maintenant que $p$ ne divise pas $k!$. Par le Théorème~%
\ref{lem:thm-fond-arith}, on peut écrire la décomposition en facteurs premiers
de $k!$ sous la forme
\[
k! = \prod_{i=1}^r \ell_i^{\alpha_i},
\]
où les $\ell_i$ sont des nombres premiers et $\alpha_i \ge 1$. Chaque $\ell_i$
divise l'un des entiers $1,2,\dots,k$, donc $\ell_i \le k < p$. Si l'on supposait
que $p$ divise $k!$, alors $p$ devrait être égal à l'un des $\ell_i$, ce qui
entraînerait une contradiction avec l'hypothèse $k<p$. Ainsi, $p$ ne
divise pas $k!$.


Comme $p$ divise $\binom{p}{k}\,k!$ et que $p$ ne divise pas $k!$, les seuls
diviseurs positifs possibles de $p$ étant $1$ et $p$, on a donc
$\gcd(p,k!) = 1$. Le Théorème~\ref{thm:gauss-div} s'applique alors avec
$a=p$ et $b=k!$, ce qui implique que $p$ divise $\binom{p}{k}$.



Dans un corps $K$ de caractéristique $p$, cela signifie que l'image de
$\binom{p}{k}$ est nulle : si $\binom{p}{k} = p q$ dans $\Z$, alors dans $K$
\[
\binom{p}{k}\cdot 1_K = (pq)\cdot 1_K = p\cdot(q\cdot 1_K) = 0,
\]
puisque $p\cdot 1_K = 0$. Pour $0<k<p$, on a donc bien $\binom{p}{k}=0$
dans $K$.

Dans le développement binomial de $(x+y)^p$, tous les termes intermédiaires
disparaissent donc dans $K$, et il reste
\[
(x+y)^p = x^p + y^p.
\]

La compatibilité à la multiplication est immédiate :
\[
(xy)^p = x^p y^p,
\]
et enfin $\varphi(1) = 1^p = 1$, donc $\varphi$ respecte l'addition,
la multiplication et l'élément neutre. C'est donc un homomorphisme de corps.
\end{proof}

\begin{proposition}
\label{prop:frobenius-bij}
Si $K$ est un corps fini de caractéristique $p$, l'endomorphisme de Frobenius
$\varphi : x \mapsto x^p$ est bijectif.
\end{proposition}

\begin{proof}
Un homomorphisme de corps est injectif dès que son noyau est réduit à $\{0\}$.
Mais si $\varphi(x)=0$, alors $x^p=0$ implique $x=0$ dans un corps. Ainsi
$\varphi$ est injectif. Comme $K$ est fini, une application injective est
automatiquement surjective, donc $\varphi$ est bijective.
\end{proof}

\begin{corollary}
\label{cor:pn-frobenius}
Soit $K$ un corps fini de cardinal $p^n$. Pour tout $x \in K$, on a
\[
x^{p^n} = x.
\]
En identifiant $\F_p$ avec le sous-corps premier de $K$ 
(Proposition~\ref{prop:sous-corps-premier}), on peut considérer 
$X^{p^n}-X$ comme un polynôme de $\F_p[X] \subseteq K[X]$. Autrement dit,
tout élément de $K$ est racine du polynôme $X^{p^n}-X \in \F_p[X]$.
\end{corollary}

\begin{proof}
Notons $q = |K| = p^n$. Pour $x=0$, on a trivialement $0^q = 0$.

Supposons maintenant $x \in K^\times$. Le groupe multiplicatif $K^\times$ a
pour cardinal $q-1$. Par le théorème de Lagrange sur les groupes finis,
l'ordre de $x$ divise $q-1$, donc $x^{\,q-1} = 1$. En multipliant par $x$,
on obtient
\[
x^q = x,
\]
c'est-à-dire $x^{p^n} = x$.

Ainsi, pour tout $x \in K$ (nul ou non nul), on a bien $x^{p^n} = x$, ce qui
signifie que tout élément de $K$ est racine du polynôme $X^{p^n}-X \in \F_p[X]$.
\end{proof}

\begin{lemma}[Corps de décomposition d'un polynôme]
\label{lem:corps-decomp}
Soit $K$ un corps et soit $P(X) \in K[X]$ un polynôme non constant. Il existe
une extension de corps $L \supseteq K$ dans laquelle $P$ se scinde dans $L[X]$
en produit de facteurs linéaires.
\end{lemma}

\begin{proof}
On procède par récurrence sur le degré $d = \deg(P) \ge 1$.

Si $d=1$, le polynôme $P$ est déjà linéaire et se scinde sur $K$ ; on peut
prendre $L = K$.

Supposons $d \ge 2$ et le résultat vrai pour tous les polynômes de degré
strictement inférieur à $d$. Comme $K[X]$ est un anneau principal euclidien,
tout polynôme non constant admet un facteur irréductible non constant.
Choisissons un tel facteur irréductible $f_1(X)$ de $P(X)$ dans $K[X]$.

On considère alors le quotient
\[
K_1 = K[X]/(f_1).
\]
C'est un corps, et si l'on note $\alpha_1$ la classe de $X$ dans $K_1$, on a
$f_1(\alpha_1) = 0$ dans $K_1$. Le polynôme $P$ admet donc une racine $\alpha_1$
dans l'extension $K_1$ de $K$.

Nous regardons maintenant $P$ comme élément de $K_1[X]$. Comme $f_1(X)$ est un
facteur de $P$ et admet $\alpha_1$ comme racine, on peut écrire
\[
P(X) = (X-\alpha_1)^m Q_1(X),
\]
où $m \ge 1$ et $Q_1(X) \in K_1[X]$ ne s'annule pas en $X=\alpha_1$. Le degré
de $Q_1$ est strictement inférieur à $d$.

Par hypothèse de récurrence appliquée au corps $K_1$ et au polynôme $Q_1$, il
existe une extension de corps $L$ de $K_1$ dans laquelle $Q_1$ se scinde en
produit de facteurs linéaires. Dans ce même corps $L$, le facteur
$(X-\alpha_1)^m$ est déjà produit de facteurs linéaires. Ainsi, dans $L[X]$,
le polynôme $P$ s'écrit comme produit de facteurs linéaires.

Comme $K \subseteq K_1 \subseteq L$, le corps $L$ est bien une extension de $K$
dans laquelle $P$ se scinde.
\end{proof}


\subsection{Polynôme $X^{p^n}-X$ et polynômes irréductibles}

Dans cette sous-section, on fixe un entier $n \ge 1$. D'après le
Lemme~\ref{lem:corps-decomp} appliqué au polynôme $X^{p^n}-X \in \F_p[X]$,
il existe une extension de corps $L$ de $\F_p$ dans laquelle $X^{p^n}-X$ se
scinde en produit de facteurs linéaires. Nous travaillerons dans une telle
extension $L$ (que l'on garde fixée pour ce $n$).


\begin{proposition}
\label{prop:racines-XpnX}
Dans l'extension $L$ fixée ci-dessus, l'ensemble des racines du polynôme
$X^{p^n} - X \in \F_p[X]$ forme un sous-corps $S$ de $L$ contenant $\F_p$.
En particulier, $S$ est un corps fini de caractéristique $p$.
\end{proposition}

\begin{proof}
Posons
\[
S = \{\,x \in L \mid x^{p^n} = x\,\}.
\]
Par définition, $S$ est exactement l'ensemble des racines de $X^{p^n}-X$ dans
$L$.

Montrons d'abord que $S$ est stable par les opérations de corps. Soient
$x,y \in S$. Alors
\[
(x+y)^{p^n} = x^{p^n} + y^{p^n} = x + y,
\]
où l'on a utilisé la Proposition~\ref{prop:frobenius} (endomorphisme de
Frobenius) itérée $n$ fois. De même,
\[
(xy)^{p^n} = x^{p^n} y^{p^n} = xy.
\]
Enfin, si $x \in S$ est non nul, alors $x^{-1}$ vérifie
\[
(x^{-1})^{p^n} = (x^{p^n})^{-1} = x^{-1}.
\]
Ainsi, $S$ est stable par addition, multiplication et passage à l'inverse
(pour les éléments non nuls), et contient $0$ et $1$. C'est donc un
sous-corps de $L$.

Comme $S$ est constitué des racines d'un polynôme de degré $p^n$, le
Lemme~\ref{lem:racines-poly} implique que $S$ est fini (et même
$|S| \le p^n$). En particulier, $S$ est un corps fini de caractéristique $p$.
\end{proof}


\begin{proposition}
\label{prop:XpnX-irreductibles}
La factorisation de $X^{p^n}-X$ dans $\F_p[X]$ est
\[
X^{p^n}-X = \prod_{\substack{f \text{ irréductible,}\\ f \in \F_p[X],\ \deg(f)\mid n}} f(X),
\]
le produit portant sur tous les polynômes irréductibles unitaires dont le degré
divise $n$, chaque facteur apparaissant une seule fois.
\end{proposition}

\begin{proof}
Soit $f \in \F_p[X]$ irréductible unitaire et soit $\alpha$ une racine de $f$
dans une extension de corps de $\F_p$ (par exemple dans le corps quotient $\F_p[X]/(f)$).
Alors $f$ est le polynôme minimal de $\alpha$ sur $\F_p$
et $\F_p(\alpha)$ est un corps de cardinal $p^d$, où $d = \deg(f)$
(cf. Proposition~\ref{prop:cardinal-pn}).
On a $\alpha^{p^d} = \alpha$ (Corollaire~\ref{cor:pn-frobenius} appliqué à
$\F_p(\alpha)$), donc $\alpha$ est racine de $X^{p^d}-X$.

Si $d$ divise $n$, alors $p^d-1$ divise $p^n-1$, et on vérifie que
\[
X^{p^n}-X = \bigl(X^{p^d}-X\bigr) \circ (\cdots),
\]
ce qui implique que toute racine de $X^{p^d}-X$ est racine de $X^{p^n}-X$.
En particulier, $\alpha$ est racine de $X^{p^n}-X$, donc le polynôme minimal
$f$ divise $X^{p^n}-X$ dans $\F_p[X]$.

Réciproquement, si $f$ divise $X^{p^n}-X$, toute racine $\alpha$ de $f$
satisfait $\alpha^{p^n}=\alpha$, donc $\alpha \in \F_{p^n}$ et
$\F_p(\alpha) \subset \F_{p^n}$, ce qui impose que $|\F_p(\alpha)| = p^d$
divise $p^n$, donc $d\mid n$.

Enfin, comme $X^{p^n}-X$ n'a pas de racine multiple (sa dérivée est
$-1 \neq 0$), il est sans facteur carré, donc chaque polynôme irréductible
apparaît au plus une fois dans la factorisation. En regroupant les facteurs
associés à chaque degré, on obtient la factorisation annoncée.
\end{proof}

\begin{corollary}[Existence de polynômes irréductibles de degré $n$]
\label{cor:irreductible-degre-n}
Pour tout entier $n \ge 1$, il existe au moins un polynôme irréductible
dans $\F_p[X]$ de degré exactement $n$.
\end{corollary}

\begin{proof}
Notons $I_d$ le nombre de polynômes irréductibles unitaires de degré $d$
dans $\F_p[X]$. La Proposition~\ref{prop:XpnX-irreductibles} donne
\[
X^{p^n}-X = \prod_{d \mid n} \ \prod_{\deg(f)=d} f(X),
\]
donc la somme des degrés des facteurs vaut
\[
p^n = \deg(X^{p^n}-X) = \sum_{d\mid n} d\, I_d.
\]
Si $I_n$ était nul, on aurait
\[
p^n = \sum_{\substack{d\mid n \\ d<n}} d\, I_d \le \sum_{\substack{d\mid n \\ d<n}} d\, p^d
< \sum_{k=0}^{n-1} p^k = \frac{p^n-1}{p-1} < p^n,
\]
ce qui est impossible. Donc $I_n>0$.
\end{proof}




\begin{lemma}[Somme des valeurs de l'indicatrice d'Euler]
\label{lem:phi-somme-diviseurs}
Pour tout entier $n \ge 1$, on a
\[
\sum_{d \mid n} \varphi(d) = n.
\]
\end{lemma}

\begin{proof}
On compte le nombre d'entiers $k$ tels que $1 \le k \le n$ de deux façons.

Pour chaque entier $k \in \{1,\dots,n\}$, posons $d = \gcd(k,n)$. Alors $d$
est un diviseur de $n$, et on peut écrire $k = d \cdot k'$ avec
$1 \le k' \le n/d$ et $\gcd(k',n/d)=1$. Inversement, pour tout diviseur
$d \mid n$ et tout entier $k'$ tel que $1 \le k' \le n/d$ et
$\gcd(k',n/d)=1$, le produit $k = d k'$ vérifie $1 \le k \le n$ et
$\gcd(k,n)=d$.

Ainsi, pour chaque diviseur $d$ de $n$, le nombre d'entiers $k$ entre $1$ et
$n$ tels que $\gcd(k,n)=d$ est exactement égal au nombre d'entiers $k'$ entre
$1$ et $n/d$ qui sont premiers avec $n/d$, c'est-à-dire $\varphi(n/d)$.

En regroupant les entiers $k$ selon la valeur de $\gcd(k,n)$, on obtient donc
\[
n = \#\{1,\dots,n\}
  = \sum_{d \mid n} \varphi\!\left(\frac{n}{d}\right).
\]
En faisant le changement de variable $e = n/d$, on voit que $e$ parcourt
exactement l'ensemble des diviseurs de $n$, et l'on obtient
\[
n = \sum_{e \mid n} \varphi(e),
\]
ce qui est la formule annoncée.
\end{proof}

\subsection{Cyclicité du groupe multiplicatif}

\begin{lemma}
\label{lem:groupe-mult-cyclique}
Soit $K$ un corps et soit $G$ un sous-groupe fini du groupe multiplicatif
$K^\times$. Alors $G$ est un groupe cyclique.
\end{lemma}

\begin{proof}
Notons $n = |G|$. Pour chaque diviseur $d$ de $n$, on introduit les ensembles
suivants :
\begin{itemize}
  \item $A_d = \{x \in G \mid \text{l'ordre de $x$ est exactement } d\}$ et
        $a_d = |A_d|$ ;
  \item $B_d = \{x \in G \mid \text{l'ordre de $x$ divise } d\}$ et
        $b_d = |B_d|$.
\end{itemize}
Les ensembles $A_d$ pour $d \mid n$ forment une partition de $G$, donc
\begin{equation}
\label{eq:partition-ordre}
n = |G| = \sum_{d \mid n} a_d.
\end{equation}

Par définition, un élément $x \in G$ appartient à $B_d$ si et seulement si
son ordre $m$ divise $d$ ; autrement dit,
\begin{equation}
\label{eq:Bd-somme-Ad}
b_d = \sum_{m \mid d} a_m \quad \text{pour tout } d \mid n.
\end{equation}

D'autre part, $B_d$ est exactement l'ensemble des solutions dans $G$ de
l'équation $x^d = 1$. Comme $G \subseteq K^\times$, ces solutions sont aussi
des solutions dans $K$ du polynôme $X^d - 1 \in K[X]$. Par le
Lemme~\ref{lem:racines-poly}, ce polynôme a au plus $d$ racines dans $K$, donc
\begin{equation}
\label{eq:bd-le-d}
b_d \le d \quad \text{pour tout } d \mid n.
\end{equation}

Nous allons maintenant montrer, par récurrence sur $d$, que pour tout
diviseur $d$ de $n$,
\begin{equation}
\label{eq:ad-le-phi}
a_d \le \varphi(d),
\end{equation}
où $\varphi$ désigne l'indicatrice d'Euler.

Pour $d=1$, le seul élément d'ordre $1$ est l'élément neutre $1_G$, donc
$a_1 = 1 = \varphi(1)$.

Supposons la propriété \eqref{eq:ad-le-phi} vraie pour tous les diviseurs
stricts de $d$, et montrons-la pour $d$. En utilisant
\eqref{eq:Bd-somme-Ad}, \eqref{eq:bd-le-d} et le
Lemme~\ref{lem:phi-somme-diviseurs}, on obtient :
\[
b_d = \sum_{m \mid d} a_m
    = a_d + \sum_{\substack{m \mid d \\ m<d}} a_m
  \le a_d + \sum_{\substack{m \mid d \\ m<d}} \varphi(m)
  \le d = \sum_{m \mid d} \varphi(m)
  = \varphi(d) + \sum_{\substack{m \mid d \\ m<d}} \varphi(m).
\]
En retranchant $\sum_{m \mid d,\,m<d} \varphi(m)$ des deux côtés, on obtient
bien $a_d \le \varphi(d)$.

En particulier, pour $d = n$, on a $a_n \le \varphi(n)$.

Montrons maintenant qu'il existe un élément d'ordre $n$ dans $G$. Supposons
par l'absurde que $a_n = 0$. Alors, comme $a_d \le \varphi(d)$ pour tout
$d \mid n$ et que $\varphi(n) \ge 1$, on a
\[
\sum_{d \mid n} a_d
  \le \sum_{\substack{d \mid n \\ d<n}} \varphi(d)
   = \sum_{d \mid n} \varphi(d) - \varphi(n)
   < \sum_{d \mid n} \varphi(d)
   = n,
\]
où l'on a utilisé le Lemme~\ref{lem:phi-somme-diviseurs} pour la dernière
égalité. Cela contredit \eqref{eq:partition-ordre}, qui affirme que
$\sum_{d \mid n} a_d = n$.

Ainsi, $a_n > 0$ : il existe au moins un élément de $G$ d'ordre $n$. Un tel
élément engendre tout le groupe $G$, qui est donc cyclique.
\end{proof}

En particulier, pour un corps fini $K$ de cardinal $p^n$, le groupe
multiplicatif $K^\times$ est cyclique d'ordre $p^n-1$.

\begin{proposition}[Élément primitif]
\label{prop:element-primitif}
Soit $K$ un corps fini de cardinal $p^n$. Il existe un élément
$\alpha \in K$ tel que
\[
K^\times = \langle \alpha \rangle.
\]
En particulier, $K = \F_p(\alpha)$ et le polynôme minimal de $\alpha$
sur $\F_p$ est de degré $n$.
\end{proposition}

\begin{proof}
Par le Lemme~\ref{lem:groupe-mult-cyclique}, $K^\times$ est cyclique :
il existe $\alpha$ tel que $K^\times = \langle \alpha \rangle$. Le sous-corps
$\F_p(\alpha)$ contient alors tous les éléments non nuls de $K$, donc
$\F_p(\alpha)=K$. Par la Proposition~\ref{prop:cardinal-pn}, le degré
$[\F_p(\alpha):\F_p]$ vaut $n$, ce qui signifie que le polynôme minimal de
$\alpha$ sur $\F_p$ est de degré $n$.
\end{proof}

\subsection{Unicité de $\F_{p^n}$ à isomorphisme près}

On peut maintenant démontrer complètement l'unicité de $\F_{p^n}$.

\begin{theorem}[Unicité à isomorphisme près]
\label{thm:unicite-Fpn}
Soient $K$ et $L$ deux corps finis de cardinal $p^n$. Alors $K$ et $L$
sont isomorphes en tant que corps.
\end{theorem}

\begin{proof}
Par la Proposition~\ref{prop:element-primitif}, il existe $\alpha \in K$
tel que $K = \F_p(\alpha)$ et le polynôme minimal $m_\alpha$ de $\alpha$
sur $\F_p$ est de degré $n$. D'après la Proposition~\ref{prop:XpnX-irreductibles},
tout polynôme irréductible de degré $n$ sur $\F_p$ divise
$X^{p^n}-X$. En particulier, $m_\alpha$ divise $X^{p^n}-X$.

Considérons le corps $L$. Comme $|L|=p^n$, le Corollaire~\ref{cor:pn-frobenius}
implique que tout élément de $L$ est racine de $X^{p^n}-X$, donc le polynôme
$m_\alpha$ se factorise dans $L[X]$ et admet une racine $\beta \in L$.

Par définition du polynôme minimal, l'application
\[
\Phi : \F_p[X]/(m_\alpha) \longrightarrow \F_p(\alpha),\quad \overline{P(X)}
\longmapsto P(\alpha)
\]
est un isomorphisme de corps, et de même
\[
\Psi : \F_p[X]/(m_\alpha) \longrightarrow \F_p(\beta),\quad \overline{P(X)}
\longmapsto P(\beta)
\]
en est un. On obtient donc un isomorphisme
\[
\theta : \F_p(\alpha) \longrightarrow \F_p(\beta),\quad \alpha \longmapsto \beta.
\]

Or $\F_p(\alpha) = K$ (Proposition~\ref{prop:element-primitif}) et
$\F_p(\beta)$ est un sous-corps de $L$ contenant $\F_p$. Son cardinal vaut
$p^{\deg(m_\alpha)} = p^n$, donc $\F_p(\beta)$ est de cardinal $p^n$.
Comme $L$ est lui-même de cardinal $p^n$, on en déduit
$\F_p(\beta) = L$. L'isomorphisme $\theta$ est donc un isomorphisme de
corps $K \simeq L$.
\end{proof}

Le Théorème~\ref{thm:unicite-Fpn}, combiné à la construction par quotient
$\F_p[X]/(m(X))$ (Corollaire~\ref{cor:irreductible-degre-n} et
Proposition~\ref{prop:corps-quotient}), donne la version complète du 
Théorème~\ref{thm:moore} utilisé dans le corps du texte : pour tout
$q=p^n$, il existe un corps fini de cardinal $q$, unique à isomorphisme près,
et l'on peut le noter sans ambiguïté $\F_{p^n}$.

\newpage


%=========================================================
% Annexe B : Borne probabiliste du test de Miller--Rabin
%=========================================================

\section{Annexe B --- Borne probabiliste du test de Miller--Rabin}
\label{sec:annexe-miller-rabin}

Dans cette annexe, on donne une preuve détaillée de la borne classique suivante
pour le test de primalité probabiliste de Miller--Rabin \cite{Conrad-MR}, dans le cas
cryptographiquement pertinent.

\begin{theorem}[Borne de Miller--Rabin]
\label{thm:MR-borne}
Soit \(n \ge 3\) un entier impair, composite, qui n'est pas une puissance d'un
nombre premier. On note
\[
  n-1 = 2^s d,\qquad s \ge 1,\ d\ \text{impair}.
\]
On considère le test de Miller--Rabin appliqué à \(n\), pour des bases \(a\)
premières avec \(n\). On appelle \emph{menteur} (ou \emph{strong liar}) toute
base \(a \in (\Z/n\Z)^\times\) pour laquelle le test déclare à tort que \(n\) est
\og probablement premier \fg{}.

On note \(L(n)\) l'ensemble des menteurs :
\[
  L(n) = \{ a \in (\Z/n\Z)^\times \mid
    \text{\(a\) passe le test de Miller--Rabin pour le module \(n\)} \}.
\]
Alors on a la borne
\[
  |L(n)| \le \frac{\varphi(n)}{4},
\]
où \(\varphi\) désigne l'indicatrice d'Euler. En particulier, si \(a\) est choisi
aléatoirement et uniformément dans \((\Z/n\Z)^\times\), la probabilité que
\(a \in L(n)\) est au plus \(1/4\).\qedhere
\end{theorem}




\subsection*{B.0. Le cas \(n = p^k\), puissance d'un premier impair}

Dans cette section, on traite séparément le cas où
\[
  n = p^k,\qquad p \text{ premier impair},\ k \ge 2,
\]
qui n'était pas couvert par l'énoncé principal du théorème~\ref{thm:MR-borne}
(voir le début de l'annexe). On conserve la notation
\[
  n-1 = 2^s d,\qquad s \ge 1,\ d\ \text{impair},
\]
et l'on note, comme dans toute l'annexe,
\[
  L(n) = \{ a \in (\Z/n\Z)^\times \mid a \text{ passe le test de Miller--Rabin pour } n \}
\]
l'ensemble des \emph{menteurs forts} (strong liars).

Notre but est de donner une description explicite de \(L(n)\) quand \(n=p^k\) et
d'en déduire une borne simple sur \(|L(n)|\).

\subsubsection*{B.0.1. Structure du groupe multiplicatif}

On note
\[
  G = (\Z/n\Z)^\times.
\]
On sait que \(G\) est cyclique d'ordre
\[
  |G| = \varphi(n) = (p-1)p^{k-1}.
\]
On écrit
\[
  \varphi(n) = 2^t m,\qquad t \ge 1,\ m\ \text{impair}.
\]
Autrement dit, \(2^t\) est la plus grande puissance de \(2\) divisant \(\varphi(n)\).

On a aussi
\[
  n-1 = p^k - 1 = (p-1)\bigl(1+p+\dots+p^{k-1}\bigr).
\]
En décomposant la partie paire, on peut écrire
\[
  p-1 = 2^t A,\qquad A\ \text{impair}.
\]
L'égalité ci-dessus montre alors que la partie impaire de \(\varphi(n)\) est
\[
  m = A\,p^{k-1},
\]
tandis que la partie impaire de \(n-1\) est de la forme
\[
  d = A\cdot C,
\]
où \(C\) est l'impair obtenu en enlevant les puissances de \(2\) du facteur
\(\,1+p+\dots+p^{k-1}\).

\begin{lemma}
\label{lem:B0-gcd-md}
Avec les notations ci-dessus, on a
\[
  \gcd(m,d) = A = \frac{p-1}{2^t}.
\]
\end{lemma}

\begin{proof}
On vient de voir que
\[
  m = A\,p^{k-1},\qquad d = A\,C,
\]
avec \(A,C\) impairs. Donc
\[
  \gcd(m,d) = \gcd(Ap^{k-1},AC) = A\,\gcd(p^{k-1},C).
\]
Or \(C\) est obtenu à partir de \(1+p+\dots+p^{k-1}\) en en retirant les facteurs
de \(2\). Mais on a
\[
  1+p+\dots+p^{k-1} \equiv 1 \pmod{p},
\]
donc \(p \nmid C\), et \(\gcd(p^{k-1},C) = 1\). D'où le résultat.
\end{proof}

\subsubsection*{B.0.2. Classification des menteurs via l'ordre de \(a\)}

On rappelle le fonctionnement du test de Miller--Rabin pour un entier impair
\(n \ge 3\) fixé : pour une base \(a\) première avec \(n\), on écrit
\(n-1 = 2^s d\) avec \(d\) impair, puis on considère la suite
\[
  x_0 = a^d,\qquad x_{r+1} = x_r^2 \pmod{n}\quad (r \ge 0).
\]
On dit que \(a\) est un \emph{menteur fort} si l'une des conditions suivantes
est vérifiée :
\begin{itemize}
  \item \(x_0 \equiv 1 \pmod{n}\);
  \item il existe \(r \in \{0,\dots,s-1\}\) tel que \(x_r \equiv -1 \pmod{n}\).
\end{itemize}

Dans le cas \(n = p^k\), le groupe \(G\) est cyclique d'ordre \(2^t m\). Soit
\(g\) un générateur de \(G\).

\begin{lemma}
\label{lem:B0-ordre-liar}
Soit \(a \in G\) et écrivons l'ordre de \(a\) sous la forme
\[
  \ord(a) = 2^\alpha \beta,\qquad 0 \le \alpha \le t,\ \beta\ \text{impair}.
\]
Alors \(a\) est un menteur (pour \(n\)) si et seulement si
\[
  \beta \mid d \quad\text{et}\quad \alpha \le s.
\]
\end{lemma}

\begin{proof}
Posons \(x_0 = a^d\). L'ordre de \(x_0\) dans \(G\) est donné par
\[
  \ord(x_0) = \frac{\ord(a)}{\gcd(\ord(a),d)}.
\]
Écrivons \(\ord(a) = 2^\alpha \beta\) avec \(\beta\) impair. Comme \(d\) est
impair, le pgcd \(\gcd(\ord(a),d)\) est lui aussi impair, disons
\(\gcd(\ord(a),d) = \delta\) avec \(\delta \mid \beta\). On obtient donc
\[
  \ord(x_0) = 2^\alpha \cdot \frac{\beta}{\delta},
\]
avec \(\beta/\delta\) impair. Notons
\[
  \ord(x_0) = 2^u v,\qquad u = \alpha,\ v = \frac{\beta}{\delta}\ \text{impair}.
\]

\textbf{Sens direct} : Supposons que \(a\) soit un menteur.

\begin{itemize}
  \item Si \(x_0 \equiv 1\), alors \(\ord(x_0) = 1\). Donc \(2^u v = 1\), d'où
    \(u=0\) et \(v=1\). En particulier, \(\alpha = 0\) et
    \(\beta = \delta \mid d\). Comme \(s \ge 1\), la condition \(\alpha \le s\)
    est triviale, et on a bien \(\beta \mid d\) et \(\alpha \le s\).

  \item Sinon, il existe \(r \in \{0,\dots,s-1\}\) tel que \(x_r \equiv -1\).
    Par définition,
    \[
      x_r = x_0^{2^r}.
    \]
    Dans le groupe cyclique \(G\), l'élément \(-1\) est l'unique élément d'ordre
    \(2\). Par conséquent, \(\ord(x_r) = 2\). Or
    \[
      \ord(x_r) = \frac{\ord(x_0)}{\gcd(\ord(x_0),2^r)}
                = \frac{2^u v}{\gcd(2^u v,2^r)}.
    \]
    Comme \(v\) est impair, le pgcd vaut \(\gcd(2^u v,2^r) = 2^{\min(u,r)}\), et
    \[
      \ord(x_r) = 2^{u-\min(u,r)} v.
    \]
    Pour que ceci soit égal à \(2\), il faut d'abord \(v=1\), puis
    \(u-\min(u,r) = 1\). On en déduit que \(u \ge 1\), \(v = 1\) et
    \(\min(u,r) = u-1\), donc \(r = u-1\). En particulier, \(r \le s-1\)
    implique \(u \le s\), i.e.\ \(\alpha \le s\). La condition \(v=1\) signifie
    que \(\beta/\delta = 1\), donc \(\beta = \delta \mid d\).
\end{itemize}

Dans tous les cas, on a donc montré que
\[
  a \text{ menteur} \;\Longrightarrow\; \beta \mid d\ \text{et}\ \alpha \le s.
\]

\textbf{Sens réciproque} : Réciproquement, supposons
\(\beta \mid d\) et \(\alpha \le s\). Écrivons \(d = \beta \cdot d_1\). Alors
\[
  x_0 = a^d = \bigl(a^\beta\bigr)^{d_1}.
\]
Comme \(\ord(a) = 2^\alpha \beta\), l'élément \(a^\beta\) a pour ordre \(2^\alpha\).
On distingue deux cas.

\begin{itemize}
  \item Si \(\alpha = 0\), alors \(\ord(a) = \beta\) est impair et \(\beta \mid d\),
    ce qui implique \(\ord(a) \mid d\) et donc \(a^d \equiv 1\). Donc \(a\) est un
    menteur de type \og \(a^d \equiv 1\) \fg{}.

  \item Si \(\alpha \ge 1\), alors \(\ord(a^\beta) = 2^\alpha\), et
    \[
      x_0 = a^d = (a^\beta)^{d_1}
    \]
    a encore pour ordre \(2^\alpha\) (car \(d_1\) est impair). La suite
    \(x_r = x_0^{2^r}\) est donc exactement la suite des puissances
    \((a^\beta)^{d_1 2^r}\). À l'étape \(r = \alpha-1\), on a
    \[
      x_{\alpha-1} = x_0^{2^{\alpha-1}}
    \]
    qui est d'ordre \(2\), donc égal à \(-1\) (l'unique élément d'ordre \(2\)
    dans \(G\)). Comme \(\alpha \le s\), on a \(\alpha-1 \le s-1\), donc cette
    occurrence de \(-1\) est bien détectée par le test de Miller--Rabin, et
    \(a\) est un menteur de type \og apparition de \(-1\) \fg{}.
\end{itemize}

Cela achève la preuve.
\end{proof}

\subsubsection*{B.0.3. Comptage explicite des menteurs}

On va maintenant exploiter la structure cyclique de \(G\) pour compter
explicitement les éléments \(a\) satisfaisant les conditions du
lemme~\ref{lem:B0-ordre-liar}.

\begin{lemma}
\label{lem:B0-nb-ordres}
Soit \(G\) un groupe cyclique d'ordre \(2^t m\) avec \(m\) impair. Pour tout
entier \(0 \le \alpha \le t\) et tout diviseur impair \(\beta\) de \(m\), le
nombre d'éléments de \(G\) d'ordre exactement \(2^\alpha \beta\) est
\[
  \varphi(2^\alpha \beta) = \varphi(2^\alpha)\,\varphi(\beta),
\]
où \(\varphi\) désigne l'indicatrice d'Euler.
\end{lemma}

\begin{proof}
C'est une propriété bien connue des groupes cycliques : si \(G = \langle g\rangle\)
est d'ordre \(N\), alors, pour chaque diviseur \(d\) de \(N\), il y a exactement
\(\varphi(d)\) éléments d'ordre \(d\), à savoir les puissances \(g^{N/d}\),
\(g^{2N/d}, \dots, g^{(d-1)N/d}\). La formule de multiplicativité
\(\varphi(uv) = \varphi(u)\varphi(v)\) pour \(\gcd(u,v)=1\) donne
\(\varphi(2^\alpha \beta) = \varphi(2^\alpha)\varphi(\beta)\) puisque \(\beta\)
est impair.
\end{proof}

Appliquons ceci à notre situation. D'après le lemme~\ref{lem:B0-ordre-liar},
un élément \(a \in G\) est menteur si et seulement si \(\ord(a) = 2^\alpha \beta\)
avec
\[
  0 \le \alpha \le \min(s,t)
  \quad\text{et}\quad
  \beta\ \text{diviseur impair de } d.
\]
Mais \(\beta\) doit aussi diviser la partie impaire \(m\) de \(|G|\); on a donc
nécessairement
\[
  \beta \mid \gcd(m,d).
\]
Posons
\[
  \Delta = \gcd(m,d)
  \qquad\text{et}\qquad
  u_0 = \min(s,t).
\]

\begin{proposition}
\label{prop:B0-card-Ln-general}
Dans le cas \(n = p^k\), on a
\[
  |L(n)|
  = \Delta \cdot 2^{u_0},
\]
où \(\Delta = \gcd(m,d)\) et \(u_0 = \min(s,t)\) sont définis comme ci-dessus.
\end{proposition}

\begin{proof}
D'après le lemme~\ref{lem:B0-ordre-liar}, on doit compter les paires
\((\alpha,\beta)\) avec \(0 \le \alpha \le u_0\) et \(\beta\) diviseur impair de
\(\Delta\). Pour une telle paire, le nombre d'éléments d'ordre \(2^\alpha \beta\)
est \(\varphi(2^\alpha \beta) = \varphi(2^\alpha)\varphi(\beta)\). On obtient
donc
\[
  |L(n)| = \sum_{\alpha=0}^{u_0} \sum_{\beta \mid \Delta}
           \varphi(2^\alpha)\,\varphi(\beta)
         = \Bigl( \sum_{\beta \mid \Delta} \varphi(\beta) \Bigr)
           \Bigl( \varphi(1) + \sum_{\alpha=1}^{u_0} \varphi(2^\alpha) \Bigr).
\]
Or \(\sum_{\beta \mid \Delta} \varphi(\beta) = \Delta\), et
\(\varphi(1) = 1\), \(\varphi(2^\alpha) = 2^{\alpha-1}\) pour \(\alpha \ge 1\). Il
vient
\[
  |L(n)| = \Delta \Bigl( 1 + \sum_{\alpha=1}^{u_0} 2^{\alpha-1} \Bigr)
         = \Delta \Bigl( 1 + (2^{u_0}-1) \Bigr)
         = \Delta \cdot 2^{u_0},
\]
comme annoncé.
\end{proof}

\subsubsection*{B.0.4. Application au cas \(n = p^k\)}

Revenons au cas particulier \(n = p^k\), \(p\) impair, \(k \ge 2\). D'après le
lemme~\ref{lem:B0-gcd-md}, on a \(\Delta = A = (p-1)/2^t\). De plus,
\(n-1 = (p-1)(1+p+\dots+p^{k-1})\) possède une valuation \(2\)-adique
\(s = t + \mu\) avec \(\mu \ge 0\). Ainsi
\[
  s \ge t,\qquad u_0 = \min(s,t) = t.
\]
La proposition~\ref{prop:B0-card-Ln-general} donne donc
\[
  |L(n)| = \Delta \cdot 2^{u_0}
         = \frac{p-1}{2^t} \cdot 2^t
         = p-1.
\]

\begin{corollary}
\label{cor:B0-Ln-prime-power}
Soit \(n = p^k\) avec \(p\) premier impair et \(k \ge 2\). Alors
\[
  |L(n)| = p-1.
\]
En particulier,
\[
  \frac{|L(n)|}{\varphi(n)}
  = \frac{p-1}{(p-1)p^{k-1}}
  = \frac{1}{p^{k-1}}.
\]
\end{corollary}

\begin{proof}
La formule \(|L(n)| = p-1\) vient du calcul précédent, et
\(\varphi(n) = (p-1)p^{k-1}\).
\end{proof}

On remarque que cette proportion de menteurs est toujours \(\le 1/4\) dès que
\[
  \frac{1}{p^{k-1}} \le \frac{1}{4}
  \quad\Longleftrightarrow\quad
  p^{k-1} \ge 4.
\]
Il y a donc un seul cas exceptionnel à exclure :

\begin{itemize}
  \item si \(p=3\) et \(k=2\), i.e.\ \(n=9\), alors
    \(|L(9)| = 2\), \(\varphi(9) = 6\) et
    \(|L(9)|/\varphi(9) = 1/3 > 1/4\) ;
  \item pour tout autre couple \((p,k)\) avec \(p\) impair, \(k \ge 2\), on a
    \(|L(n)|/\varphi(n) \le 1/4\).
\end{itemize}

\begin{remark}[Lien avec le théorème principal]
Pour le théorème~\ref{thm:MR-borne}, on a supposé que \(n\) n'était pas une
puissance d'un nombre premier. La preuve donnée dans les sections B.1 à B.7
fournit alors la borne
\[
  |L(n)| \le \frac{\varphi(n)}{4}.
\]
Le corollaire~\ref{cor:B0-Ln-prime-power} montre que, pour \(n = p^k\) avec
\(p\) impair, on a
\[
  |L(n)| = p-1 \le \frac{\varphi(n)}{4}
\]
sauf pour le seul cas \(n=9\). En pratique cryptographique (par exemple pour des
moduli de 2048 bits), ce cas minuscule est totalement hors d'atteinte, et la
borne de probabilité \og au plus \(1/4\) par base indépendante \fg{} reste donc
valable, même si l'on ne filtre pas explicitement les puissances de premiers.
\end{remark}




\subsection*{B.1. Rappel du test de Miller--Rabin}

On prend \(n\) impair, \(n \ge 3\), et on écrit
\[
  n-1 = 2^s d,\qquad s \ge 1,\ d\ \text{impair}.
\]
Soit \(a\) un entier premier à \(n\). On considère la suite
\begin{equation}
\label{eq:MR-suite}
  a^d,\ a^{2d},\ a^{4d},\ \dots,\ a^{2^{s-1}d} \pmod{n}.
\end{equation}

\begin{definition}[Témoins et menteurs]
\label{def:MR-temoin-menteur}
On dit que \(a\) est un \emph{témoin de composition} (ou \emph{strong witness})
pour \(n\) si l'une des deux conditions suivantes est vérifiée :
\begin{itemize}
  \item[(i)] \(a^d \not\equiv 1 \pmod{n}\) \emph{et}
  \item[(ii)] pour tout \(r \in \{0,1,\dots,s-1\}\),
    on a \(a^{2^r d} \not\equiv -1 \pmod{n}\).
\end{itemize}
Dans ce cas, le test Miller--Rabin détecte que \(n\) est composé.

On dit que \(a\) est un \emph{menteur} (ou \emph{strong liar}) pour \(n\) si
l'une des conditions suivantes est satisfaite :
\begin{itemize}
  \item \(a^d \equiv 1 \pmod{n}\); ou
  \item il existe \(r \in \{0,1,\dots,s-1\}\) tel que
    \(a^{2^r d} \equiv -1 \pmod{n}\).
\end{itemize}
Dans ce cas, le test de Miller--Rabin déclare \og premier \fg{} un entier en réalité
composé.\qedhere
\end{definition}

Par définition, \(L(n)\) est l'ensemble des menteurs, i.e.\ des bases qui passent
le test malgré la composité de \(n\).

\begin{remark}
Si \(\gcd(a,n) \ne 1\), le test de Miller--Rabin peut (et doit) commencer par
calculer \(\gcd(a,n)\) : si ce pgcd n'est pas \(1\), on a trouvé un facteur non
trivial de \(n\) et l'algorithme s'arrête en déclarant \og composé \fg{}. Dans toute
la suite, on ne considère donc que des \(a\) dans le groupe des unités
\((\Z/n\Z)^\times\).
\end{remark}

\subsection*{B.2. Sous-groupes associés au test}

On va exprimer la condition \og être menteur \fg{} en termes de sous-groupes de
\((\Z/n\Z)^\times\). Pour tout entier \(r \ge 0\), on pose
\[
  H_r = \{ a \in (\Z/n\Z)^\times \mid a^{2^r d} \equiv 1 \pmod{n} \}.
\]
C'est clairement un sous-groupe de \((\Z/n\Z)^\times\). En particulier,
\[
  H_0 = \{ a \mid a^d \equiv 1 \},\qquad
  H_1 = \{ a \mid a^{2d} \equiv 1 \},\quad \dots,\quad
  H_s = \{ a \mid a^{2^s d} \equiv 1 \}.
\]
Mais \(2^s d = n-1\), donc par le théorème d'Euler, \(a^{2^s d} \equiv 1\) pour
tout \(a \in (\Z/n\Z)^\times\), et ainsi
\[
  H_s = (\Z/n\Z)^\times.
\]
On a donc une suite croissante de sous-groupes :
\[
  H_0 \subseteq H_1 \subseteq \dots \subseteq H_s = (\Z/n\Z)^\times.
\]

Pour chaque \(r \ge 0\), on introduit aussi l'ensemble
\[
  C_r = \{ a \in (\Z/n\Z)^\times \mid a^{2^r d} \equiv -1 \pmod{n} \}.
\]

\begin{lemma}
\label{lem:Cr-coset}
Pour tout \(r \ge 0\), soit \(C_r\) est vide, soit \(C_r\) est une classe
latérale de \(H_r\). En particulier, si \(C_r\) est non vide, on a
\(|C_r| = |H_r|\).
\end{lemma}

\begin{proof}
Si \(C_r\) est vide il n'y a rien à prouver. Sinon, soit \(b \in C_r\) un
élément fixé. On vérifie alors que
\[
  C_r = b H_r = \{ b h \mid h \in H_r \}.
\]
En effet, si \(h \in H_r\), alors
\[
  (b h)^{2^r d} \equiv b^{2^r d} h^{2^r d} \equiv (-1)\cdot 1 \equiv -1 \pmod{n},
\]
donc \(b h \in C_r\). Réciproquement, si \(a \in C_r\), on peut écrire
\(a = b h\) avec \(h = b^{-1} a\), et
\[
  h^{2^r d} \equiv b^{-2^r d} a^{2^r d} \equiv (-1)^{-1} \cdot (-1) \equiv 1
  \pmod{n},
\]
donc \(h \in H_r\). Ainsi \(C_r = b H_r\), donc \(|C_r| = |H_r|\).
\end{proof}

\begin{lemma}
\label{lem:Cr-disjoints}
Pour \(r \ne r'\), les ensembles \(C_r\) et \(C_{r'}\) sont disjoints. De plus,
pour tout \(r\), on a \(H_r \cap C_r = \varnothing\).
\end{lemma}

\begin{proof}
Si \(a \in H_r \cap C_r\), alors on aurait à la fois \(a^{2^r d} \equiv 1\) et
\(a^{2^r d} \equiv -1\), ce qui est impossible. Donc \(H_r \cap C_r =
\varnothing\).

Pour la disjonction des \(C_r\), supposons qu'il existe \(a\) dans
\(C_r \cap C_{r'}\) avec \(r < r'\). Alors
\[
  a^{2^r d} \equiv -1 \pmod{n}
  \quad\text{et}\quad
  a^{2^{r'} d} = \bigl(a^{2^r d}\bigr)^{2^{r'-r}}
  \equiv (-1)^{2^{r'-r}} \equiv 1 \pmod{n}.
\]
Donc \(a \in H_{r'}\), ce qui contredit \(a \in C_{r'}\). Ainsi
\(C_r \cap C_{r'} = \varnothing\) si \(r \ne r'\).
\end{proof}

Avec ces notations, la définition des menteurs se réécrit :

\begin{proposition}
\label{prop:decomp-Ln}
L'ensemble des menteurs s'écrit
\[
  L(n) = H_0 \;\cup\; \bigcup_{r=0}^{s-1} C_r,
\]
union disjointe.
\end{proposition}

\begin{proof}
Par la définition~\ref{def:MR-temoin-menteur}, un élément \(a\) est menteur si
et seulement si
\[
  a^d \equiv 1 \pmod{n}
  \quad\text{ou}\quad
  \exists r \in \{0,\dots,s-1\},\ a^{2^r d} \equiv -1 \pmod{n},
\]
c'est-à-dire \(a \in H_0 \cup \bigcup_{r=0}^{s-1} C_r\). La disjonction vient du
lemme~\ref{lem:Cr-disjoints}.
\end{proof}

\subsection*{B.3. Exposant maximal pour l'apparition de $-1$}

Pour contrôler la taille de \(L(n)\), nous devons identifier le plus grand
niveau auquel $-1$ peut apparaître dans la suite~\eqref{eq:MR-suite}.

\begin{definition}
\label{def:i0}
Soit \(n\) un entier impair composé, non puissance d'un premier, et soit
\(n-1 = 2^s d\) avec \(d\) impair. On définit \(i_0\) comme le plus grand entier
\(i \in \{0,1,\dots,s-1\}\) tel qu'il existe \(a \in (\Z/n\Z)^\times\) vérifiant
\(a^{2^i d} \equiv -1 \pmod{n}\).

En d'autres termes,
\[
  i_0 = \max\{ i \in \{0,\dots,s-1\} \mid C_i \neq \varnothing \}.
\]
\end{definition}

\begin{lemma}
\label{lem:i0-existe}
L'entier \(i_0\) est bien défini et vérifie \(i_0 \ge 0\). De plus, pour tout
menteur \(a \in L(n)\), si \(a \in C_r\) pour un certain \(r\), alors
\(r \le i_0\).
\end{lemma}

\begin{proof}
Puisque \(d\) est impair, on a \((-1)^d \equiv -1 \pmod{n}\), donc \(-1 \in C_0\).
Ainsi \(C_0 \neq \varnothing\), donc l'ensemble des \(i\) tel que \(C_i \neq
\varnothing\) est non vide et majoré par \(s-1\), ce qui garantit l'existence
du maximum \(i_0\) avec \(i_0 \ge 0\).

Si \(a \in C_r\), alors par définition de \(i_0\) comme maximum, on a
nécessairement \(r \le i_0\).
\end{proof}

\subsection*{B.4. Sous-groupes locaux et morphisme de signes}

Écrivons la décomposition de \(n\) en facteurs premiers (\ref{lem:thm-fond-arith}) :
\[
  n = \prod_{j=1}^r p_j^{e_j}, \qquad r \ge 2,
\]
où les \(p_j\) sont des nombres premiers impairs distincts. Par le théorème
des restes chinois, on a un isomorphisme
\[
  (\Z/n\Z)^\times \simeq \prod_{j=1}^r (\Z/p_j^{e_j}\Z)^\times.
\]

Pour chaque \(j\), le groupe \((\Z/p_j^{e_j}\Z)^\times\) est cyclique d'ordre
\(\varphi(p_j^{e_j}) = (p_j-1)p_j^{e_j-1}\). Notons
\[
  \varphi(p_j^{e_j}) = 2^{s_j} m_j,\qquad s_j \ge 1,\ m_j\ \text{impair}.
\]

\begin{definition}[Sous-groupe \(H\)]
\label{def:H}
On définit le sous-groupe \(H\) de \((\Z/n\Z)^\times\) par
\[
  H = \{ a \in (\Z/n\Z)^\times \mid \forall j,\ a^{2^{i_0} d} \equiv \pm 1 \pmod{p_j^{e_j}} \}.
\]
\end{definition}

\begin{lemma}
\label{lem:H-sous-groupe}
L'ensemble \(H\) est un sous-groupe de \((\Z/n\Z)^\times\).
\end{lemma}

\begin{proof}
Soient \(a,b \in H\). Pour chaque \(j\), on a
\(a^{2^{i_0} d} \equiv \varepsilon_j \pmod{p_j^{e_j}}\) et
\(b^{2^{i_0} d} \equiv \varepsilon_j' \pmod{p_j^{e_j}}\) avec
\(\varepsilon_j, \varepsilon_j' \in \{\pm 1\}\). Alors
\((ab)^{2^{i_0} d} \equiv \varepsilon_j \varepsilon_j' \in \{\pm 1\}\).
De même, \((a^{-1})^{2^{i_0} d} \equiv \varepsilon_j^{-1} = \varepsilon_j\).
Enfin, \(1 \in H\). Donc \(H\) est un sous-groupe.
\end{proof}

\begin{definition}[Morphisme de signes]
\label{def:psi}
On définit l'homomorphisme \(\psi : H \to \{\pm 1\}^r\) par
\[
  \psi(a) = \bigl( \varepsilon_1(a), \dots, \varepsilon_r(a) \bigr),
\]
où \(\varepsilon_j(a)\) est l'unique élément de \(\{\pm 1\}\) tel que
\(a^{2^{i_0} d} \equiv \varepsilon_j(a) \pmod{p_j^{e_j}}\).
\end{definition}

\begin{lemma}
\label{lem:psi-surjectif}
L'homomorphisme \(\psi\) est surjectif.
\end{lemma}

\begin{proof}
Il suffit de montrer que pour chaque \(j\), il existe un élément \(a^{(j)} \in H\)
tel que \(\psi(a^{(j)})\) ait un \(-1\) en position \(j\) et des \(+1\) ailleurs.
Par symétrie, montrons-le pour \(j=1\).

Par définition de \(i_0\), il existe \(b \in (\Z/n\Z)^\times\) tel que
\(b^{2^{i_0} d} \equiv -1 \pmod{n}\). En particulier,
\(b^{2^{i_0} d} \equiv -1 \pmod{p_1^{e_1}}\). Par le théorème des restes
chinois, on peut construire \(a^{(1)}\) tel que
\[
  a^{(1)} \equiv b \pmod{p_1^{e_1}},\qquad
  a^{(1)} \equiv 1 \pmod{p_j^{e_j}}\ (j \ge 2).
\]
Alors \(a^{(1)} \in H\) et \(\psi(a^{(1)}) = (-1, 1, \dots, 1)\).

En prenant des produits de tels éléments, on engendre tous les vecteurs de
\(\{\pm 1\}^r\). Ainsi \(\psi\) est surjectif.
\end{proof}

Le noyau de \(\psi\) est
\[
  \ker(\psi) = \{ a \in H \mid a^{2^{i_0} d} \equiv 1 \pmod{p_j^{e_j}} \ \forall j \}
             = \{ a \in H \mid a^{2^{i_0} d} \equiv 1 \pmod{n} \}.
\]
Notons \(K = \ker(\psi)\). Par le premier théorème d'isomorphisme,
\(H/K \simeq \{\pm 1\}^r\), donc
\[
  |H| = |K| \cdot 2^r.
\]

\subsection*{B.5. Sous-groupe \(S\) contenant les menteurs}

\begin{definition}[Sous-groupe \(S\)]
\label{def:S}
On définit le sous-groupe \(S\) de \(H\) par
\[
  S = \{ a \in (\Z/n\Z)^\times \mid a^{2^{i_0} d} \equiv \pm 1 \pmod{n} \}.
\]
\end{definition}

\begin{lemma}
\label{lem:S-sous-groupe}
L'ensemble \(S\) est un sous-groupe de \(H\) (donc de \((\Z/n\Z)^\times\)).
\end{lemma}

\begin{proof}
Si \(a,b \in S\), alors \(a^{2^{i_0} d} \equiv \varepsilon\) et
\(b^{2^{i_0} d} \equiv \varepsilon'\) avec \(\varepsilon, \varepsilon' \in \{\pm 1\}\).
Alors \((ab)^{2^{i_0} d} \equiv \varepsilon \varepsilon' \in \{\pm 1\}\), et
\((a^{-1})^{2^{i_0} d} \equiv \varepsilon^{-1} = \varepsilon\). De plus,
\(1 \in S\). Donc \(S\) est un sous-groupe.
\end{proof}

\begin{lemma}
\label{lem:L-in-S}
On a l'inclusion \(L(n) \subseteq S\).
\end{lemma}

\begin{proof}
Soit \(a \in L(n)\). Deux cas se présentent.

\textit{Cas 1 :} \(a \in H_0\), i.e. \(a^d \equiv 1 \pmod{n}\). Alors pour tout
\(i \ge 0\), \(a^{2^i d} \equiv 1 \pmod{n}\), donc en particulier
\(a^{2^{i_0} d} \equiv 1\) et \(a \in S\).

\textit{Cas 2 :} \(a \in C_r\) pour un certain \(r \in \{0,\dots,s-1\}\).
Par le lemme~\ref{lem:i0-existe}, on a \(r \le i_0\). Si \(r = i_0\), alors
\(a^{2^{i_0} d} \equiv -1 \pmod{n}\) donc \(a \in S\). Si \(r < i_0\), alors
\[
  a^{2^{i_0} d} = (a^{2^r d})^{2^{i_0 - r}} \equiv (-1)^{2^{i_0 - r}} \equiv 1 \pmod{n},
\]
donc \(a \in S\).

Dans les deux cas, \(a \in S\).
\end{proof}

\begin{lemma}
\label{lem:psi-S}
L'image de \(S\) par \(\psi\) est exactement le sous-groupe
\[
  \psi(S) = \{ (1,\dots,1), (-1,\dots,-1) \} \subseteq \{\pm 1\}^r,
\]
qui est de cardinal \(2\).
\end{lemma}

\begin{proof}
Soit \(a \in S\). Par définition, \(a^{2^{i_0} d} \equiv \pm 1 \pmod{n}\).
Ainsi, modulo chaque \(p_j^{e_j}\), on a soit \(+1\) partout, soit \(-1\) partout.
Donc \(\psi(a)\) est soit \((1,\dots,1)\), soit \((-1,\dots,-1)\).

Réciproquement, l'élément \(1\) donne \((1,\dots,1)\). Pour obtenir
\((-1,\dots,-1)\), on prend l'élément \(b\) de la définition de \(i_0\), qui
vérifie \(b^{2^{i_0} d} \equiv -1 \pmod{n}\) et donc \(\psi(b) = (-1,\dots,-1)\).
\end{proof}

De \(\psi(S) \simeq S/K\) on déduit
\[
  |S| = |K| \cdot 2.
\]

\subsection*{B.6. Indices et fin de la preuve}

On rappelle les notations
\[
  G = (\Z/n\Z)^\times,\qquad H \subseteq G,\qquad S \subseteq H,\qquad K = \ker(\psi).
\]

\begin{lemma}
\label{lem:H-S-indice}
On a
\[
  H/K \simeq \{\pm1\}^r,\qquad
  \psi(S) = \{(1,\dots,1),(-1,\dots,-1)\}.
\]
En particulier,
\[
  [H : S] = 2^{r-1}.
\]
\end{lemma}

\begin{proof}
La surjectivité de \(\psi\) (lemme~\ref{lem:psi-surjectif}) donne
\(H/K \simeq \{\pm1\}^r\), donc \( |H| = |K| \cdot 2^r\).

Par le lemme~\ref{lem:psi-S}, l'image de \(S\) par \(\psi\) est exactement
\(\{(1,\dots,1),(-1,\dots,-1)\}\), de cardinal \(2\). La restriction
\(\psi_{\mid S} : S \to \psi(S)\) est surjective et son noyau est toujours
\(K\) (puisque \(K \subseteq S\)). Donc \(S/K \simeq \psi(S)\) et
\(|S| = |K| \cdot 2\). Par conséquent
\[
  [H : S] = \frac{|H|}{|S|}
           = \frac{|K| \cdot 2^r}{|K| \cdot 2}
           = 2^{r-1}.
\]
\end{proof}

On va maintenant montrer que \(S\) est un sous-groupe propre de \(G\), puis
comparer son indice à celui d'autres sous-groupes naturels.

\begin{lemma}[Propreté de \(S\)]
\label{lem:S-propre}
Le sous-groupe \(S\) est propre dans \(G = (\Z/n\Z)^\times\), i.e.\ \(S \neq G\).
\end{lemma}

\begin{proof}
Par définition de \(i_0\), il existe \(b \in G\) tel que
\[
  b^{2^{i_0} d} \equiv -1 \pmod{n}.
\]
Écrivons \(n = p_{j_0}^{e_{j_0}} n_0\) avec \(\gcd(p_{j_0},n_0)=1\) et \(n_0>1\)
(ceci est possible car \(n\) a au moins deux facteurs premiers distincts).

Considérons le système
\[
  a \equiv b \pmod{p_{j_0}^{e_{j_0}}},\qquad
  a \equiv 1 \pmod{n_0}.
\]
Par le théorème des restes chinois, il admet une solution \(a \in \Z/n\Z\),
et comme les résidus imposés sont premiers à leurs modules respectifs, on a
\(\gcd(a,n)=1\), donc \(a \in G\).

Alors
\[
  a^{2^{i_0} d} \equiv b^{2^{i_0} d} \equiv -1 \pmod{p_{j_0}^{e_{j_0}}}
\]
et
\[
  a^{2^{i_0} d} \equiv 1^{2^{i_0} d} \equiv 1 \pmod{n_0}.
\]
Ainsi, dans la décomposition chinoise, \(a^{2^{i_0} d}\) a une coordonnée
\(-1\) (sur \(p_{j_0}^{e_{j_0}}\)) et au moins une coordonnée \(+1\)
(sur un facteur de \(n_0\)). En particulier, \(a^{2^{i_0} d}\) n'est ni \(1\)
ni \(-1\) modulo \(n\). Donc
\[
  a^{2^{i_0} d} \not\equiv \pm 1 \pmod{n},
\]
ce qui signifie que \(a \notin S\). On a donc \(S \subsetneq G\).
\end{proof}

On introduit maintenant le sous-groupe des \og non-témoins de Fermat \fg{} :
\[
  F = \{ a \in G \mid a^{n-1} \equiv 1 \pmod{n} \}.
\]
C'est un sous-groupe de \(G\).

\begin{lemma}
\label{lem:chaines-sous-groupes}
On a les inclusions
\[
  G \supseteq F \supseteq H \supseteq S \supseteq L(n).
\]
De plus, tout \(a \in H\) et tout \(a \in S\) vérifient \(a^{n-1} \equiv 1 \pmod{n}\),
donc \(H \subseteq F\) et \(S \subseteq F\).
\end{lemma}

\begin{proof}
L'inclusion \(L(n) \subseteq S\) est le lemme~\ref{lem:L-in-S}.

Soit \(a \in H\). Par définition, pour chaque \(j\),
\(a^{2^{i_0} d} \equiv \pm 1 \pmod{p_j^{e_j}}\). Donc
\(a^{2^{i_0+1} d} \equiv 1 \pmod{p_j^{e_j}}\) pour tout \(j\), et comme
\(2^{i_0+1} d \mid 2^s d = n-1\), on obtient
\(a^{n-1} \equiv 1 \pmod{p_j^{e_j}}\) pour tout \(j\), donc \(a^{n-1} \equiv 1 \pmod{n}\).
Ainsi \(a \in F\), ce qui montre \(H \subseteq F\).

De même, si \(a \in S\), on a \(a^{2^{i_0} d} \equiv \pm 1 \pmod{n}\), donc
\(a^{2^{i_0+1} d} \equiv 1 \pmod{n}\) et, par divisibilité, \(a^{n-1} \equiv 1 \pmod{n}\).
Donc \(S \subseteq F\). Les autres inclusions sont évidentes.
\end{proof}

\begin{lemma}
\label{lem:Fn-propre}
Si \(n\) n'est pas un nombre de Carmichael, le sous-groupe \(F\) est propre
dans \(G\) et contient strictement \(S\). En particulier,
\[
  [G : F] \ge 2, \qquad [F : S] \ge 2.
\]
\end{lemma}

\begin{proof}
Par définition, \(n\) est un nombre de Carmichael si et seulement si
\[
  a^{n-1} \equiv 1 \pmod{n} \quad\text{pour tout } a \in G.
\]
Donc si \(n\) n'est pas de Carmichael, il existe un \(a_0 \in G\) tel que
\(a_0^{n-1} \not\equiv 1 \pmod{n}\). Cet élément n'appartient pas à \(F\),
et comme \(F\) est un sous-groupe de \(G\), cela implique \(F \neq G\),
donc \([G : F] \ge 2\).

Pour voir que \(S\) est strictement contenu dans \(F\), utilisons l'élément
\(a\) construit dans la preuve du lemme~\ref{lem:S-propre} : on a
\(a^{2^{i_0} d} \not\equiv \pm 1 \pmod{n}\), donc \(a \notin S\). En revanche,
\(a^{2^{i_0+1} d} \equiv 1 \pmod{n}\), et comme \(2^{i_0+1} d \mid n-1\),
on obtient \(a^{n-1} \equiv 1 \pmod{n}\), donc \(a \in F \setminus S\).
Ainsi \(S \subsetneq F\) et \([F : S] \ge 2\).
\end{proof}

\begin{lemma}
\label{lem:carmichael-r>=3}
Si \(n\) est un nombre de Carmichael impair, alors \(n\) possède au moins
trois facteurs premiers distincts, i.e.\ \(r \ge 3\).
\end{lemma}

\begin{proof}
C'est une conséquence du critère de Korselt : un entier composé impair
\(n\) est de Carmichael si et seulement s'il est sans facteur carré
(\(p^2 \nmid n\) pour tout premier \(p\)) et si, pour tout premier \(p \mid n\),
on a \(p-1 \mid n-1\). En particulier, un nombre de Carmichael ne peut pas
être le produit de seulement deux nombres premiers, d'où \(r \ge 3\).
\end{proof}

\begin{corollary}
\label{cor:indice-G-S}
On a toujours
\[
  [G : S] \ge 4.
\]
\end{corollary}

\begin{proof}
On distingue deux cas.

\medskip\noindent
\emph{Premier cas : \(n\) n'est pas un nombre de Carmichael.}
Par le lemme~\ref{lem:Fn-propre}, on a \([G : F] \ge 2\) et \([F : S] \ge 2\).
Comme \(F\) et \(S\) sont des sous-groupes de \(G\),
\[
  [G : S] = [G : F] \cdot [F : S] \ge 2 \cdot 2 = 4.
\]

\medskip\noindent
\emph{Second cas : \(n\) est un nombre de Carmichael.}
Par le lemme~\ref{lem:carmichael-r>=3}, on a \(r \ge 3\). Le lemme~\ref{lem:H-S-indice}
donne
\[
  [H : S] = 2^{r-1} \ge 2^{3-1} = 4.
\]
Comme \(H\) est un sous-groupe de \(G\),
\[
  [G : S] = [G : H] \cdot [H : S] \ge [H : S] \ge 4,
\]
puisque \([G : H] \ge 1\).

Dans tous les cas, on a bien \([G : S] \ge 4\).
\end{proof}

\begin{corollary}
\label{cor:borne-Ln}
On a
\[
  |L(n)| \le \frac{\varphi(n)}{4}.
\]
\end{corollary}

\begin{proof}
Par le lemme~\ref{lem:L-in-S}, on a \(L(n) \subseteq S\).
Comme \(S\) est un sous-groupe de \(G = (\Z/n\Z)^\times\), on a
\[
  |S| = \frac{\varphi(n)}{[G : S]}.
\]
Le corollaire~\ref{cor:indice-G-S} donne \([G : S] \ge 4\), donc
\[
  |L(n)| \le |S| \le \frac{\varphi(n)}{4},
\]
ce qui est exactement l'énoncé du théorème~\ref{thm:MR-borne}.
\end{proof}

\subsection*{B.7. Commentaires}

La démonstration ci-dessus établit le théorème~\ref{thm:MR-borne} de manière
rigoureuse, en suivant la stratégie de Conrad :
\begin{itemize}
  \item définition de l'exposant maximal \(i_0\) pour lequel \(-1\) apparaît
    globalement dans la suite~\eqref{eq:MR-suite},
  \item introduction du sous-groupe \(H\) des éléments qui sont \(\pm 1\)
    modulo chaque facteur premier à l'exposant \(2^{i_0} d\),
  \item construction du morphisme de signes \(\psi : H \to \{\pm 1\}^r\),
  \item étude du sous-groupe \(S\) (contenant les menteurs) et calcul de
    son indice en distinguant le cas Carmichael/non-Carmichael.
\end{itemize}

\begin{remark}[Cas RSA]
Pour un module RSA \(n = pq\) (produit de deux nombres premiers impairs distincts),
on a \(r = 2\). Dans ce cas, la preuve montre que \([G : S] \ge 4\) et
\(|L(n)| \le \varphi(n)/4\). Dans beaucoup de situations \og génériques \fg{}, on a même
\([G : S] = 4\), ce qui montre que la borne \(1/4\) est essentiellement optimale
pour cette classe d'entiers.
\end{remark}

\begin{remark}[Généralisation]
Si \(n\) possède plus de deux facteurs
premiers distincts (\(r \ge 3\)), le lemme~\ref{lem:H-S-indice} donne
\([H : S] = 2^{r-1} \ge 4\), et on obtient une borne plus forte :
\(|L(n)| \le \varphi(n)/2^r \le \varphi(n)/8\).
Pour l'application cryptographique usuelle (RSA), la borne \(1/4\) reste
toutefois la référence standard.
\end{remark}





\newpage

\addcontentsline{toc}{section}{Références}
\begin{thebibliography}{9}

\bibitem{git-hub}
Philippe Rackette. (2025).
\textit{K of N Tails - Documentation and Implementation}. \\
\url{https://github.com/philipperackette/kofn-tails}.

\bibitem{shamir1979share}
Shamir, A. (1979). 
\textit{How to share a secret}. 
Communications of the ACM, 22(11), 612-613.

\bibitem{rfc2104}
Krawczyk, H., Bellare, M., \& Canetti, R. (1997).
\textit{HMAC: Keyed-Hashing for Message Authentication}.
RFC 2104.

\bibitem{rfc5869}
Krawczyk, H., \& Eronen, P. (2010).
\textit{HMAC-based Extract-and-Expand Key Derivation Function (HKDF)}.
RFC 5869.

\bibitem{rfc8018}
Moriarty, K., Kaliski, B., \& Rusch, A. (2017).
\textit{PKCS \#5: Password-Based Cryptography Specification Version 2.1}.
RFC 8018.

\bibitem{rfc8032}
Josefsson, S., \& Liusvaara, I. (2017).
\textit{Edwards-Curve Digital Signature Algorithm (EdDSA)}.
RFC 8032.

\bibitem{rfc8017}
Moriarty, K., Kaliski, B., Jonsson, J., \& Rusch, A. (2016).
\textit{PKCS \#1: RSA Cryptography Specifications Version 2.2}.
RFC 8017.

\bibitem{fips197}
National Institute of Standards and Technology. (2001).
\textit{Advanced Encryption Standard (AES)}.
FIPS PUB 197.

\bibitem{fips180-4}
National Institute of Standards and Technology. (2015).
\textit{Secure Hash Standard (SHS)}.
FIPS PUB 180-4.

\bibitem{nist-sp800-38d}
Dworkin, M. (2007).
\textit{Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC}.
NIST Special Publication 800-38D.


\bibitem{Conrad-MR}
K.~Conrad,
\emph{The Miller--Rabin primality test},\\
\url{https://kconrad.math.uconn.edu/blurbs/ugradnumthy/millerrabin.pdf}.

\bibitem{rackette-pgp}
Philippe Rackette. (2020).
\textit{Clé publique OpenPGP personnelle}.\\
Clé RSA 4096 bits (créée le 23 janvier 2020, expiration le 31 août 2050).\\
\textsc{Empreinte} (fingerprint) :\\
\hspace*{1em}\texttt{BC69 21A8 5B8D DBB5 F3A6 EB81 9055 4E6A 6924 F3C7}.\\
\textsc{Identifiants} (UID) :\\
\hspace*{1em}\texttt{philippe.rackette@ac-strasbourg.fr}\\
\hspace*{1em}\texttt{philippe.rackette@cse-strasbourg.com}.\\
Disponible sur le serveur de clés OpenPGP :\\
\hspace*{1em}\url{https://keys.openpgp.org/search?q=philippe.rackette%40ac-strasbourg.fr}


\end{thebibliography}

\end{document}