\documentclass[12pt,a4paper]{article}

% ============================
% Encodage, langue, mise en page
% ============================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}

\usepackage{geometry}
\geometry{margin=2.5cm}

% ============================
% Maths et mise en forme
% ============================
\usepackage{amsmath,amssymb,amsthm,mathtools}
\usepackage{bm}
\usepackage{mathrsfs}
\usepackage{enumitem}
\usepackage{array}
\usepackage{booktabs}
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning}
\usepackage{hyperref}
\usepackage{url}

% Supprimer l'indentation de tous les paragraphes
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.5em}  % Espacement entre paragraphes

% ============================
% Environnements mathématiques
% ============================
\numberwithin{equation}{section}

% Style pour les environnements (sans italique)
\theoremstyle{definition}
\newtheorem{theorem}{Théorème}[section]
\newtheorem{lemma}[theorem]{Lemme}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollaire}
\newtheorem{definition}[theorem]{Définition}
\newtheorem{propriete}[theorem]{Propriété}
\newtheorem{remark}[theorem]{Remarque}
\newtheorem{example}[theorem]{Exemple}

% ============================
% Raccourcis usuels
% ============================
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\F}{\mathbb{F}}

\newcommand{\Ell}{\mathscr{E}}
\newcommand{\bin}{\{0,1\}}
\newcommand{\concat}{\,\Vert\,}
\newcommand{\xor}{\oplus}

% Macros pour éviter les problèmes de crochets dans les arguments optionnels
\newcommand{\FdeuxX}{\F_2[X]}  % F_2[X]
\newcommand{\FdeuxQuot}{\F_2[X]/(X^2+X+1)}  % F_2[X]/(X^2+X+1)
\newcommand{\Kpolys}{\mathbb{K}[X]}  % Anneau de polynômes

\DeclareMathOperator{\HKDF}{HKDF}
\DeclareMathOperator{\PBKDF}{PBKDF2}
\DeclareMathOperator{\HMAC}{HMAC}
\DeclareMathOperator{\AESGCM}{AES-GCM}
\DeclareMathOperator{\RSAOAEP}{RSA-OAEP}
\DeclareMathOperator{\MGF}{MGF1}

% ============================
% Métadonnées
% ============================
\title{Schéma $k$-sur-$n$ sous Tails :\\
formulation mathématique rigoureuse}
\author{BC69 21A8 5B8D DBB5 F3A6 EB81 9055 4E6A 6924 F3C7}
\date{\centering\today}

% ============================
\begin{document}
\maketitle

\begin{abstract}
Ce texte formalise, dans un cadre entièrement mathématique, le schéma
$k$-sur-$n$ mis en \oe uvre par la procédure opérationnelle sous Tails
pour la gestion d'un secret maître, telle qu'elle est décrite dans le
document HTML \texttt{procedure\_kofn\_tails\_v1.html} dont l'empreinte
SHA-256 est
\[
  \texttt{ed223dd055108b0c08cd6d7b3011962d5bdc5f92dd38760c5c6a202982fcde84}.
\]
Le protocole repose sur les briques cryptographiques suivantes :
\begin{itemize}[leftmargin=2em]
  \item le partage de secret de Shamir \cite{shamir1979share} sur un corps fini pour répartir un secret maître $S$ selon un seuil $k$-sur-$n$ ;
  \item la dérivation de clés symétriques à partir de $S$ et des mots de passe par \textbf{HKDF} (\textbf{HMAC-based Key Derivation Function}) \cite{rfc5869} et \textbf{PBKDF2} (\textbf{Password-Based Key Derivation Function 2}) \cite{rfc8018} ;
  \item une clé de signature \textbf{Ed25519} (Edwards-curve Digital Signature Algorithm) \cite{rfc8032} dérivée de $S$ (schéma de signature à base de courbe elliptique) ;
  \item un chiffrement hybride \textbf{RSA-4096} / \textbf{AES-256-GCM} (\textbf{Advanced Encryption Standard} en mode \textbf{Galois/Counter Mode}) \cite{rfc8017, fips197, nist-sp800-38d} pour les fichiers destinés aux membres du groupe $k$-sur-$n$, la clé RSA privée étant elle-même chiffrée par AES-256-GCM à partir de $S$ ;
\end{itemize}

Nous détaillons, pour chaque type d'objet manipulé, les garanties effectives
en termes de confidentialité, d'intégrité et d'authenticité :
\begin{itemize}[leftmargin=2em]
  \item \textbf{Parts de secret} : confidentialité et intégrité assurées par AES-GCM avec une clé dérivée du mot de passe du porteur (PBKDF2) ;
  \item \textbf{Signatures de fichiers} : intégrité et authenticité cryptographiques assurées par Ed25519 à partir de la clé dérivée de $S$ ;
  \item \textbf{Fichiers chiffrés hybrides RSA--AES} : confidentialité et intégrité du contenu assurées par AES-GCM ; l'authenticité de la \emph{source} n'est en revanche pas garantie en l'absence de signature dédiée ;
  \item \textbf{Clés publiques} : leur authenticité doit être vérifiée par des canaux hors-bande (vérification humaine, échange préalable sur canal sécurisé, etc.).
\end{itemize}

Les objets sont définis dans leur structure algébrique naturelle (corps finis,
groupes, espaces de clés), puis mis en correspondance explicite avec les
formats de fichiers et les scripts décrits dans \texttt{procedure\_kofn\_tails\_v1.html}, de façon à assurer une traçabilité complète entre le modèle
mathématique et la mise en \oe uvre opérationnelle. Dans toute la suite,
l'expression \og procédure Tails\fg{} désigne précisément ce document HTML
identifié par l'empreinte SHA-256 ci-dessus.
\end{abstract}

\newpage

\tableofcontents

%=========================================================

%=========================================================
\section*{Table des notations}
\addcontentsline{toc}{section}{Table des notations}

\begin{center}
\footnotesize
\renewcommand{\arraystretch}{1.1}
\begin{tabular}{>{$}l<{$} p{0.8\textwidth}}
\toprule
\bin^t & Mots binaires de longueur $t$ \\
\bin^* & Mots binaires de longueur finie (union sur $t\ge 0$) \\
\lVert x\rVert & Longueur en bits de $x\in\bin^*$ \\
x\concat y & Concaténation de mots binaires \\
x\xor y & XOR bit-à-bit ($x,y$ de même longueur) \\
\mathrm{val}_{\mathrm{be}}(b) & Encodage big-endian $b\in\bin^t \to \{0,\dots,2^t-1\}$ \\
\mathrm{val}_{\mathrm{le}}(b) & Encodage little-endian $b\in\bin^t \to \{0,\dots,2^t-1\}$ \\
S \in \bin^{256} & Secret maître (32 octets) \\
s_0 & Entier $\mathrm{val}_{\mathrm{be}}(S)\in\{0,\dots,2^{256}-1\}$ \\
P = 2^{521} - 1 & Premier de Mersenne, cardinal de $\F_P$ \\
\F_P & Corps fini à $P$ éléments \\
\F_P[X] & Polynômes à coefficients dans $\F_P$ \\
\mathcal{P}_{<k} & Polynômes de degré $<k$ dans $\F_P[X]$ \\
(x_i,y_i) & Part de Shamir du participant $i$ ($\in\F_P^2$) \\
q = 2^{255} - 19 & Cardinal du corps de base de Ed25519 \\
E(\F_q) & Groupe des points de la courbe elliptique \\
B \in E(\F_q) & Point de base d'ordre premier $\ell$ \\
\ell & Ordre premier de $B$ ($\approx 2^{252}$) \\
\Z_\ell & Anneau $\{0,\dots,\ell-1\}$ modulo $\ell$ \\
a \in \Z_\ell & Clé privée Ed25519 \\
A = aB & Clé publique Ed25519 \\
(n,e,d) & Paramètres RSA : module, exposants public/privé \\
h & Fonction de hachage $h:\bin^* \to \bin^d$ \\
\HMAC_h & MAC HMAC basé sur $h$ \\
\HKDF_h & Dérivation de clé HKDF (RFC 5869) \\
\PBKDF_h & Dérivation par mot de passe (PBKDF2, RFC 8018) \\
\MGF_h & Génération de masque MGF1 (RFC 8017) \\
\RSAOAEP & RSA avec rembourrage OAEP (RFC 8017) \\
\AESGCM_K & AES-GCM sous clé symétrique $K$ \\
\mathrm{IKM} & Input Keying Material (ici $S$) \\
\mathrm{saltEd} & Sel HKDF constant pour $K_{\mathrm{Ed}}$ \\
W & Sel HKDF aléatoire par cérémonie pour $K_{\mathrm{RSA}}$ \\
\mathrm{info}_{\mathrm{Ed}} & Contexte HKDF pour Ed25519 \\
\mathrm{info}_{\mathrm{RSA}} & Contexte HKDF pour RSA \\
P_i & Mot de passe du participant $i$ \\
S_i & Sel PBKDF2 individuel \\
K_i & Clé symétrique pour chiffrer la part $i$ \\
K_{\mathrm{Ed}} & Graine Ed25519 dérivée de $S$ \\
K_{\mathrm{RSA}} & Clé pour chiffrer la clé privée RSA \\
K_{\mathrm{AES}} & Clé de session AES \\
N,\,N_i & Nonces AES-GCM \\
\perp & Symbole d'échec/rejet \\
\bottomrule
\end{tabular}
\end{center}

\newpage

%=========================================================



%=========================================================
\section{Cadre algébrique de base}

\subsection*{Préambule et motivation}

Cette section rassemble les notions d'algèbre abstraite et d'arithmétique modulaire utilisées dans la suite du document. Nous suivons une progression logique : 
\begin{itemize}
  \item L'\textbf{arithmétique modulaire} (entiers, pgcd, inverses) définit le socle concret pour $\Z/n\Z$ et prépare $\F_p = \Z/p\Z$.
  \item Les \textbf{théorèmes d'isomorphisme} généralisent ces structures, s'appuyant sur les exemples concrets.
  \item Les \textbf{corps finis et extensions} construisent sur les deux précédents (utilisation des isomorphismes pour l'unicité de $\F_p$).
  \item Les \textbf{mots binaires et encodages} formalisent la conversion vers les représentations cryptographiques.
\end{itemize}

\subsection{Arithmétique modulaire et groupe multiplicatif $(\Z/n\Z)^\times$}

\begin{definition}[Anneau $\Z/n\Z$ et groupe multiplicatif $(\Z/n\Z)^\times$]
Soit $n \in \N^*$. L'anneau $\Z/n\Z$ est l'ensemble $\{0,1,\dots,n-1\}$ muni des opérations $+$ et $\cdot$ modulo $n$.

Le groupe multiplicatif $(\Z/n\Z)^\times$ est l'ensemble des éléments inversibles de $\Z/n\Z$ :
\[
(\Z/n\Z)^\times = \{a \in \{0,1,\dots,n-1\} \mid \gcd(a,n)=1\}.
\]
\end{definition}

\begin{remark}[Inversibilité modulo $n$]
L'élément $a \in \Z/n\Z$ est inversible si et seulement si $\gcd(a,n)=1$. En effet, si $\gcd(a,n)=1$, alors par l'identité de Bézout, il existe $u,v$ tels que $au + nv = 1$, donc $au \equiv 1 \pmod{n}$. Réciproquement, si $a$ est inversible, il existe $b$ tel que $ab \equiv 1 \pmod{n}$, donc $ab  -kn = 1$ pour un certain $k$, ce qui implique que tout diviseur commun à $a$ et $n$ divise 1, donc $\gcd(a,n)=1$.
\end{remark}

\begin{definition}[Indicatrice d'Euler]
L'indicatrice d'Euler $\varphi(n)$ est définie pour tout entier $n \geq 1$ comme le nombre d'entiers compris entre $1$ et $n$ qui sont premiers avec $n$ :
\[
\varphi(n) = \#\{k \in \{1, 2, \dots, n\} \mid \gcd(k, n) = 1\}
\]
\end{definition}

\begin{proposition}[Valeur de $\varphi(n)$ pour $n = pq$]
\label{prop:phi-pq}
Si $p$ et $q$ sont deux nombres premiers distincts et $n = pq$, alors :
\[
\varphi(n) = (p-1)(q-1)
\]
\end{proposition}

\begin{proof}
Parmi les $n = pq$ entiers de $1$ à $n$, les entiers qui ne sont pas premiers avec $n$ sont :
\begin{itemize}
\item Les multiples de $p$ : $p, 2p, 3p, \dots, qp$ → il y en a $q$
\item Les multiples de $q$ : $q, 2q, 3q, \dots, pq$ → il y en a $p$
\end{itemize}
L'entier $pq$ a été compté deux fois. Par le principe d'inclusion-exclusion :
\[
\varphi(n) = n - q - p + 1 = pq - p - q + 1 = (p-1)(q-1)
\]
\end{proof}

\begin{theorem}[Théorème de Lagrange pour les groupes finis]
\label{thm:lagrange-groupes}
Soit $G$ un groupe fini et $H$ un sous-groupe de $G$. Alors l'ordre de $H$ divise l'ordre de $G$ :
\[
|H| \ \big|\ |G|
\]
En particulier, pour tout $g \in G$, l'ordre de $g$ divise $|G|$.
\end{theorem}

\begin{proof}
Considérons la relation d'équivalence sur $G$ définie par :
\[
x \sim y \quad \Leftrightarrow \quad x^{-1}y \in H
\]
Les classes d'équivalence sont les \emph{classes à gauche} $gH = \{gh : h \in H\}$. 

Pour montrer que toutes les classes à gauche ont le même cardinal que $H$, considérons l'application $f : H \to gH$ définie par $f(h) = gh$. Cette application est :
\begin{itemize}
  \item \textbf{Surjective} : Par définition de $gH$
  \item \textbf{Injective} : Si $gh_1 = gh_2$, alors en multipliant à gauche par $g^{-1}$, on obtient $h_1 = h_2$
\end{itemize}
Ainsi, $|gH| = |H|$ pour tout $g \in G$.

Puisque les classes à gauche forment une partition de $G$, on a :
\[
|G| = \sum_{\text{classes}} |gH| = (\text{nombre de classes}) \times |H|
\]
Donc $|H|$ divise $|G|$.

Pour la deuxième partie, si $g \in G$, considérons le sous-groupe engendré par $g$, noté $\langle g \rangle = \{g^n : n \in \Z\}$. 

Montrons que l'ordre de $\langle g \rangle$ est égal à l'ordre de $g$. Soit $d$ l'ordre de $g$, c'est-à-dire le plus petit entier positif tel que $g^d = e$. Alors les éléments $g^0 = e, g^1, g^2, \dots, g^{d-1}$ sont tous distincts. En effet, si $g^i = g^j$ avec $0 \le i < j < d$, alors $g^{j-i} = e$ avec $0 < j-i < d$, ce qui contredit la minimalité de $d$.

De plus, pour tout $n \in \Z$, par division euclidienne, on peut écrire $n = qd + r$ avec $0 \le r < d$, et donc $g^n = g^{qd+r} = (g^d)^q \cdot g^r = e^q \cdot g^r = g^r$. Ainsi, tout élément de $\langle g \rangle$ est l'un des $g^r$ avec $0 \le r < d$.

Donc $\langle g \rangle = \{e, g, g^2, \dots, g^{d-1}\}$ a exactement $d$ éléments, ce qui signifie que l'ordre du sous-groupe $\langle g \rangle$ est égal à l'ordre de $g$.

Par la première partie du théorème, l'ordre de $\langle g \rangle$ divise $|G|$, donc l'ordre de $g$ divise $|G|$.
\end{proof}

\begin{theorem}[Théorème d'Euler]
\label{thm:euler}
Si $a$ et $n$ sont premiers entre eux, alors :
\[
a^{\varphi(n)} \equiv 1 \pmod{n}
\]
\end{theorem}

\begin{proof}
L'ensemble $(\Z/n\Z)^\times$ est un groupe multiplicatif d'ordre $\varphi(n)$. Pour tout $a \in (\Z/n\Z)^\times$, par le théorème de Lagrange (Théorème~\ref{thm:lagrange-groupes}) appliqué au sous-groupe $\langle a \rangle$, l'ordre de $a$ divise $\varphi(n)$. Donc $a^{\varphi(n)} = 1$ dans $(\Z/n\Z)^\times$, c'est-à-dire $a^{\varphi(n)} \equiv 1 \pmod{n}$.
\end{proof}

\begin{theorem}[Petit théorème de Fermat]
\label{thm:fermat}
Si $p$ est premier et $a$ n'est pas divisible par $p$, alors :
\[
a^{p-1} \equiv 1 \pmod{p}
\]
\end{theorem}

\begin{proof}
C'est un cas particulier du théorème d'Euler, car pour $p$ premier, $\varphi(p) = p-1$.
\end{proof}

\begin{theorem}[Théorème de Gauss (lemme d'Euclide)]
\label{thm:gauss-div}
Soient $a, b, c$ des entiers. Si $a$ et $b$ sont premiers entre eux et $a$ divise $bc$, alors $a$ divise $c$.
\end{theorem}

\begin{proof}
Puisque $\gcd(a,b) = 1$, par l'identité de Bézout, il existe des entiers $u,v$ tels que :
\[
au + bv = 1
\]
Multiplions cette égalité par $c$ :
\[
auc + bvc = c
\]
Par hypothèse, $a$ divise $bc$, donc $a$ divise $bvc$. De plus, $a$ divise évidemment $auc$. Donc $a$ divise la somme $auc + bvc = c$.
\end{proof}

\begin{proposition}[Algorithme d'Euclide étendu et inverse modulaire]
\label{prop:euclide-etendu}
Soient $a,n\in\mathbb{Z}$ avec $\gcd(a,n)=1$. L'algorithme d'Euclide étendu calcule des entiers $u,v$ tels que
\[
au + nv = 1.
\]
En particulier, $u \bmod n$ est l'inverse de $a$ modulo $n$.
\end{proposition}

\begin{proof}[Algorithme d'Euclide étendu]
Soient $a \in \{1, 2, \dots, n-1\}$ et $n$ premier avec $a$.
\begin{enumerate}
  \item Initialiser : $r_0 \gets n$, $r_1 \gets a$, $u_0 \gets 0$, $u_1 \gets 1$.
  \item Tant que $r_1 \neq 0$ :
    \begin{enumerate}
      \item Calculer $q \gets \lfloor r_0 / r_1 \rfloor$ (division euclidienne).
      \item Mettre à jour : $r_2 \gets r_0 - q \cdot r_1$, $u_2 \gets u_0 - q \cdot u_1$.
      \item Décaler : $r_0 \gets r_1$, $r_1 \gets r_2$, $u_0 \gets u_1$, $u_1 \gets u_2$.
    \end{enumerate}
  \item Le pgcd est $r_0 = 1$, et l'inverse de $a$ modulo $n$ est $u_0 \bmod n$.
\end{enumerate}
\end{proof}

\begin{remark}[À retenir pour RSA]
Pour RSA, nous utiliserons :
\begin{itemize}
  \item Le théorème d'Euler (ou le petit théorème de Fermat) dans la preuve de correction (section~\ref{thm:rsa-correct}).
  \item L'algorithme d'Euclide étendu pour calculer $d = e^{-1} \bmod \varphi(n)$.

\end{itemize}
\end{remark}

\subsection{Théorèmes fondamentaux d'isomorphisme}

\begin{definition}[Homomorphisme de groupes]
Soient $(G,\cdot)$ et $(H,\ast)$ deux groupes. Une application $f: G \to H$ est un \emph{homomorphisme de groupes} si pour tous $g_1, g_2 \in G$ :
\[
f(g_1 \cdot g_2) = f(g_1) \ast f(g_2).
\]
Le \emph{noyau} de $f$ est $\ker(f) = \{g \in G \mid f(g) = e_H\}$.
\end{definition}

\begin{definition}[Homomorphisme d'anneaux]
Soient $(A,+_A,\cdot_A)$ et $(B,+_B,\cdot_B)$ deux anneaux. Une application $f: A \to B$ est un \emph{homomorphisme d'anneaux} si pour tous $a_1, a_2 \in A$ :
\begin{align*}
f(a_1 +_A a_2) &= f(a_1) +_B f(a_2) \\
f(a_1 \cdot_A a_2) &= f(a_1) \cdot_B f(a_2) \\
f(1_A) &= 1_B
\end{align*}
Le \emph{noyau} de $f$ est $\ker(f) = \{a \in A \mid f(a) = 0_B\}$.
\end{definition}

\begin{theorem}[Premier théorème d'isomorphisme pour les groupes]
\label{thm:iso-groupes}
Soit $f: G \to H$ un homomorphisme de groupes. Alors :
\begin{enumerate}
  \item $\ker(f)$ est un sous-groupe distingué de $G$
  \item $\mathrm{Im}(f)$ est un sous-groupe de $H$
  \item $G/\ker(f) \simeq \mathrm{Im}(f)$
\end{enumerate}
\end{theorem}

\begin{proof}
(1) et (2) sont des vérifications directes. Pour (3), définissons :
\[
\overline{f}: G/\ker(f) \to \mathrm{Im}(f),\quad g\ker(f) \mapsto f(g).
\]
Vérifions que $\overline{f}$ est bien définie : si $g_1\ker(f) = g_2\ker(f)$, alors $g_1^{-1}g_2 \in \ker(f)$, donc $f(g_1^{-1}g_2) = e_H$, d'où $f(g_1) = f(g_2)$. Ceci montre que $\overline{f}$ ne dépend pas du choix du représentant de la classe $g\ker(f)$, ce qui est possible car $\ker(f)$ est distingué.

Montrons que $\overline{f}$ est un homomorphisme : 
\[
\overline{f}((g_1\ker(f))(g_2\ker(f))) = \overline{f}(g_1g_2\ker(f)) = f(g_1g_2) = f(g_1)f(g_2) = \overline{f}(g_1\ker(f))\overline{f}(g_2\ker(f)).
\]

L'injectivité vient de : si $\overline{f}(g\ker(f)) = e_H$, alors $f(g) = e_H$, donc $g \in \ker(f)$, d'où $g\ker(f) = \ker(f)$ (classe de l'élément neutre).

La surjectivité est immédiate par définition de $\mathrm{Im}(f)$.

Ainsi $\overline{f}$ est un isomorphisme.
\end{proof}

\begin{definition}[Idéal d'un anneau]
Un sous-ensemble $I$ d'un anneau $A$ est un \emph{idéal} si :
\begin{enumerate}
  \item $(I, +)$ est un sous-groupe de $(A, +)$
  \item Pour tout $a \in A$ et tout $x \in I$, on a $a \cdot x \in I$ et $x \cdot a \in I$ (stabilité par multiplication par tout élément de l'anneau)
\end{enumerate}
\end{definition}

\begin{theorem}[Premier théorème d'isomorphisme pour les anneaux]
\label{thm:iso-anneaux}
Soit $f: A \to B$ un homomorphisme d'anneaux. Alors :
\begin{enumerate}
  \item $\ker(f)$ est un idéal de $A$
  \item $\mathrm{Im}(f)$ est un sous-anneau de $B$
  \item $A/\ker(f) \simeq \mathrm{Im}(f)$
\end{enumerate}
\end{theorem}

\begin{proof}
(1) Montrons que $\ker(f)$ est un idéal. Soient $x, y \in \ker(f)$. Alors $f(x - y) = f(x) - f(y) = 0_B - 0_B = 0_B$, donc $x - y \in \ker(f)$. Soit $a \in A$ et $x \in \ker(f)$. Alors $f(a \cdot x) = f(a) \cdot f(x) = f(a) \cdot 0_B = 0_B$, donc $a \cdot x \in \ker(f)$. De même, $x \cdot a \in \ker(f)$. Ainsi $\ker(f)$ est un idéal.

(2) Soient $b_1, b_2 \in \mathrm{Im}(f)$. Il existe $a_1, a_2 \in A$ tels que $f(a_1) = b_1$ et $f(a_2) = b_2$. Alors $b_1 - b_2 = f(a_1) - f(a_2) = f(a_1 - a_2) \in \mathrm{Im}(f)$ et $b_1 \cdot b_2 = f(a_1) \cdot f(a_2) = f(a_1 \cdot a_2) \in \mathrm{Im}(f)$. De plus, $1_B = f(1_A) \in \mathrm{Im}(f)$. Donc $\mathrm{Im}(f)$ est un sous-anneau de $B$.

(3) Définissons $\overline{f}: A/\ker(f) \to \mathrm{Im}(f)$ par $\overline{f}(a + \ker(f)) = f(a)$. Cette application est bien définie car si $a + \ker(f) = a' + \ker(f)$, alors $a - a' \in \ker(f)$, donc $f(a - a') = 0_B$, soit $f(a) = f(a')$. C'est un homomorphisme d'anneaux car :
\begin{align*}
\overline{f}((a + \ker(f)) + (b + \ker(f))) &= \overline{f}(a + b + \ker(f)) = f(a + b) = f(a) + f(b) \\
&= \overline{f}(a + \ker(f)) + \overline{f}(b + \ker(f)), \\
\overline{f}((a + \ker(f)) \cdot (b + \ker(f))) &= \overline{f}(a \cdot b + \ker(f)) = f(a \cdot b) = f(a) \cdot f(b) \\
&= \overline{f}(a + \ker(f)) \cdot \overline(f)(b + \ker(f)), \\
\overline{f}(1_A + \ker(f)) &= f(1_A) = 1_B.
\end{align*}
L'injectivité : si $\overline{f}(a + \ker(f)) = 0_B$, alors $f(a) = 0_B$, donc $a \in \ker(f)$, d'où $a + \ker(f) = 0_A + \ker(f)$. La surjectivité est évidente. Donc $\overline{f}$ est un isomorphisme.
\end{proof}

\begin{remark}[Utilisation en cryptographie]
Ces théorèmes justifient plusieurs isomorphismes fondamentaux :
\begin{itemize}
  \item $\Z/p\Z \simeq \F_p$ (corps premier) - essentiel pour RSA et Shamir
  \item $\F_2[X]/(m(X)) \simeq \F_{2^8}$ pour AES - représentation canonique du corps de Galois
  \item $\Z_\ell \simeq \langle B \rangle$ pour Ed25519 - isomorphisme entre scalaires et points du sous-groupe
\end{itemize}
Ils garantissent que différentes représentations d'une même structure algébrique sont équivalentes, ce qui permet de choisir la représentation la plus efficace pour l'implémentation.
\end{remark}

\subsection{Corps finis et extensions}

\begin{theorem}[Unicité du corps à $p$ éléments]
\label{thm:unicite-corps-premier}
Soit $p$ un nombre premier. Alors :
\begin{enumerate}
  \item $\F_p = \Z/p\Z$ est un corps à $p$ éléments.
  \item Tout corps $K$ de cardinal $p$ est isomorphe à $\F_p$.
  \item Cet isomorphisme est unique : si $\phi_1, \phi_2 : K \to \F_p$ sont deux isomorphismes, alors $\phi_1 = \phi_2$.
\end{enumerate}
\end{theorem}

\begin{proof}
(1) Puisque $p$ est premier, tout élément non nul de $\Z/p\Z$ est inversible modulo $p$, donc $\Z/p\Z$ est un corps.

(2) Soit $K$ un corps de cardinal $p$. Puisque $K$ est fini, sa caractéristique est un nombre premier. Comme $p \cdot 1_K = 0$ (d'après le théorème de Lagrange appliqué au groupe additif), la caractéristique divise $p$, donc est égale à $p$.

Considérons l'homomorphisme d'anneaux canonique :
\[
\iota : \Z \to K,\quad n \mapsto n \cdot 1_K
\]
Son noyau est un idéal de $\Z$, donc de la forme $m\Z$ avec $m \ge 0$. Puisque $\iota(p) = p \cdot 1_K = 0$, on a $p \in \ker\iota$, donc $m$ divise $p$. Comme $\iota$ n'est pas l'application nulle (car $\iota(1) = 1_K \neq 0$), on a $m = p$.

Ainsi $\ker\iota = p\Z$. Par le théorème fondamental d'isomorphisme (Théorème~\ref{thm:iso-anneaux}), on obtient un homomorphisme injectif :
\[
\overline{\iota} : \Z/p\Z \hookrightarrow K
\]
Puisque les deux ensembles ont le même cardinal fini $p$, $\overline{\iota}$ est un isomorphisme.

(3) Soient $\phi_1, \phi_2 : K \to \F_p$ deux isomorphismes. Alors $\psi = \phi_2^{-1} \circ \phi_1$ est un automorphisme de $K$. Pour tout $x \in K$, on a $p \cdot x = 0$, donc $K$ est un $\F_p$-espace vectoriel de dimension $1$. Tout automorphisme de $\F_p$-espaces vectoriels est une multiplication par un scalaire non nul $\lambda \in \F_p^*$. Mais comme $\psi(1) = 1$, on a $\lambda = 1$, donc $\psi = \mathrm{id}_K$, d'où $\phi_1 = \phi_2$.
\end{proof}

\begin{definition}[Corps fini premier]
Soit $p$ un nombre premier. On note
\[
  \F_p = \Z/p\Z
\]
le corps fini à $p$ éléments. Les opérations arithmétiques dans $\F_p$ sont effectuées modulo $p$. Plus précisément, pour $a, b \in \F_p$ :
\begin{itemize}
  \item $a + b = (a + b) \bmod p$
  \item $a \cdot b = (a \cdot b) \bmod p$
  \item L'inverse additif de $a$ est $p - a$ (modulo $p$)
  \item L'inverse multiplicatif de $a \neq 0$ est l'unique élément $a^{-1} \in \F_p$ tel que $a \cdot a^{-1} \equiv 1 \pmod{p}$
\end{itemize}
\end{definition}

\begin{example}[Corps $\F_5$]
Le corps $\F_5 = \{0,1,2,3,4\}$ avec les opérations modulo 5.

Tables d'addition et de multiplication :
\[
\begin{array}{c|ccccc}
+ & 0 & 1 & 2 & 3 & 4 \\ \hline
0 & 0 & 1 & 2 & 3 & 4 \\
1 & 1 & 2 & 3 & 4 & 0 \\
2 & 2 & 3 & 4 & 0 & 1 \\
3 & 3 & 4 & 0 & 1 & 2 \\
4 & 4 & 0 & 1 & 2 & 3
\end{array}
\qquad
\begin{array}{c|ccccc}
\times & 0 & 1 & 2 & 3 & 4 \\ \hline
0 & 0 & 0 & 0 & 0 & 0 \\
1 & 0 & 1 & 2 & 3 & 4 \\
2 & 0 & 2 & 4 & 1 & 3 \\
3 & 0 & 3 & 1 & 4 & 2 \\
4 & 0 & 4 & 3 & 2 & 1
\end{array}
\]

Calcul de l'inverse de 3 modulo 5 : on cherche $x$ tel que $3x \equiv 1 \pmod{5}$. En inspectant la table, $3 \times 2 = 6 \equiv 1 \pmod{5}$, donc $3^{-1} = 2$.
\end{example}

\begin{definition}[Corps $\F_P$ pour le partage de Shamir]
Dans le cadre du schéma $k$-sur-$n$, on utilise un corps fini premier particulier de cardinal 
\[
P = 2^{521} - 1
\]
qui est un nombre premier de Mersenne. Ce choix est motivé par :
\begin{itemize}
  \item Sa taille (521 bits) est suffisamment grande pour garantir la sécurité du partage de secret.
  \item Les opérations modulo $P$ peuvent être optimisées grâce à la forme $2^{521} - 1$ (réduction rapide).
  \item Le corps $\F_P$ permet de représenter de manière injective un secret maître $S \in \bin^{256}$ (car $P > 2^{256}$).
\end{itemize}
Ce corps sera le support algébrique des polynômes de Shamir utilisés pour le partage du secret maître.
\end{definition}

\begin{definition}[Anneau de polynômes]
Soit $\mathbb{K}$ un corps commutatif. L'anneau des polynômes à coefficients dans $\mathbb{K}$ est l'ensemble des suites $(a_0, a_1, a_2, \dots)$ d'éléments de $\mathbb{K}$ qui sont presque toutes nulles (c'est-à-dire qu'il existe un rang $N$ tel que $a_n = 0$ pour tout $n \geq N$). Un tel polynôme s'écrit usuellement $P(X) = a_0 + a_1X + a_2X^2 + \dots + a_dX^d$ où $d$ est le plus grand indice tel que $a_d \neq 0$ (degré). Les opérations sont :
\begin{itemize}
  \item Addition : $(a_n) + (b_n) = (a_n + b_n)$
  \item Multiplication : $(a_n) \cdot (b_n) = (c_n)$ avec $c_n = \sum_{i+j=n} a_i b_j$
\end{itemize}
On note cet anneau $\mathbb{K}[X]$.
\end{definition}

\begin{lemma}[Division euclidienne dans l'anneau $\Kpolys$]
Soient $A(X), B(X) \in \Kpolys$ avec $B(X) \neq 0$. Il existe un unique couple $(Q(X), R(X)) \in \Kpolys^2$ tel que :
\[
A(X) = B(X)Q(X) + R(X) \quad \text{avec} \quad \deg(R(X)) < \deg(B(X)) \quad \text{ou} \quad R(X) = 0.
\]
\end{lemma}

\begin{lemma}[Nombre de racines d'un polynôme]
\label{lem:racines-poly}
Soit $\mathbb{K}$ un corps et soit $f\in\Kpolys$ un polynôme non nul de degré $d\ge 0$. Alors $f$ admet au plus $d$ racines dans $\mathbb{K}$.
\end{lemma}

\begin{proof}
Par récurrence sur $d$. Le cas $d=0$ est immédiat (un polynôme constant non nul n'a aucune racine). Pour $d\ge 1$, si $f$ a une racine $a\in\mathbb{K}$, alors par division euclidienne dans $\Kpolys$, on peut écrire $f(X) = (X-a)g(X)$ avec $g\in\Kpolys$ de degré $d-1$.

Soit maintenant $b\neq a$ une autre racine de $f$. Alors $0=f(b)=(b-a)g(b)$. Comme $b-a\neq 0$ et que $\mathbb{K}$ est un corps (donc intègre), on en déduit $g(b)=0$. Ainsi, toutes les racines de $f$ distinctes de $a$ sont des racines de $g$. Par hypothèse de récurrence, $g$ a au plus $d-1$ racines, donc $f$ a au plus $d$ racines.
\end{proof}

\begin{proposition}[Anneau principal des polynômes]
\label{prop:anneau-principal}
Soit $\mathbb{K}$ un corps. Alors $\Kpolys$ est un anneau principal, c'est-à-dire que tout idéal de $\Kpolys$ est engendré par un unique polynôme unitaire (le générateur unitaire de l'idéal).
\end{proposition}

\begin{proof}
Soit $J$ un idéal non nul de $\Kpolys$. Considérons l'ensemble :
\[
D = \{\deg(P(X)) \mid P(X) \in J,\ P(X) \neq 0\}.
\]
Comme $J$ est non nul, $D$ est une partie non vide de $\mathbb{N}$. Soit $d_0$ le plus petit élément de $D$, et soit $P_0(X) \in J$ non nul de degré $d_0$. On peut supposer $P_0(X)$ unitaire (quitte à le normaliser). Montrons que $J = (P_0(X))$.

Soit $A(X) \in J$. Par division euclidienne, il existe $Q(X), R(X) \in \Kpolys$ tels que :
\[
A(X) = P_0(X)Q(X) + R(X) \quad \text{avec} \quad \deg(R(X)) < \deg(P_0(X)) \quad \text{ou} \quad R(X) = 0.
\]
Or $R(X) = A(X) - P_0(X)Q(X) \in J$ (car $A(X), P_0(X) \in J$). Si $R(X) \neq 0$, alors $\deg(R(X)) < d_0$, ce qui contredit la minimalité de $d_0$. Donc $R(X) = 0$ et $A(X) = P_0(X)Q(X) \in (P_0(X))$. Ainsi $J \subset (P_0(X))$. L'inclusion inverse est évidente car $P_0(X) \in J$. Donc $J = (P_0(X))$.
\end{proof}

\begin{proposition}[Quotient par un idéal maximal]
\label{prop:quotient-maximal}
Soit $A$ un anneau commutatif unitaire et $I$ un idéal maximal de $A$. Alors l'anneau quotient $A/I$ est un corps.
\end{proposition}

\begin{proof}
Soit $\overline{x} \neq 0$ dans $A/I$. Alors $x \notin I$. Considérons l'idéal $J = I + (x)$ (l'idéal engendré par $I$ et $x$). Puisque $I$ est maximal et $I \subsetneq J$ (car $x \in J$ mais $x \notin I$), on a nécessairement $J = A$.

Ainsi, il existe $i \in I$ et $a \in A$ tels que :
\[
1 = i + a \cdot x
\]
En passant au quotient dans $A/I$, on obtient :
\[
\overline{1} = \overline{i} + \overline{a} \cdot \overline{x} = 0 + \overline{a} \cdot \overline{x} = \overline{a} \cdot \overline{x}
\]
Donc $\overline{a}$ est l'inverse de $\overline{x}$ dans $A/I$. Ainsi, tout élément non nul de $A/I$ est inversible, et $A/I$ est un corps.
\end{proof}

\begin{corollary}[Construction de corps par quotient avec un polynôme irréductible]
\label{prop:corps-quotient}
Soit $\mathbb{K}$ un corps commutatif et soit $m(X) \in \Kpolys$ un polynôme irréductible. Alors l'anneau quotient $\Kpolys/(m(X))$ est un corps.
\end{corollary}

\begin{proof}
Soit $I = (m(X))$ l'idéal engendré par $m(X)$. 

Puisque $\Kpolys$ est principal (Proposition~\ref{prop:anneau-principal}), et que $m(X)$ est irréductible, l'idéal $I$ est maximal. En effet, soit $J$ un idéal tel que $I \subset J \subset \Kpolys$. Alors $J = (p(X))$ pour un certain $p(X) \in \Kpolys$. Puisque $m(X) \in J$, on a $p(X) \mid m(X)$. Mais $m(X)$ est irréductible, donc soit $p(X)$ est une constante non nulle (auquel cas $J = \mathbb{K[X]}$), soit $p(X)$ est associé à $m(X)$ (auquel cas $J = I$). Ainsi, $I$ est maximal.

Par la Proposition~\ref{prop:quotient-maximal}, le quotient $\Kpolys/I$ est un corps.
\end{proof}

\begin{theorem}[Théorème de Moore]
\label{thm:moore}
Pour tout $q = p^n$ avec $p$ premier et $n \ge 1$, il existe un corps fini de cardinal $q$, unique à isomorphisme près.
\end{theorem}

\begin{proof}[Idée de la preuve]
\textbf{Existence} : Soit $\F_p$ le corps premier à $p$ éléments. Soit $m(X) \in \F_p[X]$ un polynôme irréductible de degré $n$ (un tel polynôme existe toujours). Alors par la Proposition~\ref{prop:corps-quotient}, l'anneau quotient $\F_p[X]/(m(X))$ est un corps. Comme $\F_p[X]/(m(X))$ est un $\F_p$-espace vectoriel de dimension $n$, il contient exactement $p^n = q$ éléments.

\textbf{Unicité} : Soient $K$ et $L$ deux corps finis de cardinal $q = p^n$. Alors $K$ et $L$ ont pour caractéristique $p$ (car un corps fini a pour cardinal une puissance de sa caractéristique). Le sous-corps premier de $K$ et de $L$ est isomorphe à $\F_p$. Notons $\F_p$ ce sous-corps commun.

Soit $\alpha$ un élément primitif de $K$ (générateur du groupe multiplicatif $K^\times$). Soit $m_\alpha(X) \in \F_p[X]$ son polynôme minimal sur $\F_p$. Alors $\deg(m_\alpha) = n$ et $K \simeq \F_p[X]/(m_\alpha(X))$.

De même, soit $\beta$ un élément primitif de $L$ et $m_\beta(X)$ son polynôme minimal. Comme $m_\alpha$ et $m_\beta$ sont deux polynômes irréductibles de degré $n$ sur $\F_p$, ils sont tous deux facteurs du polynôme $X^{p^n} - X$ (qui se décompose en produit de tous les polynômes irréductibles de degré divisant $n$). En particulier, les corps de rupture $\F_p[X]/(m_\alpha(X))$ et $\F_p[X]/(m_\beta(X))$ sont isomorphes (ce sont des corps de décomposition du même polynôme $X^{p^n} - X$).

Ainsi, $K \simeq \F_p[X]/(m_\alpha(X)) \simeq \F_p[X]/(m_\beta(X)) \simeq L$.
\end{proof}

\begin{remark}[Construction pratique]
En pratique, pour construire $\F_{p^n}$, on choisit un polynôme irréductible $m(X) \in \F_p[X]$ de degré $n$ et on pose :
\[
\F_{p^n} = \F_p[X]/(m(X))
\]
Les éléments sont les polynômes de degré au plus $n-1$ à coefficients dans $\F_p$, et les opérations sont effectuées modulo $m(X)$.

Cette construction est fondamentale pour de nombreux schémas cryptographiques :
\begin{itemize}
  \item AES utilise $\F_{2^8} = \F_2[X]/(X^8 + X^4 + X^3 + X + 1)$
  \item Les courbes elliptiques utilisent souvent des extensions de $\F_p$
  \item Certains schémas de partage de secret utilisent des corps finis non premiers
\end{itemize}
\end{remark}

\begin{example}[Corps $\F_4$ comme $\FdeuxQuot$]
Le polynôme $X^2 + X + 1$ est irréductible sur $\F_2$ (il n'a pas de racine dans $\F_2$ : $0^2+0+1=1$, $1^2+1+1=1$). On a $\F_4 \simeq \FdeuxQuot$.

Les éléments de ce corps sont les polynômes de degré au plus 1 : $0, 1, X, X+1$. Notons $\alpha$ la classe de $X$ modulo $X^2+X+1$, donc $\alpha^2 + \alpha + 1 = 0$, soit $\alpha^2 = \alpha + 1$ (car $-1 = 1$ dans $\F_2$).

Tables d'opérations (en notant les éléments comme $0,1,\alpha,\alpha+1$) :
\[
\begin{array}{c|cccc}
+ & 0 & 1 & \alpha & \alpha+1 \\ \hline
0 & 0 & 1 & \alpha & \alpha+1 \\
1 & 1 & 0 & \alpha+1 & \alpha \\
\alpha & \alpha & \alpha+1 & 0 & 1 \\
\alpha+1 & \alpha+1 & \alpha & 1 & 0
\end{array}
\qquad
\begin{array}{c|cccc}
\times & 0 & 1 & \alpha & \alpha+1 \\ \hline
0 & 0 & 0 & 0 & 0 \\
1 & 0 & 1 & \alpha & \alpha+1 \\
\alpha & 0 & \alpha & \alpha+1 & 1 \\
\alpha+1 & 0 & \alpha+1 & 1 & \alpha
\end{array}
\]

\textbf{Calcul de l'inverse de $\alpha$ par l'algorithme d'Euclide étendu :}

Dans $\F_2[X]$, on cherche l'inverse de $X$ modulo $X^2+X+1$, c'est-à-dire un polynôme $u(X) \in \F_2[X]$ de degré au plus 1 tel que :
\[
X \cdot u(X) \equiv 1 \pmod{X^2+X+1}
\]

Appliquons l'algorithme d'Euclide étendu à $A(X) = X^2+X+1$ et $B(X) = X$ :

\begin{enumerate}
\item Division de $A(X)$ par $B(X)$ :
\[
X^2+X+1 = X \cdot (X+1) + 1
\]
Donc $Q_1(X) = X+1$ et $R_1(X) = 1$.

\item Division de $B(X)$ par $R_1(X)$ :
\[
X = 1 \cdot X + 0
\]
Le pgcd est donc $1 = R_1(X)$.

\item Remontons l'algorithme pour exprimer 1 comme combinaison de $X^2+X+1$ et $X$ :
\[
1 = (X^2+X+1) - X \cdot (X+1)
\]
Ainsi, modulo $X^2+X+1$, on a :
\[
X \cdot (X+1) \equiv -1 \equiv 1 \pmod{X^2+X+1}
\]
car dans $\F_2$, $-1 = 1$.
\end{enumerate}

Donc l'inverse de $X$ modulo $X^2+X+1$ est $X+1$. En termes d'éléments de $\F_4$, cela donne $\alpha^{-1} = \alpha+1$.

Vérification dans la table : $\alpha \times (\alpha+1) = 1$, donc $\alpha^{-1} = \alpha+1$.
\end{example}

\begin{remark}[À retenir sur les corps finis]\leavevmode\\[0.3em]
\begin{itemize}
  \item $\F_p = \mathbb{Z}/p\mathbb{Z}$ est un corps si et seulement si $p$ est premier.
  \item Pour tout $a$ non multiple de $p$, il existe un unique inverse $a^{-1} \in \F_p$.
  \item Un polynôme irréductible $m(X)$ sur $\F_2$ donne un corps $\F_{2^m} \simeq \F_2[X]/(m(X))$.
  \item Tout corps fini de cardinal $q = p^n$ est isomorphe à $\F_p[X]/(m(X))$ pour un polynôme irréductible $m(X)$ de degré $n$.
\end{itemize}
\end{remark}

\subsection{Mots binaires et conventions d'encodage}

Les primitives cryptographiques sont spécifiées en termes de mots binaires (octets, séquences d'octets) tandis que nous raisonnons souvent dans des corps finis $\F_n$. Cette section fixe les conventions d'encodage qui permettent de passer de l'un à l'autre sans ambiguïté.

\begin{definition}[Mots binaires]
Pour $t\in\N$, on note
\[
  \bin^t 
\]
l'ensemble des suites $(b_{t-1},\dots,b_0)$ de bits, avec la convention que $\bin^0 = \{\varepsilon\}$ contient le mot vide. On pose
\[
  \bin^* = \bigcup_{t\ge 0}\bin^t,
\]
et pour $x\in\bin^*$, on note $\lVert x\rVert$ sa longueur (en bits).
\end{definition}

\begin{definition}[Concaténation et XOR]
La concaténation est l'application
\[
  \concat : \bin^a \times \bin^b \to \bin^{a+b}
\]
qui à $(x,y)$ associe la suite obtenue en juxtaposant $x$ et $y$.

Le XOR est l'application
\[
  \xor : \bin^t \times \bin^t \to \bin^t
\]
définie par $(x,y) \mapsto (x_0 \oplus y_0, \dots, x_{t-1} \oplus y_{t-1})$, où $\oplus$ désigne l'addition dans $\F_2$.
\end{definition}

\begin{definition}[Encodage big-endian]
Pour $t\in\N$ et $b=(b_{t-1},\dots,b_0)\in\bin^t$, on définit
\[
  \mathrm{val}_{\mathrm{be}}(b) = \sum_{j=0}^{t-1} b_j\,2^{t-1-j}
  \in \{0,\dots,2^t-1\}.
\]
Cet encodage fournit une bijection canonique entre $\bin^t$ et
$\{0,\dots,2^t-1\}$.
\end{definition}

\begin{definition}[Encodage little-endian]
Pour $t\in\N$ et $b=(b_{t-1},\dots,b_0)\in\bin^t$, on définit
\[
  \mathrm{val}_{\mathrm{le}}(b) = \sum_{j=0}^{t-1} b_j\,2^{j}
  \in \{0,\dots,2^t-1\}.
\]
Cet encodage est utilisé dans les standards Ed25519.
\end{definition}

\begin{remark}[Convention d'écriture]
Dans la suite du document :
\begin{itemize}
\item L'encodage big-endian est utilisé pour :
  \begin{itemize}
    \item Le partage de Shamir (représentation des éléments de $\F_P$)
    \item Les représentations internes dans $\F_p$ pour RSA
    \item Les compteurs AES-GCM
  \end{itemize}
\item L'encodage little-endian est utilisé pour :
  \begin{itemize}
    \item Ed25519 (scalaires et points)
    \item Certaines opérations internes d'AES
  \end{itemize}
\item Le contexte déterminera clairement quel encodage est employé
\end{itemize}
\end{remark}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Secret maître et schéma de Shamir}

\subsection{Secret maître}

\begin{definition}[Secret maître]
On fixe un entier
\[
  P = 2^{521} - 1
\]
et le corps $\F_P$. Le secret maître est un mot binaire
\[
  S\in\bin^{256}
\]
tiré uniformément. On définit
\[
  s_0 = \mathrm{val}_{\mathrm{be}}(S) \in \{0,\dots,2^{256}-1\},\qquad
  s = s_0 \bmod P \in \F_P.
\]
Comme $P > 2^{256}-1$, on a $s = s_0$ dans $\F_P$, ce qui garantit que l'application $S \mapsto s$ est une injection de $\bin^{256}$ dans $\F_P$.
\end{definition}

Ainsi, $S$ est la représentation binaire utilisée pour la dérivation de
clés, et $s\in\F_P$ est la représentation dans le corps fini utilisée pour
le partage de secret.

\subsection{Schéma $(k,n)$ de Shamir}

\begin{definition}[Partage de Shamir]
Soient des entiers $n,k$ vérifiant $2\le k\le n$ et $n < P$. On définit le schéma
$(k,n)$ de Shamir sur $\F_P$ comme suit.
\begin{itemize}[leftmargin=2em]
  \item À partir de $s\in\F_P$, on choisit indépendamment et uniformément
        $a_1,\dots,a_{k-1}\in\F_P$.
  \item On définit
  \[
    f(X) = s + a_1X + a_2X^2 + \dots + a_{k-1}X^{k-1}\in\mathcal{P}_{<k}.
  \]
  \item Pour $i\in\{1,\dots,n\}$, on fixe $x_i=i\in\F_P$ (en identifiant l'entier $i$ à son image dans $\F_P$) et on pose
  \[
    y_i = f(x_i)\in\F_P.
  \]
  \item La part $i$-ème est le couple $(x_i,y_i)\in\F_P^2$.
\end{itemize}
\end{definition}

\begin{definition}[Algorithmes Share et Reconstruct]
On définit formellement les applications :
\begin{itemize}
\item $\mathrm{Share}: \F_P \to (\F_P^2)^n$ qui à $s$ associe la famille $((x_i,y_i))_{1\le i\le n}$.
\item $\mathrm{Reconstruct}: (\F_P^2)^k \to \F_P$ qui, à $k$ points distincts $(x_{i_j},y_{i_j})$, associe $s=f(0)$ obtenu par interpolation de Lagrange.
\end{itemize}
\end{definition}

\begin{theorem}[Unicité de l'interpolation]
\label{thm:lagrange}
Soient $x_1,\dots,x_k \in \F_P$ deux à deux distincts et
$y_1,\dots,y_k\in\F_P$. Il existe un unique $f\in\mathcal{P}_{<k}$ tel que
$f(x_j)=y_j$ pour tout $j\in\{1,\dots,k\}$.
\end{theorem}

\begin{proof}
Par le lemme sur le nombre de racines, deux polynômes de degré $<k$
coïncidant en $k$ points distincts sont égaux. L'existence s'obtient par la
formule d'interpolation de Lagrange :
\[
  f(X) = \sum_{j=1}^k y_j \ell_j(X),\qquad
  \ell_j(X) = \prod_{\substack{m=1\\ m\neq j}}^k
  \frac{X-x_m}{x_j-x_m}\in\F_P[X].
\]
Les dénominateurs $x_j-x_m$ sont inversibles dans $\F_P$ car les $x_j$ sont distincts. On vérifie $\ell_j(x_i)=\delta_{ij}$, d'où $f(x_j)=y_j$.
\end{proof}

\begin{propriete}[Reconstruction du secret]
\label{prop:reconstruction}
Soit $I=\{i_1,\dots,i_k\}$ avec $i_1<\dots<i_k$. Soit $f$ le polynôme
défini par le schéma de Shamir. Alors
\[
  s = f(0)
  = \sum_{j=1}^k y_{i_j}\,\lambda_j,\qquad
  \lambda_j = \ell_j(0) = \prod_{\substack{m=1\\ m\neq j}}^k
   \frac{-x_{i_m}}{x_{i_j}-x_{i_m}} \in \F_P.
\]
\end{propriete}

\begin{proof}
On applique le théorème~\ref{thm:lagrange} avec
$(x_j,y_j)=(x_{i_j},y_{i_j})$. On obtient
\[
  f(X) = \sum_{j=1}^k y_{i_j}\,\ell_j(X).
\]
Comme $f(X)=s + a_1X + \dots + a_{k-1}X^{k-1}$, on a $f(0)=s$. En évaluant en $X=0$, on obtient
\[
  s=f(0)=\sum_{j=1}^k y_{i_j}\ell_j(0),
\]
avec $\lambda_j=\ell_j(0)$.
\end{proof}

\begin{proposition}[Confidentialité parfaite du schéma de Shamir]
\label{prop:perfect-secrecy}
Soit $t<k$ et $I=\{i_1,\dots,i_t\}\subset\{1,\dots,n\}$. On suppose que
$(s,a_1,\dots,a_{k-1})$ est uniforme dans $\F_P^k$. Alors, pour toute réalisation
fixée des parts $\bigl( (x_{i_j},y_{i_j}) \bigr)_{1\le j\le t}$ et pour
tous $s_0,s_1\in\F_P$,
\[
  \Pr[s = s_0 \mid (x_{i_j},y_{i_j})]
  = \Pr[s = s_1 \mid (x_{i_j},y_{i_j})].
\]
En particulier, la loi a posteriori de $s$ conditionnellement à $t<k$ parts
reste uniforme sur $\F_P$.
\end{proposition}

\begin{proof}
Les $t$ équations $f(x_{i_j})=y_{i_j}$ forment un système linéaire de rang $t$ (la matrice de Vandermonde partielle est de rang plein car les $x_{i_j}$ sont distincts). Ce système impose $t$ contraintes indépendantes sur les $k$ variables $(s,a_1,\dots,a_{k-1})$.

Pour toute valeur fixée $s_0 \in \F_P$, le système restreint aux $(a_1,\dots,a_{k-1})$ a $t$ équations indépendantes sur $k-1$ variables, donc admet exactement $P^{k-1-t}$ solutions. Ce nombre est indépendant de $s_0$.

Par Bayes et l'uniformité a priori sur $\F_P^k$ :
\[
\Pr[s = s_0 \mid \text{parts}] = \frac{\Pr[\text{parts} \mid s = s_0] \cdot \Pr[s = s_0]}{\Pr[\text{parts}]} = \frac{P^{-t} \cdot P^{-1}}{P^{-t}} = \frac{1}{P}.
\]
Ainsi, la loi conditionnelle reste uniforme sur $\F_P$.
\end{proof}

%=========================================================
\section{Fonctions de hachage, HMAC, HKDF, PBKDF2}

\subsection{Fonction de hachage}

\begin{definition}[Fonction de hachage]
Une fonction de hachage est une application
\[
  h : \bin^* \to \bin^d,
\]
pour un $d$ fixé (par exemple $d=256$ pour SHA-256). Dans ce document,
$h$ désigne une telle fonction fixée une fois pour toutes.
\end{definition}

\subsection{HMAC}

\begin{definition}[Longueur de bloc et masques internes]
On fixe un entier $k_{\mathrm{blk}}\in\mathbb{N}^*$, appelé longueur de bloc
de HMAC. On se donne deux mots binaires
\[
  \mathsf{ipad},\,\mathsf{opad} \in \{0,1\}^{k_{\mathrm{blk}}}
\]
appelés respectivement masque interne et masque externe. Dans
les spécifications usuelles \cite{rfc2104}, ce sont les octets $0x36$ (pour \(\mathsf{ipad}\))
et $0x5C$ (pour \(\mathsf{opad}\)) répétés de façon à obtenir $k_{\mathrm{blk}}$
bits.
\end{definition}

\begin{definition}[Normalisation de clé pour HMAC]
On définit une application
\[
  \mathrm{NormKey} : \{0,1\}^* \to \{0,1\}^{k_{\mathrm{blk}}}
\]
qui, pour toute clé $K\in\{0,1\}^*$,
\begin{itemize}[leftmargin=2em]
  \item si $\lVert K\rVert > k_{\mathrm{blk}}$, alors $K_{\mathrm{blk}} = \mathrm{troncature}(h(K))$ aux $k_{\mathrm{blk}}$ premiers bits ;
  \item si $\lVert K\rVert < k_{\mathrm{blk}}$, alors $K_{\mathrm{blk}} = K \concat 0^{k_{\mathrm{blk}} - \lVert K\rVert}$ ;
  \item si $\lVert K\rVert = k_{\mathrm{blk}}$, alors $K_{\mathrm{blk}} = K$.
\end{itemize}
Ainsi, pour tout $K\in\{0,1\}^*$, la valeur $\mathrm{NormKey}(K)$ est un mot
binaire de longueur exactement $k_{\mathrm{blk}}$.
\end{definition}

\begin{definition}[HMAC basé sur $h$]
On fixe une fonction de hachage
\[
  h : \{0,1\}^* \to \{0,1\}^d.
\]
On définit la fonction
\[
  \HMAC_h : \{0,1\}^* \times \{0,1\}^* \to \{0,1\}^d
\]
par la formule :
\[
  \HMAC_h(K,M)
  = h\bigl( (\mathrm{NormKey}(K) \xor \mathsf{opad}) \concat
           h\bigl( (\mathrm{NormKey}(K) \xor \mathsf{ipad}) \concat M \bigr)
      \bigr).
\]
\end{definition}

\subsection{Fonction d'encodage d'entier}

\begin{definition}[Fonction $\mathrm{INT}_4$]
On définit l'application
\[
  \mathrm{INT}_4 : \{0,\dots,2^{32}-1\} \to \bin^{32}
\]
qui à un entier $i$ associe son encodage big-endian sur 4 octets (32 bits) :
\[
\mathrm{INT}_4(i) = (b_{31}b_{30}\dots b_0) \text{ où } i = \sum_{j=0}^{31} b_j 2^{31-j}.
\]
\end{definition}

\subsection{HKDF}

\begin{definition}[HKDF (HMAC-based Key Derivation Function) \cite{rfc5869}]
Soit $h:\bin^*\to\bin^d$ une fonction de hachage. On définit la fonction de dérivation de clé HKDF selon RFC 5869 :
\[
  \HKDF_h : \bin^* \times \bin^* \times \bin^* \times \N \to \bin^L
\]
comme suit. Soient $\mathrm{IKM}\in\bin^*$ (input keying material), $\mathrm{salt}\in\bin^*$, $\mathrm{info}\in\bin^*$, et $L\in\N$ (longueur de sortie en octets). On pose :
\begin{itemize}
\item $\mathrm{PRK} = \HMAC_h(\mathrm{salt}, \mathrm{IKM})$ (extraction)
\item On définit itérativement pour $i=1,2,\dots$ jusqu' à obtenir $L$ octets :
  \begin{align*}
  T_1 &= \HMAC_h(\mathrm{PRK}, \mathrm{info} \concat \mathrm{INT}_4(1)) \\
  T_2 &= \HMAC_h(\mathrm{PRK}, T_1 \concat \mathrm{info} \concat \mathrm{INT}_4(2)) \\
  &\vdots \\
  T_i &= \HMAC_h(\mathrm{PRK}, T_{i-1} \concat \mathrm{info} \concat \mathrm{INT}_4(i))
  \end{align*}
\item La sortie est la troncature aux $L$ octets de $T_1 \concat T_2 \concat \dots$
\end{itemize}
\end{definition}

\subsection{PBKDF2}

\begin{definition}[PBKDF2 (Password-Based Key Derivation Function 2) \cite{rfc8018}]
On fixe un paramètre d'itération $c\in\N^*$ et un hachage $h$. On définit
\[
  \PBKDF_h : \bin^* \times \bin^* \times \N^* \times \N \to \bin^{8L}
\]
où $L$ est le nombre d'octets souhaités. Pour un mot de passe $P\in\bin^*$, un sel $S\in\bin^*$ et un entier $L\ge 1$, on
définit, pour $i\ge 1$ :
\[
  U_1 = \HMAC_h(P,\,S\concat \mathrm{INT}_4(i)),
\]
\[
  U_j = \HMAC_h(P,\,U_{j-1})\quad(2\le j\le c),
\]
puis
\[
  F(P,S,c,i) = U_1 \xor U_2 \xor \dots \xor U_c.
\]
La sortie de PBKDF2 est le préfixe aux $8L$ bits de la concaténation
\[
  F(P,S,c,1)\concat F(P,S,c,2)\concat \dots
\]
\end{definition}

%=========================================================

\section{Structure de groupe et signature Ed25519}

\subsection{Courbe elliptique Ed25519}

\begin{definition}[Courbe elliptique Ed25519 (Edwards-curve Digital Signature Algorithm) \cite{rfc8032}]
Soit $q = 2^{255} - 19$ et $\F_q$ le corps fini correspondant. La courbe elliptique Ed25519 est définie par l'équation de Twisted Edwards :
\[
E: -x^2 + y^2 = 1 + dx^2y^2 \quad \text{sur } \F_q
\]
où $d = -\frac{121665}{121666} \in \F_q$, avec la division interprétée comme la multiplication par l'inverse modulo $q$.
\end{definition}

\begin{definition}[Loi de groupe sur $E(\F_q)$]
Soient $P_1 = (x_1, y_1)$ et $P_2 = (x_2, y_2)$ deux points de $E(\F_q)$. L'addition est définie par :
\[
P_1 + P_2 = (x_3, y_3) = \left(
\frac{x_1y_2 + y_1x_2}{1 + dx_1x_2y_1y_2},
\frac{y_1y_2 + x_1x_2}{1 - dx_1x_2y_1y_2}
\right)
\]
où toutes les opérations arithmétiques sont effectuées dans $\F_q$. L'élément neutre est le point $\mathcal{O} = (0, 1)$.
\end{definition}

\begin{proposition}[Cardinal du groupe]
Le groupe $E(\F_q)$ est abélien fini de cardinal :
\[
\#E(\F_q) = 8\ell
\]
où $\ell$ est le nombre premier $\ell = 2^{252} + 27742317777372353535851937790883648493$.
\end{proposition}

\begin{remark}[Admission du cardinal]
Le calcul du cardinal de la courbe Ed25519 est admis. Il peut être obtenu par l'algorithme de Schoof-Elkies-Atkin (SEA) et a été vérifié de manière indépendante par plusieurs implémentations.
\end{remark}

\begin{definition}[Point de base standard Ed25519]
On fixe le point de base standard $B \in E(\F_q)$ d'ordre $\ell$, dont les coordonnées affines sont :
\begin{align*}
y_B &= 46316835694926478169428394003475163141307993866256225615783033603165251855960 \\
x_B &= 15112221349535400772501151409588531511454012693041857206046113283949847762202
\end{align*}
Ces valeurs satisfont l'équation de la courbe.
\end{definition}

\begin{remark}[Admission de l'ordre du point de base]
L'ordre premier $\ell$ du point de base $B$ est admis. Cette propriété essentielle pour la sécurité cryptographique a été vérifiée par la communauté.
\end{remark}

\begin{definition}[Sous-groupe cyclique principal]
Le sous-groupe cyclique d'ordre $\ell$ est :
\[
\langle B \rangle = \{aB \mid a \in \mathbb{Z}_\ell\}
\]
\end{definition}

\begin{proposition}[Isomorphisme $\Z_\ell \simeq \langle B \rangle$]
\label{prop:iso-z-ell-b}
L'application
\[
\psi : \Z_\ell \to \langle B \rangle, \quad a \mapsto aB
\]
est un isomorphisme de groupes. Plus précisément :
\begin{enumerate}
  \item $\psi$ est un homomorphisme de groupes.
  \item $\ker(\psi) = \{0\}$ (injectivité).
  \item $\psi$ est surjectif par définition de $\langle B \rangle$.
\end{enumerate}
Par le premier théorème d'isomorphisme (Théorème~\ref{thm:iso-groupes}), on a donc $\Z_\ell/\ker(\psi) \simeq \mathrm{Im}(\psi)$, c'est-à-dire $\Z_\ell/\{0\} \simeq \langle B \rangle$.
\end{proposition}

\begin{proof}
Vérifions les propriétés :
\begin{enumerate}
  \item \textbf{Homomorphisme} : Pour tous $a, b \in \Z_\ell$, on a 
        \[
        \psi(a + b) = (a + b)B = aB + bB = \psi(a) + \psi(b),
        \]
        où l'addition dans $\Z_\ell$ est modulo $\ell$ et l'addition dans $\langle B \rangle$ est l'addition de points sur la courbe elliptique.
  
  \item \textbf{Noyau} : Soit $a \in \Z_\ell$ tel que $\psi(a) = \mathcal{O}$ (élément neutre). Alors $aB = \mathcal{O}$. Puisque $B$ est d'ordre $\ell$, cela implique que $\ell$ divise $a$. Comme $a \in \{0, \dots, \ell-1\}$, on a nécessairement $a = 0$. Donc $\ker(\psi) = \{0\}$.
  
  \item \textbf{Surjectivité} : Par définition, $\langle B \rangle = \{aB \mid a \in \Z_\ell\}$, donc tout élément de $\langle B \rangle$ est de la forme $aB$ pour un certain $a \in \Z_\ell$, c'est-à-dire $\psi(a)$.
\end{enumerate}
Ainsi, $\psi$ est un isomorphisme de groupes. L'application du premier théorème d'isomorphisme donne directement $\Z_\ell/\{0\} \simeq \langle B \rangle$.
\end{proof}

\begin{remark}[Application du théorème d'isomorphisme]
Le premier théorème d'isomorphisme pour les groupes (Théorème~\ref{thm:iso-groupes}) s'applique ici avec $G = \Z_\ell$, $H = \langle B \rangle$, et $f = \psi$. On a :
\begin{itemize}
  \item $\ker(\psi) = \{0\}$ qui est un sous-groupe distingué de $\Z_\ell$
  \item $\mathrm{Im}(\psi) = \langle B \rangle$
  \item $\Z_\ell/\{0\} \simeq \langle B \rangle$, ce qui est bien l'isomorphisme exhibé.
\end{itemize}
Cet isomorphisme est crucial pour Ed25519 : il permet d'identifier les scalaires (clés privées) avec les points du sous-groupe cyclique (clés publiques).
\end{remark}

\begin{remark}[Utilisation cryptographique]
Seuls les points du sous-groupe $\langle B \rangle$ d'ordre premier $\ell$ sont utilisés pour la cryptographie. Le clampage dans Ed25519 garantit que les scalaires appartiennent à $\mathbb{Z}_\ell$, et l'isomorphisme $\Z_\ell \simeq \langle B \rangle$ assure que chaque scalaire correspond à un unique point du sous-groupe.
\end{remark}
\subsection{Encodage des points et scalaires}

\begin{definition}[Encodage des points et scalaires]
L'encodage canonique d'un point $P = (x, y) \in E(\F_q)$ est défini par :
\[
\mathrm{enc}(P) = \mathrm{bytes}_{\mathrm{le}}(y) \concat p \in \bin^{256}
\]
où $\mathrm{bytes}_{\mathrm{le}}(y)$ est la représentation little-endian de $y$ sur 255 bits (32 octets, le bit de poids fort ignoré), et $p$ est le bit de parité de $x$, c'est-à-dire le bit le moins significatif de $x$.

L'encodage d'un scalaire $s \in \mathbb{Z}_\ell$ est sa représentation little-endian sur 32 octets.
\end{definition}

\begin{remark}[Encodage compressé]
L'encodage utilisé pour Ed25519 est l'encodage compressé standard où seul le coordonnée $y$ est stockée avec un bit de parité pour permettre la reconstruction de $x$. L'encodage est en little-endian conformément au standard \cite{rfc8032}.
\end{remark}

\subsection{Décodage des points Ed25519}

\begin{definition}[Symbole de Legendre]
Soit $p$ un nombre premier impair et $a$ un entier. Le symbole de Legendre $\left(\frac{a}{p}\right)$ est défini par :
\[
\left(\frac{a}{p}\right) = \begin{cases}
0 & \text{si } p \mid a \\
1 & \text{si } a \text{ est un carré modulo } p \\
-1 & \text{sinon}
\end{cases}
\]
\end{definition}

\begin{theorem}[Critère d'Euler]
\label{thm:euler-critere}
Soit $p$ un nombre premier impair et $a$ un entier non divisible par $p$. Alors :
\[
a^{(p-1)/2} \equiv \left(\frac{a}{p}\right) \pmod{p}
\]
En particulier, $a^{(p-1)/2} \equiv 1 \pmod{p}$ si et seulement si $a$ est un carré modulo $p$, et \\
$a^{(p-1)/2} \equiv -1 \pmod{p}$ si et seulement si $a$ n'est pas un carré modulo $p$.
\end{theorem}

\begin{proof}
Si $a$ est un carré modulo $p$, alors $a \equiv b^2 \pmod{p}$ pour un $b$ non divisible par $p$, donc $a^{(p-1)/2} \equiv b^{p-1} \equiv 1 \pmod{p}$ par le théorème de Fermat.

Réciproquement, dans $\F_p^*$ qui est cyclique d'ordre $p-1$, considérons l'homomorphisme $\phi: x \mapsto x^2$. Son noyau est $\{\pm 1\}$ d'ordre 2, donc son image (les carrés) est d'ordre $(p-1)/2$. L'équation $x^{(p-1)/2} = 1$ a au plus $(p-1)/2$ solutions, et tous les carrés la vérifient. Donc les non-carrés vérifient $a^{(p-1)/2} = -1$.
\end{proof}

\begin{lemma}[Lemme de Gauss pour les résidus quadratiques]
\label{lem:gauss-quadratic}
Soit $p$ un nombre premier impair et $a$ un entier non divisible por $p$. Considérons l'ensemble :
\[
A = \{a, 2a, 3a, \dots, \tfrac{p-1}{2}a\}
\]
Pour chaque élément $ka \in A$, on considère son \emph{résidu modulo $p$}, c'est-à-dire l'unique entier $r_k$ tel que $1 \leq r_k \leq p-1$ et $r_k \equiv ka \pmod{p}$.

On sépare ces résidus en deux groupes :
\begin{itemize}
\item Les résidus $r_1, \dots, r_k$ qui sont inférieurs ou égaux à $p/2$
\item Les résidus $s_1, \dots, s_\mu$ qui sont supérieurs à $p/2$
\end{itemize}
où $k$ est le nombre de résidus dans le premier groupe et $\mu$ est le nombre de résidus dans le second groupe. Alors :
\[
\left(\frac{a}{p}\right) = (-1)^\mu
\]
\end{lemma}

\begin{proof}
\textbf{Étape 1 : Les nombres $r_1, \dots, r_k, p-s_1, \dots, p-s_\mu$ sont distincts}

Les $r_i$ sont par définition dans $\{1, \dots, \lfloor p/2 \rfloor\}$. Pour les $s_j$, comme $s_j > p/2$, on a $p-s_j \in \{1, \dots, \lfloor p/2 \rfloor\}$.

Supposons par l'absurde qu'il existe $i,j$ tels que $r_i = p-s_j$. Alors :
\[
r_i + s_j = p
\]
Mais $r_i \equiv \alpha a \pmod{p}$ et $s_j \equiv \beta a \pmod{p}$ pour certains $\alpha, \beta \in \{1, \dots, \tfrac{p-1}{2}\}$. Donc :
\[
\alpha a + \beta a \equiv 0 \pmod{p} \quad \Rightarrow \quad (\alpha + \beta)a \equiv 0 \pmod{p}
\]
Puisque $p \nmid a$, on doit avoir $p \mid (\alpha + \beta)$. Mais $2 \leq \alpha + \beta \leq p-1$, contradiction.

Ainsi, ces $k + \mu = \tfrac{p-1}{2}$ nombres forment une permutation de $\{1, 2, \dots, \tfrac{p-1}{2}\}$.

\textbf{Étape 2 : Relations produits}

Le produit de tous les éléments de $\{1, 2, \dots, \tfrac{p-1}{2}\}$ est $\left(\tfrac{p-1}{2}\right)!$. Donc :
\[
r_1 \cdots r_k (p-s_1) \cdots (p-s_\mu) = \left(\frac{p-1}{2}\right)!
\]

Modulo $p$, on a $p-s_j \equiv -s_j \pmod{p}$, donc :
\[
r_1 \cdots r_k (p-s_1) \cdots (p-s_\mu) \equiv r_1 \cdots r_k (-s_1) \cdots (-s_\mu) = (-1)^\mu r_1 \cdots r_k s_1 \cdots s_\mu \pmod{p}
\]

Ainsi :
\[
(-1)^\mu r_1 \cdots r_k s_1 \cdots s_\mu \equiv \left(\frac{p-1}{2}\right)! \pmod{p} \tag{1}
\]

D'autre part, le produit des éléments de $A$ est :
\[
a \cdot 2a \cdot 3a \cdots \tfrac{p-1}{2}a = a^{(p-1)/2} \left(\frac{p-1}{2}\right)!
\]

Modulo $p$, ce produit est congru au produit des résidus des éléments de $A$, c'est-à-dire $r_1 \cdots r_k s_1 \cdots s_\mu$. Donc :
\[
a^{(p-1)/2} \left(\frac{p-1}{2}\right)! \equiv r_1 \cdots r_k s_1 \cdots s_\mu \pmod{p} \tag{2}
\]

\textbf{Étape 3 : Conclusion}

En substituant (2) dans (1), on obtient :
\[
(-1)^\mu a^{(p-1)/2} \left(\frac{p-1}{2}\right)! \equiv \left(\frac{p-1}{2}\right)! \pmod{p}
\]

Puisque $\left(\tfrac{p-1}{2}\right)!$ n'est pas divisible par $p$, on peut simplifier :
\[
(-1)^\mu a^{(p-1)/2} \equiv 1 \pmod{p} \quad \Rightarrow \quad a^{(p-1)/2} \equiv (-1)^\mu \pmod{p}
\]

Par le critère d'Euler (Théorème~\ref{thm:euler-critere}), on a $a^{(p-1)/2} \equiv \left(\frac{a}{p}\right) \pmod{p}$, donc :
\[
\left(\frac{a}{p}\right) = (-1)^\mu
\]
\end{proof}

\begin{lemma}[Caractère quadratique de 2]
Soit $q$ un nombre premier impair. Alors :
\[
\left(\frac{2}{q}\right) = (-1)^{\frac{q^2-1}{8}}
\]
En particulier, pour $q \equiv 5 \pmod{8}$, on a $\left(\frac{2}{q}\right) = -1$.
\end{lemma}

\begin{proof}
Nous appliquons le lemme~\ref{lem:gauss-quadratic} avec $a = 2$. Soit 
\[
A = \{2, 4, 6, \dots, 2\cdot\frac{q-1}{2}\} = \{2, 4, \dots, q-1\}
\]
Soit $\mu$ le nombre d'éléments de $A$ dont le reste modulo $q$ est supérieur à $q/2$. Alors par le lemme de Gauss :
\[
\left(\frac{2}{q}\right) = (-1)^\mu
\]

Les éléments de $A$ sont tous dans l'intervalle $[2, q-1]$. Un élément $2k$ (avec $1 \leq k \leq \frac{q-1}{2}$) a un reste modulo $q$ supérieur à $q/2$ si et seulement si $2k > q/2$, c'est-à-dire $k > q/4$.

Le nombre de tels $k$ est donc :
\[
\mu = \left\lfloor \frac{q-1}{2} \right\rfloor - \left\lfloor \frac{q}{4} \right\rfloor
\]

Écrivons $q = 8m + r$ avec $r \in \{1, 3, 5, 7\}$. Alors :
\[
\frac{q^2 - 1}{8} = \frac{(8m+r)^2 - 1}{8} = 8m^2 + 2mr + \frac{r^2 - 1}{8}
\]

D'autre part, calculons $\mu$ pour chaque cas :

\begin{itemize}
\item Si $q = 8m+1$, alors $\mu = 4m - 2m = 2m$ (pair)
\item Si $q = 8m+3$, alors $\mu = 4m+1 - 2m = 2m+1$ (impair)  
\item Si $q = 8m+5$, alors $\mu = 4m+2 - (2m+1) = 2m+1$ (impair)
\item Si $q = 8m+7$, alors $\mu = 4m+3 - (2m+1) = 2m+2$ (pair)
\end{itemize}

Donc $\left(\frac{2}{q}\right) = (-1)^\mu = (-1)^{\frac{q^2-1}{8}}$.

Pour $q \equiv 5 \pmod{8}$, on a $q = 8m+5$, donc $\frac{q^2-1}{8} = 8m^2 + 10m + 3$ qui est impair, donc $\left(\frac{2}{q}\right) = -1$.
\end{proof}

\begin{theorem}[Structure des racines carrées dans $\F_q$ pour $q \equiv 5 \pmod{8}$]
Soit $q = 2^{255} - 19$ et $a \in \F_q$ un élément non nul. Si $a$ est un carré dans $\F_q$, alors l'ensemble de ses racines carrées est $\{x, -x\}$ où :
\[
x = a^{(q+3)/8} \quad \text{ou} \quad x = a^{(q+3)/8} \cdot 2^{(q-1)/4}
\]
De plus, ces deux racines carrées ont des bits de parité opposés.
\end{theorem}

\begin{proof}
Soit $q = 2^{255} - 19 \equiv 5 \pmod{8}$. On peut écrire $q = 8k + 5$ avec $k \in \mathbb{Z}$, donc $(q+3)/8 = k+1$ est un entier.

Supposons que $a$ est un carré dans $\F_q$. Calculons $x_0 = a^{(q+3)/8}$ :
\[
x_0^2 = \left(a^{(q+3)/8}\right)^2 = a^{(q+3)/4} = a \cdot a^{(q-1)/4}
\]
Soit $b = a^{(q-1)/4}$. Puisque $a$ est un carré, le critère d'Euler (Théorème~\ref{thm:euler-critere}) donne $a^{(q-1)/2} = 1$, donc $b^2 = a^{(q-1)/2} = 1$, ce qui implique $b = \pm 1$.

On distingue deux cas :
\begin{itemize}
\item Si $b = 1$, alors $x_0^2 = a \cdot 1 = a$, donc $x_0$ est une racine carrée de $a$.
\item Si $b = -1$, alors $x_0^2 = a \cdot (-1) = -a$. Soit $i = 2^{(q-1)/4}$. Alors :
\[
i^2 = (2^{(q-1)/4})^2 = 2^{(q-1)/2}
\]
Par le lemme précédent, pour $q \equiv 5 \pmod{8}$, on a $\left(\frac{2}{q}\right) = -1$, donc par le critère d'Euler (Théorème~\ref{thm:euler-critere}), $2^{(q-1)/2} = -1$. Ainsi $i^2 = -1$ et $x = x_0 \cdot i$ vérifie $x^2 = x_0^2 \cdot i^2 = (-a) \cdot (-1) = a$, donc $x$ est une racine carrée de $a$.
\end{itemize}

Dans les deux cas, on obtient une racine carrée $x$ de $a$. L'autre racine carrée est $-x$. Puisque la caractéristique de $\F_q$ est différente de 2, on a $x \neq -x$. En effet, si $x = -x$, alors $2x = 0$, ce qui impliquerait $x = 0$, mais $a = x^2 = 0$, contradiction avec $a$ non nul.

De plus, les bits de parité de $x$ et $-x$ sont opposés. En effet, si on représente les éléments de $\F_q$ par des entiers entre $0$ et $q-1$, alors $-x$ est représenté par $q - x$. Comme $q$ est impair, $q - x$ a la parité opposée à $x$.
\end{proof}

\begin{definition}[Décodage des points Ed25519]
Le décodage d'un point compressé est l'application :
\[
\mathrm{dec}: \bin^{256} \to E(\F_q) \cup \{\perp\}
\]
définie comme suit. Soit $P_{\mathrm{enc}} \in \bin^{256}$ un point encodé :
\begin{enumerate}[leftmargin=2em]
  \item Interpréter $P_{\mathrm{enc}}$ comme un entier en little-endian $0 \le N < 2^{256}$. Noter $p$ le bit de poids fort de $N$ (bit d'indice 255), et $y$ l'entier obtenu en annulant ce bit, c'est-à-dire en prenant les 255 bits de poids faible. On identifie alors $y$ avec un élément de $\bin^{255}$ et $p \in \bin$.
  \item Interpréter $y$ (les 255 bits de poids faible) comme un élément de $\F_q$ (en little-endian) et le noter $y_P$.
  \item Calculer $x_P^2 = \frac{y_P^2 - 1}{d y_P^2 + 1}$ dans $\F_q$.
  \item Si $x_P^2$ n'est pas un carré dans $\F_q$, retourner $\perp$.
  \item Calculer une racine carrée $x_P$ de $x_P^2$ en utilisant le théorème précédent.
  \item Parmi les deux racines carrées $\{x_P, -x_P\}$, choisir celle dont le bit de parité (bit le moins significatif) est égal à $p$.
  \item Retourner le point $P = (x_P, y_P)$.
\end{enumerate}
\end{definition}

\begin{remark}[Implémentation efficace de la racine carrée]
En pratique, on calcule d'abord :
\[
x = a^{(q+3)/8}
\]
puis on vérifie :
\begin{itemize}
\item Si $x^2 = a$, alors $x$ est une racine carrée de $a$.
\item Si $x^2 = -a$, alors $x \cdot 2^{(q-1)/4}$ est une racine carrée de $a$.
\item Sinon, $a$ n'est pas un carré dans $\F_q$.
\end{itemize}
On ajuste ensuite la parité en choisissant entre la racine obtenue et son opposée selon le bit $p$ stocké dans l'encodage.
\end{remark}

\subsection{Clés Ed25519}

\begin{definition}[Clampage Ed25519]
Soit $H_1 \in \bin^{256}$, que l'on interprète comme une suite de 32 octets $(h_0, h_1, \dots, h_{31})$ en little-endian. Le clampage Ed25519 est l'application :
\[
\mathrm{clamp}: \bin^{256} \to \mathbb{Z}_\ell
\]
définie par les opérations suivantes sur les octets :
\begin{align*}
h_0 &\gets h_0 \land \mathtt{0xF8} \quad \text{(bits 0-2 à 0)}, \\
h_{31} &\gets (h_{31} \land \mathtt{0x7F}) \lor \mathtt{0x40} \quad \text{(bit 255 à 0, bit 254 à 1)},
\end{align*}
puis on pose
\[
a = \mathrm{val}_{\mathrm{le}}(h_0, h_1, \dots, h_{31}) \bmod \ell.
\]
\end{definition}

\begin{definition}[Génération de clés Ed25519]
Soit $K_{\mathrm{Ed}} \in \bin^{256}$. On calcule :
\[
H = \mathrm{SHA\text{-}512}(K_{\mathrm{Ed}}) = H_1 \concat H_2 \quad \text{avec } H_1, H_2 \in \bin^{256}
\]
La clé privée est :
\[
a = \mathrm{clamp}(H_1) \in \mathbb{Z}_\ell
\]
La clé publique est :
\[
A = aB \in E(\F_q)
\]
\end{definition}

\subsection{Algorithme de signature Ed25519}

\begin{definition}[Signature Ed25519 \cite{rfc8032}]
L'algorithme de signature $\mathrm{Sign}: \mathbb{Z}_\ell \times \bin^* \to \bin^{512}$ est défini comme suit :

Pour $(a, M) \in \mathbb{Z}_\ell \times \bin^*$ :
\begin{enumerate}[leftmargin=2em]
\item Calculer $H = \mathrm{SHA\text{-}512}(K_{\mathrm{Ed}}) = H_1 \concat H_2$
\item Définir $r = \mathrm{val}_{\mathrm{le}}(\mathrm{SHA\text{-}512}(H_2 \concat M)) \bmod \ell$
\item Calculer $R = rB \in E(\F_q)$
\item Calculer $k = \mathrm{val}_{\mathrm{le}}(\mathrm{SHA\text{-}512}(\mathrm{enc}(R) \concat \mathrm{enc}(A) \concat M)) \bmod \ell$
\item Calculer $s = (r + k \cdot a) \bmod \ell$
\item La signature est $\sigma = \mathrm{enc}(R) \concat \mathrm{bytes}_{\mathrm{le}}(s)$
\end{enumerate}
\end{definition}

\subsection{Algorithme de vérification Ed25519}

\begin{definition}[Vérification Ed25519 \cite{rfc8032}]
L'algorithme de vérification $\mathrm{Verify}: E(\F_q) \times \bin^* \times \bin^{512} \to \{\mathrm{OK}, \perp\}$ est défini comme suit :

Pour $(A, M, \sigma) \in E(\F_q) \times \bin^* \times \bin^{512}$ :
\begin{enumerate}[leftmargin=2em]
\item Parser $\sigma = R_{enc} \concat s_{enc}$ avec $R_{enc}, s_{enc} \in \bin^{256}$
\item Décoder $R = \mathrm{dec}(R_{enc}) \in E(\F_q)$
\item Décoder $s = \mathrm{val}_{\mathrm{le}}(s_{enc}) \in \mathbb{Z}_\ell$
\item Vérifier que $A$ et $R$ sont des points valides sur $E(\F_q)$
\item Vérifier que $s \in \{0, \dots, \ell-1\}$
\item Calculer $k = \mathrm{val}_{\mathrm{le}}(\mathrm{SHA\text{-}512}(R_{enc} \concat \mathrm{enc}(A) \concat M)) \bmod \ell$
\item Vérifier l'équation :
\[
sB = R + kA
\]
Si toutes les vérifications réussissent, retourner $\mathrm{OK}$, sinon $\perp$.
\end{enumerate}
\end{definition}

\begin{theorem}[Correction de la vérification Ed25519]
Pour toute paire $(a,A)$ générée valide et tout message $M$,
\[
\mathrm{Verify}(A, M, \mathrm{Sign}(a, M)) = \mathrm{OK}
\]
\end{theorem}

\begin{proof}
Soit $\sigma = (R, s)$ une signature valide. Alors :
\begin{align*}
sB &= (r + k \cdot a)B \\
   &= rB + k \cdot (aB) \\
   &= R + kA
\end{align*}
L'équation de vérification est donc satisfaite.
\end{proof}

\begin{remark}[Signature contextuelle dans le schéma $k$-sur-$n$]
Dans notre implémentation, on signe non pas $M$ directement mais le message contextualisé :
\[
M' = \texttt{"kofn-ed25519-v1"} \concat \mathrm{SHA256}(A) \concat M
\]
où $A$ est la clé publique Ed25519. Cela empêche la réutilisation des signatures hors contexte et garantit la liaison avec la clé maîtresse du schéma.
\end{remark}

\begin{remark}[Sécurité des signatures]
La sécurité d'Ed25519 repose sur la difficulté du problème du logarithme discret dans le groupe $\langle B \rangle$ et sur les propriétés de résistance aux collisions de SHA-512. Le clampage empêche les attaques par canaux auxiliaires et garantit que le scalaire est dans le sous-groupe principal.
\end{remark}

%=========================================================
\section{RSA, MGF1 et OAEP}



\subsection{Clés RSA}

\begin{definition}[Clés RSA (Rivest-Shamir-Adleman)]
On choisit deux nombres premiers $p,q$ de taille comparable (typiquement $p,q \approx 2^{2048}$ pour un module de 4096 bits) et on pose $n = pq$. 

On calcule $\varphi(n) = (p-1)(q-1)$ (voir Proposition~\ref{prop:phi-pq}).

On choisit un exposant public $e$ tel que $\gcd(e,\varphi(n)) = 1$ (typiquement $e = 65537$). L'exposant privé $d$ est l'inverse de $e$ modulo $\varphi(n)$ :
\[
d \equiv e^{-1} \pmod{\varphi(n)}
\]
La clé publique est $(n,e)$ et la clé privée est $(n,d)$.
\end{definition}






\
\begin{theorem}[Correction du chiffrement RSA]
\label{thm:rsa-correct}
Pour tout message $M \in \{0,\dots,n-1\}$ et toute clé RSA valide $(n,e,d)$, on a :
\[
(M^e)^d \equiv M \pmod{n}
\]
\end{theorem}

\begin{proof}
Puisque $ed \equiv 1 \pmod{\varphi(n)}$, il existe $k$ tel que $ed = 1 + k(p-1)(q-1)$.

\textbf{Modulo $p$} :
\begin{itemize}
\item Si $p \mid M$ : alors $M \equiv 0 \pmod{p}$, donc $M^{ed} \equiv 0 \equiv M \pmod{p}$
\item Si $p \nmid M$ : par le petit théorème de Fermat (théorème \ref{thm:fermat}), $M^{p-1} \equiv 1 \pmod{p}$, donc
  \[
  M^{ed} = M^{1 + k(p-1)(q-1)} = M \cdot (M^{p-1})^{k(q-1)} \equiv M \cdot 1^{k(q-1)} = M \pmod{p}
  \]
\end{itemize}

Ainsi, dans tous les cas, $M^{ed} \equiv M \pmod{p}$, donc $p \mid (M^{ed} - M)$.

\textbf{Modulo $q$} :
\begin{itemize}
\item Si $q \mid M$ : alors $M \equiv 0 \pmod{q}$, donc $M^{ed} \equiv 0 \equiv M \pmod{q}$
\item Si $q \nmid M$ : par le petit théorème de Fermat (théorème \ref{thm:fermat}), $M^{q-1} \equiv 1 \pmod{q}$, donc
  \[
  M^{ed} = M^{1 + k(p-1)(q-1)} = M \cdot (M^{q-1})^{k(p-1)} \equiv M \cdot 1^{k(p-1)} = M \pmod{q}
  \]
\end{itemize}

Ainsi, dans tous les cas, $M^{ed} \equiv M \pmod{q}$, donc $q \mid (M^{ed} - M)$.

Soit $N = M^{ed} - M$. Nous avons montré que $p \mid N$ et $q \mid N$. Puisque $p$ et $q$ sont premiers distincts, ils sont premiers entre eux.

Comme $p \mid N$, on peut écrire $N = p \cdot K$ pour un certain entier $K$.
Puisque $q \mid N = p \cdot K$ et que $\gcd(p,q) = 1$, par le théorème de Gauss (théorème \ref{thm:gauss-div}), $q \mid K$.
Donc $K = q \cdot L$ pour un certain entier $L$, et ainsi :
\[
N = p \cdot K = p \cdot q \cdot L = n \cdot L
\]
Ce qui montre que $n \mid N$, c'est-à-dire :
\[
M^{ed} \equiv M \pmod{n}
\]
\end{proof}

\begin{remark}[Risque lorsque $\gcd(M,n) \neq 1$]
Si $\gcd(M,n) \neq 1$, alors $M$ est divisible par $p$ ou par $q$, ce qui permettrait à un attaquant de factoriser $n$ en calculant $\gcd(M,n)$.

Bien que théoriquement possible, cette attaque est pratiquement irréalisable :

\begin{itemize}
\item Pour un module RSA de 4096 bits, la probabilité qu'un message aléatoire $M$ (de 4096 bits après encodage OAEP) ait un facteur commun avec $n$ est d'environ $2^{-2048}$
\item Cette probabilité est bien inférieure à l'inverse du nombre estimé de particules dans l'univers observable ($\approx 10^{80} \approx 2^{266}$)
\item Même en chiffrant un milliard de messages par seconde pendant l'âge de l'univers ($\approx 4 \times 10^{17}$ secondes), le nombre total de messages serait d'environ $10^{26} \approx 2^{86}$, et l'espérance du nombre de messages \og vulnérables \fg{} serait de $2^{86} \cdot 2^{-2048} = 2^{-1962}$, ce qui reste bien inférieur à 1
\item Si un tel événement se produisait par miracle, le chiffrement et le déchiffrement fonctionneraient parfaitement normalement, et personne ne s'en rendrait compte sans calculer explicitement $\gcd(M,n)$
\end{itemize}

En pratique, cette attaque n'est donc pas une préoccupation réaliste pour la sécurité de RSA avec des paramètres standard.
\end{remark}

\begin{definition}[Paramètres concrets pour le schéma $k$-sur-$n$]
Dans notre implémentation :
\begin{itemize}[leftmargin=2em]
  \item Module $n$ : 4096 bits
  \item Exposant public $e = 65537$
  \item Exposant privé $d \equiv e^{-1} \pmod{\varphi(n)}$
\end{itemize}
\end{definition}

\begin{remark}[Sécurité RSA]
La sécurité de RSA repose sur la difficulté de la factorisation du module $n$. Pour un module de 4096 bits, cela offre une sécurité suffisante selon les standards actuels.
\end{remark}

\subsection{MGF1}

\begin{definition}[Fonction de génération de masque MGF1 (Mask Generation Function 1) \cite{rfc8017}]
Soit $h:\bin^*\to\bin^d$ une fonction de hachage. On définit
\[
  \MGF_h : \bin^* \times \N \to \bin^\ell
\]
par :
\[
  \MGF_h(Z,\ell) = T_1 \concat T_2 \concat \dots \concat T_{\lceil \ell/d \rceil} \quad \text{tronqué à $\ell$ bits}
\]
où 
\[
T_i = h(Z \concat \mathrm{INT}_4(i-1)) \quad \text{pour } i = 1, 2, \dots, \lceil \ell/d \rceil
\]
et $\mathrm{INT}_4(j)$ est l'encodage big-endian de $j$ sur 4 octets.
\end{definition}

\begin{propriete}[Propriétés de MGF1]
MGF1 est déterministe et peut générer des masques de longueur arbitraire. Sa sécurité repose sur les propriétés de résistance aux collisions et de préimage de la fonction de hachage sous-jacente $h$.
\end{propriete}

\begin{remark}[Rôle crucial de MGF1 dans OAEP]
MGF1 joue un rôle essentiel dans OAEP en empêchant les attaques par blocs indépendants :

\begin{itemize}
\item \textbf{Transformation de taille} : Passer d'une entrée fixe à une sortie de longueur arbitraire
\item \textbf{Distribution uniforme} : Garantir que le masque n'a pas de motifs détectables  
\item \textbf{Non-corrélation} : Assurer que chaque partie du masque est unique grâce au compteur
\item \textbf{Entrelacement cryptographique} : Créer des dépendances non linéaires entre \texttt{maskedSeed} et \texttt{maskedDB} via la structure :
  \[
  \begin{cases}
  \texttt{maskedDB} = \texttt{DB} \oplus \MGF_h(\texttt{seed}) \\
  \texttt{maskedSeed} = \texttt{seed} \oplus \MGF_h(\texttt{maskedDB})
  \end{cases}
  \]
\item \textbf{Prévention d'attaques par blocs} : Toute modification d'un bit dans une partie affecte de manière imprévisible l'ensemble du message, rendant impossible les attaques ciblées sur des blocs individuels
\item \textbf{Sécurité prouvée} : Permettre les preuves formelles de sécurité d'OAEP contre les attaques adaptatives (IND-CCA2)
\end{itemize}

Sans MGF1, un attaquant pourrait manipuler séparément les différentes parties du message encodé, réduisant la sécurité à celle de schémas de padding vulnérables comme PKCS\#1 v1.5. MGF1 est donc la \og colle cryptographique \fg{} qui assure l'indissociabilité des composants d'OAEP.
\end{remark}

\subsection{RSA-OAEP}

\begin{definition}[Paramètres RSA-OAEP (Optimal Asymmetric Encryption Padding) \cite{rfc8017}]
Soient $k$ la taille en octets du module $n$ (pour $n$ de 4096 bits, $k = 512$), et $hLen$ la taille de sortie de la fonction de hachage en octets (pour SHA-256, $hLen = 32$). On fixe :
\[
k_0 = k - 2hLen - 2,\quad k_1 = hLen
\]
où $k_0$ est la longueur maximale du message en octets et $k_1$ la longueur de l'aléa $r$.
\end{definition}

\begin{definition}[Encodage OAEP]
L'encodage OAEP pour un message $M\in\bin^{8k_0}$, un label $L\in\bin^*$ et un aléa $r\in\bin^{8k_1}$ est défini comme suit :
\begin{enumerate}[leftmargin=2em]
  \item Calculer $lHash = h(L)$
  \item Former la chaîne $PS = 0^{8(k - k_0 - 2hLen - 2)}$ (padding de zéros)
  \item Construire le bloc $DB = lHash \concat PS \concat 0x01 \concat M$
  \item Calculer $maskedDB = DB \xor \MGF_h(r, 8(k - hLen - 1))$
  \item Calculer $maskedSeed = r \xor \MGF_h(maskedDB, 8hLen)$
  \item Le message encodé est $EM = maskedSeed \concat maskedDB \in \bin^{8k}$
\end{enumerate}
\end{definition}

\begin{definition}[Chiffrement RSA-OAEP]
Soient $(n,e)$ une clé publique RSA, $k_0,k_1$ les paramètres de taille définis ci-dessus. On définit :
\begin{align*}
  \RSAOAEP_{(n,e)} &: \bin^{8k_0} \times \bin^{8k_1} \to \{0,\dots,n-1\} \\
  \RSAOAEP_{(n,e)}(M;r) &= \mathrm{val}_{\mathrm{be}}(EM)^e \bmod n
\end{align*}
où $EM$ est le résultat de l'encodage OAEP de $M$ avec l'aléa $r$.
\end{definition}

\begin{definition}[Déchiffrement RSA-OAEP]
Soient $(n,d)$ une clé privée RSA. On définit :
\begin{align*}
  \RSAOAEP^{-1}_{(n,d)} &: \{0,\dots,n-1\} \to \bin^{8k_0} \cup \{\perp\} \\
  \RSAOAEP^{-1}_{(n,d)}(C) &= 
  \begin{cases}
    M & \text{si le décodage réussit} \\
    \perp & \text{sinon}
  \end{cases}
\end{align*}
où $C \in \{0,\dots,n-1\}$ est le \textbf{texte chiffré} (ciphertext) obtenu par $\RSAOAEP_{(n,e)}(M;r)$.

Le déchiffrement procède comme suit :
\begin{enumerate}[leftmargin=2em]
  \item Calculer $EM = C^d \bmod n$ et convertir en binary sur $8k$ bits
  \item Parser $EM = maskedSeed \concat maskedDB$ avec $maskedSeed \in \bin^{8hLen}$
  \item Calculer $seed = maskedSeed \xor \MGF_h(maskedDB, 8hLen)$
  \item Calculer $DB = maskedDB \xor \MGF_h(seed, 8(k - hLen - 1))$
  \item Parser $DB = lHash' \concat PS \concat 0x01 \concat M$ où $PS$ est une suite de zéros
  \item Vérifier que $lHash' = h(L)$ et que $PS$ contient bien que des zéros
  \item Si toutes les vérifications passent, retourner $M$, sinon $\perp$
\end{enumerate}
\end{definition}

\begin{remark}[Statut de l'aléa $r$ dans OAEP]
Contrairement aux sels publics utilisés dans HKDF ou PBKDF2, l'aléa $r$ dans OAEP est \og cryptographiquement protégé \fg{} :
\begin{itemize}
\item \textbf{Non public} : $r$ n'est pas stocké en clair ni transmis publiquement
\item \textbf{Masqué cryptographiquement} : Il est caché dans le chiffré via $\texttt{maskedSeed} = r \oplus \MGF_h(\texttt{maskedDB})$
\item \textbf{Récupération au déchiffrement} : Seul le possesseur de la clé privée peut retrouver $r$ 
\item \textbf{Rôle éphémère} : $r$ est utilisé une seule fois puis \og jeté \fg{}
\end{itemize}
La sécurité d'OAEP repose sur le fait que $r$ reste \og imprévisible \fg{} pour un attaquant au moment du chiffrement.
\end{remark}

\begin{remark}[Paramètres numériques pour RSA-4096 et SHA-256]
Pour un module RSA de 4096 bits ($k = 512$ octets) avec SHA-256 ($hLen = 32$ octets), on a :
\[
k_0 = 512 - 2\times 32 - 2 = 446 \text{ octets}
\]
Cette capacité de 446 octets est amplement suffisante pour une clé AES-256 de 32 octets, avec une marge importante pour les données de padding.
\end{remark}

\begin{theorem}[Correction de RSA-OAEP]
Pour toute clé $(n,e,d)$ valide, pour tout message $M$ de longueur $8k_0$ bits et pour tout aléa $r\in\bin^{8k_1}$,
\[
  \RSAOAEP^{-1}_{(n,d)}\bigl(\RSAOAEP_{(n,e)}(M;r)\bigr) = M.
\]
\end{theorem}

\begin{proof}
La correction découle de la structure réversible de l'encodage OAEP. Les opérations de masquage utilisant MGF sont réversibles car déterministes, et les vérifications assuren l'intégrité du message.
\end{proof}

\begin{remark}[Propriétés de sécurité]
RSA-OAEP offre une sécurité prouvée dans le modèle de l'oracle aléatoire contre les attaques adaptatives à chiffrés choisis (IND-CCA2). Le padding OAEP prévient les attaques par canal auxiliaire et garantit l'intégrité du message.
\end{remark}

\begin{definition}[Utilisation dans le schéma $k$-sur-$n$]
Dans notre contexte, RSA-OAEP est utilisé pour chiffrer des clés AES-256 de 32 octets. Pour un module RSA de 4096 bits ($k=512$) avec SHA-256 ($hLen=32$), on a :
\[
k_0 = 512 - 2\times 32 - 2 = 446 \text{ octets}
\]
Ce qui est amplement suffisant pour une clé AES-256 de 32 octets, avec une marge importante de 414 octets pour le padding OAEP.
\end{definition}

%=========================================================
\section{AES-GCM}

\subsection{AES comme permutation de bloc}

\begin{definition}[AES-256 (Advanced Encryption Standard) selon FIPS 197 \cite{fips197}]
On fixe une taille de bloc de $128$ bits et une taille de clé de $256$ bits.
Pour chaque clé $K \in \bin^{256}$, on dispose d'une permutation de blocs
\[
  E_K : \bin^{128} \to \bin^{128},
\]
bijective, avec réciproque notée $D_K = E_K^{-1}$.

L'algorithme AES-256 opère sur un \emph{état} (state) représenté comme une matrice $4 \times 4$ d'octets, notée:
\[
\text{state} = 
\begin{bmatrix}
s_{0,0} & s_{0,1} & s_{0,2} & s_{0,3} \\
s_{1,0} & s_{1,1} & s_{1,2} & s_{1,3} \\
s_{2,0} & s_{2,1} & s_{2,2} & s_{2,3} \\
s_{3,0} & s_{3,1} & s_{3,2} & s_{3,3}
\end{bmatrix}
\]
où chaque $s_{r,c}$ est un octet ($0 \leq r < 4$, $0 \leq c < 4$).

\textbf{Note :} L'algorithme complet de chiffrement (fonction CIPHER) sera détaillé à la section~\ref{sec:aes-cipher}.
\end{definition}

\begin{definition}[Mapping entrée-état selon FIPS 197]
Le mapping entre le bloc d'entrée $in \in \bin^{128}$ et l'état suit l'ordre \emph{colonne-major} :
\[
s[r,c] = in[8 \cdot (4c + r) \ldots 8 \cdot (4c + r) + 7] \quad \text{pour } 0 \leq r < 4, 0 \leq c < 4
\]
En représentation octet, cela équivaut à :
\[
s[r,c] = in[4c + r] \quad \text{pour } 0 \leq r < 4, 0 \leq c < 4
\]
où $in$ est vu comme un tableau de 16 octets $in[0] \ldots in[15]$.
\end{definition}

\begin{definition}[Paramètres AES-256]
Pour AES-256, on a les paramètres fixes suivants:
\begin{itemize}
\item $Nk = 8$ (nombre de mots de 32 bits dans la clé)
\item $Nb = 4$ (nombre de mots de 32 bits dans le bloc/état)  
\item $Nr = 14$ (nombre de tours)
\end{itemize}
\end{definition}

\subsection{Correspondance des corps finis}

\begin{remark}[Corps GF($2^8$) d'AES]
Le corps GF($2^8$) utilisé dans AES correspond à la construction suivante dans notre formalisme :
\[
\F_{2^8} = \F_2[X]/(X^8 + X^4 + X^3 + X + 1)
\]
où :
\begin{itemize}
\item $\F_2$ est le corps à 2 éléments (corps premier)
\item Le polynôme $m(X) = X^8 + X^4 + X^3 + X + 1$ est irréductible sur $\F_2$
\item Chaque élément de $\F_{2^8}$ est un polynôme de degré $\leq 7$ à coefficients dans $\F_2$
\item Un octet $\{b_7b_6b_5b_4b_3b_2b_1b_0\}$ représente le polynôme $b_7X^7 + b_6X^6 + \cdots + b_1X + b_0$
\end{itemize}
\end{remark}

\begin{remark}[Différence avec le corps de Shamir]
Le corps $\F_P$ utilisé pour le partage de Shamir (avec $P = 2^{521}-1$) est de caractéristique différente :
\begin{itemize}
\item $\F_P$ : corps premier de caractéristique $P$ (premier)
\item $\F_{2^8}$ : corps de caractéristique 2
\end{itemize}
Cette différence est fondamentale et explique pourquoi les opérations arithmétiques (addition, multiplication) diffèrent radicalement entre Shamir et AES.
\end{remark}

\begin{proposition}[Opérations dans les corps de caractéristique 2]
Dans $\F_{2^8}$ :
\begin{itemize}
\item \textbf{Addition} : équivaut au XOR bit-à-bit
\item \textbf{Soustraction} : identique à l'addition ($a - b = a + b$)
\item \textbf{Multiplication} : multiplication polynomiale suivie de réduction modulo le polynôme irréductible
\end{itemize}
\end{proposition}

\subsection{Transformations de base}

\begin{definition}[S-box AES]
La S-box (table de substitution) AES est une table fixe de 256 octets définie dans le standard FIPS 197. Pour un octet d'entrée $xy$ en hexadécimal (où $x$ est le nibble de poids fort et $y$ le nibble de poids faible), la valeur de substitution est donnée par la table suivante:

\[
\renewcommand{\arraystretch}{1.2}
\begin{array}{c|cccccccccccccccc}
 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & a & b & c & d & e & f \\
\hline
0 & 63 & 7c & 77 & 7b & f2 & 6b & 6f & c5 & 30 & 01 & 67 & 2b & fe & d7 & ab & 76 \\
1 & ca & 82 & c9 & 7d & fa & 59 & 47 & f0 & ad & d4 & a2 & af & 9c & a4 & 72 & c0 \\
2 & b7 & fd & 93 & 26 & 36 & 3f & f7 & cc & 34 & a5 & e5 & f1 & 71 & d8 & 31 & 15 \\
3 & 04 & c7 & 23 & c3 & 18 & 96 & 05 & 9a & 07 & 12 & 80 & e2 & eb & 27 & b2 & 75 \\
4 & 09 & 83 & 2c & 1a & 1b & 6e & 5a & a0 & 52 & 3b & d6 & b3 & 29 & e3 & 2f & 84 \\
5 & 53 & d1 & 00 & ed & 20 & fc & b1 & 5b & 6a & cb & be & 39 & 4a & 4c & 58 & cf \\
6 & d0 & ef & aa & fb & 43 & 4d & 33 & 85 & 45 & f9 & 02 & 7f & 50 & 3c & 9f & a8 \\
7 & 51 & a3 & 40 & 8f & 92 & 9d & 38 & f5 & bc & b6 & da & 21 & 10 & ff & f3 & d2 \\
8 & cd & 0c & 13 & ec & 5f & 97 & 44 & 17 & c4 & a7 & 7e & 3d & 64 & 5d & 19 & 73 \\
9 & 60 & 81 & 4f & dc & 22 & 2a & 90 & 88 & 46 & ee & b8 & 14 & de & 5e & 0b & db \\
a & e0 & 32 & 3a & 0a & 49 & 06 & 24 & 5c & c2 & d3 & ac & 62 & 91 & 95 & e4 & 79 \\
b & e7 & c8 & 37 & 6d & 8d & d5 & 4e & a9 & 6c & 56 & f4 & ea & 65 & 7a & ae & 08 \\
c & ba & 78 & 25 & 2e & 1c & a6 & b4 & c6 & e8 & dd & 74 & 1f & 4b & bd & 8b & 8a \\
d & 70 & 3e & b5 & 66 & 48 & 03 & f6 & 0e & 61 & 35 & 57 & b9 & 86 & c1 & 1d & 9e \\
e & e1 & f8 & 98 & 11 & 69 & d9 & 8e & 94 & 9b & 1e & 87 & e9 & ce & 55 & 28 & df \\
f & 8c & a1 & 89 & 0d & bf & e6 & 42 & 68 & 41 & 99 & 2d & 0f & b0 & 54 & bb & 16 \\
\end{array}
\]

Cette table est notée $\mathrm{SBox} : \bin^8 \to \bin^8$.
\end{definition}

\begin{definition}[SUBBYTES()]
La transformation SUBBYTES() applique la S-box à chaque octet de l'état:
\[
s'_{r,c} = \mathrm{SBox}(s_{r,c}) \quad \text{pour } 0 \leq r < 4, 0 \leq c < 4
\]

Bien que la S-box soit définie par un algorithme (inversion dans GF($2^8$) suivie d'une transformation affine), dans la pratique elle est implémentée comme une table de consultation fixe pour des raisons de performance.
\end{definition}

\begin{remark}[Construction algorithmique de la S-box]
La S-box peut être générée algorithmiquement pour tout octet $b \neq 0$ par:
\begin{enumerate}
\item Calculer l'inverse multiplicatif $b^{-1}$ dans GF($2^8$) modulo $m(x) = x^8 + x^4 + x^3 + x + 1$
\item Appliquer la transformation affine:
\[
b_i' = b_i \oplus b_{(i+4)\mod 8} \oplus b_{(i+5)\mod 8} \oplus b_{(i+6)\mod 8} \oplus b_{(i+7)\mod 8} \oplus c_i
\]
où $c = \mathtt{0x63} = \{01100011\}$.
\end{enumerate}
Pour $b = 0$, on utilise $0^{-1} = 0$ par convention.
\end{remark}

\begin{definition}[SHIFTROWS()]
La transformation SHIFTROWS() décale cycliquement les lignes de l'état:
\begin{itemize}
\item Ligne 0: pas de décalage
\item Ligne 1: décalage de 1 position vers la gauche  
\item Ligne 2: décalage de 2 positions vers la gauche
\item Ligne 3: décalage de 3 positions vers la gauche
\end{itemize}
Formellement: $s'_{r,c} = s_{r,(c+r)\mod 4}$ pour $0 \leq r < 4$, $0 \leq c < 4$.
\end{definition}

\begin{definition}[MIXCOLUMNS()]
La transformation MIXCOLUMNS() traite chaque colonne de l'état comme un polynôme sur GF($2^8$) et le multiplie modulo $x^4 + 1$ par le polynôme fixe:
\[
a(x) = \{03\}x^3 + \{01\}x^2 + \{01\}x + \{02\}
\]
Ceci équivaut à la multiplication matricielle:
\[
\begin{bmatrix}
s'_{0,c} \\
s'_{1,c} \\
s'_{2,c} \\
s'_{3,c}
\end{bmatrix}
=
\begin{bmatrix}
02 & 03 & 01 & 01 \\
01 & 02 & 03 & 01 \\
01 & 01 & 02 & 03 \\
03 & 01 & 01 & 02
\end{bmatrix}
\begin{bmatrix}
s_{0,c} \\
s_{1,c} \\
s_{2,c} \\
s_{3,c}
\end{bmatrix}
\quad\text{pour } 0 \leq c < 4
\]
\end{definition}

\subsection{Expansion de clé AES-256}

\begin{definition}[Structure des mots de clé]
Un mot $w[i]$ est une séquence de 32 bits interprétée comme 4 octets:
\[
w[i] = (w[i]_0, w[i]_1, w[i]_2, w[i]_3)
\]
où $w[i]_0$ est l'octet de poids fort et $w[i]_3$ l'octet de poids faible.
\end{definition}

\begin{definition}[KEYEXPANSION() pour AES-256]
L'expansion de clé génère $4 \times (Nr + 1) = 60$ mots de 32 bits à partir de la clé initiale.

Soit $key[0..7]$ les 8 mots initiaux de la clé. Pour $i = 0$ à $59$:
\begin{itemize}
\item Si $i < 8$: $w[i] = key[i]$
\item Si $i \geq 8$ et $i \mod 8 = 0$: 
  \[
  w[i] = w[i-8] \oplus \text{SubWord}(\text{RotWord}(w[i-1])) \oplus \text{Rcon}[i/8]
  \]
\item Si $i \geq 8$ et $i \mod 8 = 4$:
  \[
  w[i] = w[i-8] \oplus \text{SubWord}(w[i-1])
  \]
\item Sinon:
  \[
  w[i] = w[i-8] \oplus w[i-1]
  \]
\end{itemize}
où:
\begin{itemize}
\item $\text{RotWord}([a,b,c,d]) = [b,c,d,a]$
\item $\text{SubWord}([a,b,c,d]) = [\text{SBox}(a), \text{SBox}(b), \text{SBox}(c), \text{SBox}(d)]$
\item $\text{Rcon}[j] = [x^{j-1}, \{00\}, \{00\}, \{00\}]$ avec $x = \{02\}$
\end{itemize}
\end{definition}

\begin{definition}[ADDROUNDKEY()]
La transformation ADDROUNDKEY() combine l'état avec la clé de tour par XOR. Pour chaque colonne $c$ ($0 \leq c < 4$), on a:
\[
[s'_{0,c}, s'_{1,c}, s'_{2,c}, s'_{3,c}] = [s_{0,c}, s_{1,c}, s_{2,c}, s_{3,c}] \oplus w[4 \times round + c]
\]
où $w[i]$ est le $i$-ème mot du schedule de clés et $round$ est le numéro du tour.
\end{definition}

\subsection{Algorithme de chiffrement complet}
\label{sec:aes-cipher}

\begin{definition}[CIPHER() pour AES-256]
L'algorithme de chiffrement complet est:
\begin{enumerate}
\item $\text{state} \leftarrow \text{in}$ (copie de l'entrée dans l'état selon le mapping colonne-major)
\item $\text{state} \leftarrow \text{ADDROUNDKEY}(\text{state}, w[0..3])$
\item Pour $round = 1$ à $Nr-1$:
  \begin{enumerate}
  \item $\text{state} \leftarrow \text{SUBBYTES}(\text{state})$
  \item $\text{state} \leftarrow \text{SHIFTROWS}(\text{state})$
  \item $\text{state} \leftarrow \text{MIXCOLUMNS}(\text{state})$
  \item $\text{state} \leftarrow \text{ADDROUNDKEY}(\text{state}, w[4 \times round..4 \times round + 3])$
  \end{enumerate}
\item $\text{state} \leftarrow \text{SUBBYTES}(\text{state})$
\item $\text{state} \leftarrow \text{SHIFTROWS}(\text{state})$
\item $\text{state} \leftarrow \text{ADDROUNDKEY}(\text{state}, w[4 \times Nr..4 \times Nr + 3])$
\item $\text{out} \leftarrow \text{state}$ (conversion selon le mapping colonne-major inverse)
\end{enumerate}
\end{definition}

\begin{definition}[Arithmétique dans GF($2^8$)]
Le corps fini GF($2^8$) est défini par le polynôme irréductible:
\[
m(x) = x^8 + x^4 + x^3 + x + 1
\]
Chaque octet $\{b_7b_6b_5b_4b_3b_2b_1b_0\}$ représente le polynôme:
\[
b(x) = b_7x^7 + b_6x^6 + b_5x^5 + b_4x^4 + b_3x^3 + b_2x^2 + b_1x + b_0
\]
L'addition est le XOR bit-à-bit. La multiplication est la multiplication polynomiale modulo $m(x)$.
\end{definition}

\begin{remark}[Implémentation efficace]
La multiplication par $\{02\}$ (notée $\text{XTIMES}()$) peut être implémentée efficacement:
\[
\text{XTIMES}(b) = 
\begin{cases}
(b \ll 1) & \text{si } b_7 = 0 \\
(b \ll 1) \oplus \{1b\} & \text{si } b_7 = 1
\end{cases}
\]
Cette opération est utilisée dans MIXCOLUMNS() et KEYEXPANSION().
\end{remark}

\subsection{Corps $\F_{2^{128}}$ et GHASH}

\begin{definition}[Corps $\F_{2^{128}}$]
On fixe un polynôme irréductible $P(X)\in\F_2[X]$ de degré $128$ (par
exemple $X^{128}+X^7+X^2+X+1$) et on définit
\[
  \F_{2^{128}} = \F_2[X]/(P(X)).
\]
On fixe une bijection entre $\bin^{128}$ et $\F_{2^{128}}$ en identifiant le bloc $(b_{127},\dots,b_0)$ au polynôme $\sum_{i=0}^{127} b_iX^i \bmod P(X)$.
\end{definition}

\begin{definition}[Sous-clé de hachage $H$]
Pour une clé AES $K$, on définit
\[
  H = E_K(0^{128}) \in \bin^{128},
\]
que l'on identifie à un élément de $\F_{2^{128}}$.
\end{definition}

\begin{definition}[GHASH (Galois Hash) selon SP 800-38D \cite{nist-sp800-38d}]
Soit $H\in\F_{2^{128}}$. Pour une séquence de blocs $X_1, \dots, X_m \in \bin^{128}$, la fonction GHASH est définie récursivement par:
\[
Y_0 = 0^{128}, \quad Y_i = (Y_{i-1} \oplus X_i) \cdot H \quad \text{pour } i = 1, \dots, m
\]
Le résultat est $Y_m$. Cette définition est équivalente à:
\[
\mathrm{GHASH}_H(X_1, \dots, X_m) = \sum_{j=1}^m X_j \cdot H^{m-j+1}
\]
\end{definition}


\subsection{Mode AES-GCM}

\begin{definition}[AES-GCM (Galois/Counter Mode) selon SP 800-38D \cite{nist-sp800-38d}]
Pour une clé $K\in\bin^{256}$, on modélise AES-GCM comme un couple
d'applications
\begin{align*}
  \AESGCM_K &: \bin^{96} \times \bin^* \times \bin^* \to \bin^* \times \bin^{128} \\
  \AESGCM_K^{-1} &: \bin^{96} \times \bin^* \times \bin^* \times \bin^{128} \to \bin^* \cup\{\perp\}
\end{align*}
où:
\begin{itemize}
\item Le premier argument est un nonce $N\in\bin^{96}$
\item Le deuxième argument est les données authentifiées associées (AAD) $A\in\bin^*$
\item Le troisième argument est le message $M\in\bin^*$
\item La sortie est un couple $(C,T)$ avec $C$ le texte chiffré et $T$ le tag (128 bits)
\end{itemize}
\end{definition}

\begin{remark}[Rôle d'AES dans AES-GCM]
Le chiffrement AES est utilisé à deux endroits essentiels dans GCM :
\begin{enumerate}
\item \textbf{Dans GCTR} : Pour générer la séquence de masquage en chiffrant les compteurs $J_i$ :
\[
E_K(J_i) \quad \text{servant de masque pour } M_i \xor E_K(J_i)
\]

\item \textbf{Pour calculer $H$} : La sous-clé de hachage est obtenue par :
\[
H = E_K(0^{128})
\]
qui est utilisée dans toutes les multiplications GHASH.
\end{enumerate}
Ainsi, AES fournit à la fois la confidentialité (via GCTR) et la base de l'authentification (via $H$).
\end{remark}

\begin{definition}[Structure mathématique de GCM]
Le mode GCM combine :
\begin{itemize}
\item Le chiffrement en mode compteur (GCTR) utilisant $E_K$ pour la confidentialité
\item La fonction d'authentification GHASH dans $\F_{2^{128}}$ utilisant $H = E_K(0^{128})$ pour l'intégrité
\end{itemize}
Soit le polynôme irréductible :
\[
P(X) = X^{128} + X^7 + X^2 + X + 1 \in \F_2[X]
\]
qui définit le corps $\F_{2^{128}} = \F_2[X]/(P(X))$.
\end{definition}

\begin{definition}[Sous-clé de hachage $H$]
Pour une clé AES $K$, on définit la sous-clé de hachage :
\[
H = E_K(0^{128}) \in \bin^{128}
\]
Cette valeur est identifiée à un élément de $\F_{2^{128}}$ et utilisée dans toutes les multiplications GHASH.
\end{definition}

\begin{definition}[Fonction d'incrémentation GCM]
Soit $\mathrm{incr}_s : \bin^{128} \to \bin^{128}$ qui incrémente les $s$ bits de droite comme un entier big-endian.
Pour GCM, $s = 32$ :
\[
\mathrm{incr}_{32}(X) = \mathrm{MSB}_{96}(X) \concat \mathrm{INT}_4^{-1}((\mathrm{val}_{\mathrm{be}}(\mathrm{LSB}_{32}(X)) + 1) \bmod 2^{32})
\]
\end{definition}

\begin{definition}[Génération des compteurs]
À partir du nonce $N\in\bin^{96}$, on définit :
\[
J_0 = 
\begin{cases}
N \concat 0^{31}1 & \text{si } \lVert N\rVert = 96 \\
\mathrm{GHASH}_H(\varepsilon, N) & \text{sinon}
\end{cases}
\]
Les compteurs successifs sont :
\[
J_i = \mathrm{incr}_{32}(J_{i-1}) \quad \text{pour } i = 1, 2, \dots
\]
\end{definition}

\begin{definition}[Fonction GCTR utilisant AES]
Pour une clé $K$, un compteur initial $ICB\in\bin^{128}$, et une entrée $X\in\bin^*$ :
\begin{align*}
\text{GCTR}_K(ICB, X) = & \\
\text{Si } X = \varepsilon &: \varepsilon \\
\text{Sinon } &: \text{Soit } m = \lceil \lVert X\rVert/128 \rceil \\
& \text{Pour } i = 1 \text{ à } m-1: \\
& \quad CB_i = \mathrm{incr}_{32}(CB_{i-1}) \text{ avec } CB_0 = ICB \\
& \quad Y_i = X_i \xor \mathbf{E_K(CB_i)} \quad \text{\textbf{AES utilisé ici}} \\
& CB_m = \mathrm{incr}_{32}(CB_{m-1}) \\
& Y_m = X_m \xor \mathrm{MSB}_{\lVert X_m\rVert}(\mathbf{E_K(CB_m)}) \quad \text{\textbf{AES utilisé ici}} \\
& \text{Résultat } Y_1 \concat \dots \concat Y_m
\end{align*}
\end{definition}

\begin{definition}[Fonction GHASH utilisant $H = E_K(0^{128})$]
Soit $H = \mathbf{E_K(0^{128})} \in \F_{2^{128}}$. Pour des données $X\in\bin^*$ :
\begin{align*}
\text{GHASH}_H(X) = & \\
\text{Soit } & X_1, \dots, X_m \leftarrow \text{Partition}_{128}(X) \\
& Y_0 = 0^{128} \\
& \text{Pour } i = 1 \text{ à } m: \\
& \quad Y_i = (Y_{i-1} \xor X_i) \cdot H \quad \text{dans } \F_{2^{128}} \\
& \text{Résultat } Y_m
\end{align*}
Équivalent polynomial :
\[
\text{GHASH}_H(X_1, \dots, X_m) = X_1 \cdot H^m \xor X_2 \cdot H^{m-1} \xor \dots \xor X_m \cdot H
\]
\end{definition}

\begin{definition}[Algorithme de chiffrement GCM]
Pour $K, N, A, M$ :
\begin{enumerate}[leftmargin=2em]
  \item $H = \mathbf{E_K(0^{128})}$ \quad \textbf{AES utilisé ici}
  \item $J_0 = \begin{cases} 
        N \concat 0^{31}1 & \text{si } \lVert N\rVert = 96 \\
        \mathrm{GHASH}_H(\varepsilon, N) & \text{sinon}
        \end{cases}$
  \item $C = \mathrm{GCTR}_K(\mathrm{incr}_{32}(J_0), M)$ \quad \textbf{AES utilisé dans GCTR}
  \item $u = 128 \cdot \lceil \lVert C\rVert/128 \rceil - \lVert C\rVert$
  \item $v = 128 \cdot \lceil \lVert A\rVert/128 \rceil - \lVert A\rVert$
  \item $S = \mathrm{GHASH}_H(A \concat 0^v \concat C \concat 0^u \concat \mathrm{len}_{64}(A) \concat \mathrm{len}_{64}(C))$
  \item $T = \mathrm{MSB}_t(\mathrm{GCTR}_K(J_0, S))$ \quad \textbf{AES utilisé dans GCTR}
  \item Retourner $(C, T)$
\end{enumerate}
où $\mathrm{len}_{64}(X)$ représente la longueur de $X$ en bits sur 64 bits.
\end{definition}

\begin{definition}[Algorithme de déchiffrement GCM]
Pour $K, N, A, C, T$ :
\begin{enumerate}[leftmargin=2em]
  \item $H = \mathbf{E_K(0^{128})}$ \quad \textbf{AES utilisé ici}
  \item $J_0 = \begin{cases} 
        N \concat 0^{31}1 & \text{si } \lVert N\rVert = 96 \\
        \mathrm{GHASH}_H(\varepsilon, N) & \text{sinon}
        \end{cases}$
  \item $P = \mathrm{GCTR}_K(\mathrm{incr}_{32}(J_0), C)$ \quad \textbf{AES utilisé dans GCTR}
  \item $u = 128 \cdot \lceil \lVert C\rVert/128 \rceil - \lVert C\rVert$
  \item $v = 128 \cdot \lceil \lVert A\rVert/128 \rceil - \lVert A\rVert$
  \item $S = \mathrm{GHASH}_H(A \concat 0^v \concat C \concat 0^u \concat \mathrm{len}_{64}(A) \concat \mathrm{len}_{64}(C))$
  \item $T' = \mathrm{MSB}_t(\mathrm{GCTR}_K(J_0, S))$ \quad \textbf{AES utilisé dans GCTR}
  \item Si $T' = T$ retourner $P$, sinon $\perp$
\end{enumerate}
\end{definition}

\begin{theorem}[Correction d'AES-GCM]
Pour toute clé $K$, tout nonce $N$, toutes données $A$, et tout message $M$ :
\[
\AESGCM_K^{-1}(N, A, \AESGCM_K(N, A, M)) = M
\]
\end{theorem}

\begin{proof}[Esquisse]
La correction découle de :
\begin{itemize}
\item La réversibilité de GCTR qui utilise $E_K$ de façon déterministe
\item La linéarité de GHASH dans $\F_{2^{128}}$ utilisant $H = E_K(0^{128})$
\item L'utilisation cohérente des mêmes compteurs $J_i$ et de la même clé $K$
\end{itemize}
\end{proof}

\begin{remark}[Double usage d'AES dans GCM]
AES est utilisé de deux manières différentes :
\begin{enumerate}
\item \textbf{Confidentialité} : Dans GCTR, $E_K(J_i)$ génère une séquence de masquage pour chiffrer le message
\item \textbf{Authentification} : $E_K(0^{128})$ produit $H$, la base de toutes les opérations GHASH
\end{enumerate}
Cette dualité fait de GCM un mode authentifié efficace utilisant une seule primitive cryptographique.
\end{remark}

\begin{remark}[Sécurité GCM]
La sécurité d'AES-GCM repose sur :
\begin{itemize}
\item L'indistinguabilité de $E_K$ comme permutation pseudo-aléatoire (PRP)
\item L'unicité des nonces (pour éviter la réutilisation des compteurs)
\item La résistance aux collisions de GHASH dans $\F_{2^{128}}$
\end{itemize}
\end{remark}

\begin{remark}[Utilisation dans le schéma $k$-sur-$n$]
Dans notre contexte :
\begin{itemize}
\item AES-256 est utilisé avec des clés de 256 bits
\item Nonces de 96 bits garantissant $J_0 = N \concat 0^{31}1$
\item Données authentifiées associées généralement vides : $A = \varepsilon$
\item Tags de 128 bits ($t = 128$)
\end{itemize}
\end{remark}


\subsection{Dénombrement des permutations vs. clés}

\begin{remark}[Injectivité pratique de l'application clé→permutation]
L'espace des blocs possibles est $\bin^{128}$, qui contient
\[
  N = 2^{128}
\]
éléments. L'ensemble de toutes les permutations de $\bin^{128}$ est donc
le groupe symétrique
\[
  \mathrm{Sym}(\bin^{128}) \simeq \mathfrak{S}_{2^{128}},
\]
qui contient
\[
  \bigl|\mathrm{Sym}(\bin^{128})\bigr| = (2^{128})!
\]
permutations possibles.

L'espace des clés AES-256 contient $ |\mathcal{K}| = 2^{256}$ clés possibles. L'application
\[
  \Phi : \mathcal{K} \to \mathrm{Sym}(\bin^{128}), \qquad K \mapsto E_K
\]
ne peut donc, au plus, réaliser que $2^{256}$ permutations parmi les $(2^{128})!$
permutations théoriquement possibles sur $\bin^{128}$.

En utilisant l'approximation de Stirling $\log_2(n!) \approx n(\log_2 n - \log_2 e)$,
\[
  \log_2\bigl((2^{128})!\bigr)
  \approx 2^{128} (\log_2(2^{128}) - \log_2 e)
  = 2^{128}(128 - \log_2 e)
  \approx 2^{128} \cdot 126{,}56,
\]
alors que
\[
  \log_2 |\mathcal{K}| = \log_2(2^{256}) = 256.
\]
On a donc
\[
  \log_2 \bigl|\mathrm{Sym}(\bin^{128})\bigr| \;\approx\; 126{,}56 \cdot 2^{128}
  \;\gg\; 256 = \log_2 |\mathcal{K}|,
\]
ce qui signifie que le nombre de permutations de blocs possibles est
astronomiquement plus grand que le nombre de clés AES-256 possibles.

Si l'on modélise AES-256 comme une \emph{permutation pseudo-aléatoire} (PRP),
la probabilité de collision (existence de $K \neq K'$ tels que $E_K = E_{K'}$)
est d'environ $2^{-\Omega(2^{128})}$, totalement négligeable à toute échelle pratique.
\end{remark}

%=========================================================

\section{Construction globale du schéma $k$-sur-$n$}

\subsection{Paramètres et constantes}

\begin{definition}[Paramètres globaux]
On fixe :
\begin{itemize}[leftmargin=2em]
  \item un entier $n\ge 2$ (nombre de participants) ;
  \item un entier $k$ avec $2\le k\le n$ (seuil) ;
  \item le corps $\F_P$ avec $P=2^{521}-1$ ;
  \item la fonction de hachage $h$ (par exemple SHA-256) ;
  \item les fonctions dérivées $\HMAC_h$, $\HKDF_h$, $\PBKDF_h$ ;
  \item un schéma de signature Ed25519 sur $(E(\F_q),\langle B\rangle)$ ;
  \item un schéma RSA-OAEP pour des modules de taille $4096$ bits ;
  \item AES-GCM avec blocs de 128 bits et clés de 256 bits.
\end{itemize}
\end{definition}

\begin{definition}[Constantes de contexte et sels]
On fixe les constantes suivantes :
\begin{itemize}[leftmargin=2em]
  \item $\mathrm{info}_{\mathrm{Ed}}\in\bin^*$, chaîne ASCII
        (par exemple \texttt{"ed25519-master-key"}) ;
  \item $\mathrm{info}_{\mathrm{RSA}}\in\bin^*$,
        (par exemple \texttt{"rsa-wrap-key"}) ;
  \item un sel HKDF public pour Ed25519,
        $\mathrm{saltEd}\in\bin^*$, typiquement l'ASCII de
        \texttt{"ed25519-salt"} ;
  \item pour chaque cérémonie, un sel HKDF public pour RSA,
        $W\in\bin^{\ell_{\mathrm{wrap}}}$, tiré uniformément ;
  \item pour chaque participant $i$, un sel PBKDF2 individuel
        $S_i\in\bin^{\ell_S}$ (avec $\ell_S$ fixé, par exemple 128 bits), tiré uniformément ;
  \item un nombre d'itérations $c\in\N^*$ pour PBKDF2 ;
  \item pour RSA-OAEP, un label $L\in\bin^*$ (souvent vide).
\end{itemize}
\end{definition}

\subsection{Cérémonie initiale}

\begin{definition}[Encodage des éléments de $\F_P$]
Soit $\phi: \F_P \to \bin^{521}$ l'isomorphisme qui à $a \in \F_P$ associe sa représentation binaire big-endian sur $\lceil \log_2 P \rceil = 521$ bits.
\end{definition}

\begin{definition}[Étape de génération]
La cérémonie initiale réalise les étapes suivantes :
\begin{enumerate}[leftmargin=2em,label=\arabic*)]
  \item Tirer $S\in\bin^{256}$ uniformément et définir $s = \mathrm{val}_{\mathrm{be}}(S) \bmod P \in \F_P$.
  \item Appliquer $\mathrm{Share}(s)$ pour obtenir les parts
        $(x_i,y_i)_{1\le i\le n}$.
  \item Dériver la clé
  \[
    K_{\mathrm{Ed}} = \HKDF_h(S,\mathrm{saltEd},
    \mathrm{info}_{\mathrm{Ed}},32) \in \bin^{256}.
  \]
  \item Dériver à partir de $K_{\mathrm{Ed}}$ la paire de clés Ed25519
        $(a,A)$.
  \item Générer une paire RSA $(n,e,d)$ avec $n$ de 4096 bits.
  \item Tirer $W\in\bin^{\ell_{\mathrm{wrap}}}$ et dériver la clé
  \[
    K_{\mathrm{RSA}} = \HKDF_h(S,W,
    \mathrm{info}_{\mathrm{RSA}},L_{\mathrm{RSA}}) \in \bin^{8L_{\mathrm{RSA}}}
  \]
  avec $L_{\mathrm{RSA}}=32$ (clé AES-256 de 32 octets).
  \item Encoder la clé privée RSA en un mot binaire $M_{\mathrm{RSA}}$ (format PEM ou DER), puis calculer
  \[
    (C_{\mathrm{RSA}}, T_{\mathrm{RSA}}) = \AESGCM_{K_{\mathrm{RSA}}}(N_{\mathrm{RSA}}, M_{\mathrm{RSA}})
  \]
  pour un nonce $N_{\mathrm{RSA}}\in\bin^{96}$.
  \item Stocker $(W,N_{\mathrm{RSA}},C_{\mathrm{RSA}},T_{\mathrm{RSA}})$ dans \texttt{rsa\_wrapped.json}.
\end{enumerate}
\end{definition}

\subsection{Protection des parts}

\begin{definition}[Sérialisation des parts]
Pour chaque part $(x_i,y_i)$, on construit un dictionnaire JSON contenant les champs \texttt{x}, \texttt{y}, \texttt{k}, \texttt{n}, et \texttt{pub\_hash}. On encode ce dictionnaire en UTF-8 pour obtenir le message à chiffrer $M_i \in \bin^*$.
\end{definition}

\begin{definition}[Dérivation des clés individuelles]
Pour chaque participant $i$, on fixe un mot de passe $P_i\in\bin^*$ et on
définit
\[
  K_i = \PBKDF_h(P_i,S_i,c,L_i) \in \bin^{8L_i},
\]
où $L_i$ est choisi en fonction de la clé AES à dériver (par exemple
$L_i=32$ pour une clé AES-256).
\end{definition}

\begin{definition}[Chiffrement des parts]
Pour une part sérialisée $M_i$, on calcule
\[
  (C_i,T_i) = \AESGCM_{K_i}(N_i, M_i)
\]
avec un nonce $N_i\in\bin^{96}$. Le tuple $(S_i,N_i,C_i,T_i)$ est
stocké dans la partie personnelle du coffre du participant $i$.
\end{definition}

\subsection{Chiffrement hybride des fichiers}

\begin{definition}[Chiffrement hybride d'un fichier]
Soit un fichier $F\in\bin^*$. On procède comme suit :
\begin{enumerate}[leftmargin=2em,label=\arabic*)]
  \item Tirer une clé de session $K_{\mathrm{AES}}\in\bin^{256}$.
  \item Tirer un nonce $N\in\bin^{96}$.
  \item Calculer $(C,T)=\AESGCM_{K_{\mathrm{AES}}}(N,F)$.
  \item Calculer $E_K = \RSAOAEP_{(n,e)}(K_{\mathrm{AES}};r)$ pour un
        aléa $r\in\bin^{k_1}$.
\end{enumerate}
Le quadruplet $(E_K,N,C,T)$ est le chiffrement hybride de $F$.
\end{definition}

%=========================================================
\section{Correspondance avec les scripts Tails v1}

Cette section établit la correspondance entre les objets formalisés ci-dessus
et les éléments concrets (scripts, fichiers) de la procédure Tails v1.

\subsection{Secret maître et partage Shamir}

\begin{itemize}[leftmargin=2em]
  \item Le secret $S\in\bin^{256}$ est généré par \verb|os.urandom(32)|
        dans le script \texttt{ceremony\_generate.py} (variable \verb|S_int|).
  \item La conversion $s = \mathrm{val}_{\mathrm{be}}(S) \bmod P \in \F_P$ est implicite
        dans l'implémentation Python.
  \item Les partages $(x_i,y_i)$ sont obtenus par évaluation d'un
        polynôme $f\in\mathcal{P}_{<k}$ via la fonction \verb|shamir_split|.
  \item La reconstruction utilise l'interpolation de Lagrange dans
        \verb|shamir_reconstruct| avec calcul explicite des coefficients
        $\lambda_j$.
\end{itemize}

\subsection{Clés dérivées, sels HKDF et Ed25519}

\begin{itemize}[leftmargin=2em]
  \item La clé $K_{\mathrm{Ed}} = \HKDF_h(S,\mathrm{saltEd},
        \mathrm{info}_{\mathrm{Ed}},32)$ est instanciée via :
\begin{verbatim}
HKDF(SHA256, 32, salt=b"ed25519-salt", 
     info=b"ed25519-master-key")
\end{verbatim}
  \item De même, $K_{\mathrm{RSA}} = \HKDF_h(S,W,
        \mathrm{info}_{\mathrm{RSA}},32)$ utilise \verb|info=b"rsa-wrap-key"|
        avec un sel aléatoire $W$ stocké dans \texttt{rsa\_wrapped.json}.
  \item La paire $(a,A)$ est construite via 
        \verb|Ed25519PrivateKey.from_private_bytes(ed_seed)|,
        où \texttt{ed\_seed} est $K_{\mathrm{Ed}}$. L'API effectue le clampage
        et calcule $A=aB$.
\end{itemize}

\subsection{PBKDF2, sels $S_i$ et chiffrement des parts}

\begin{itemize}[leftmargin=2em]
  \item Pour chaque participant $i$, le script tire un sel $S_i$ (16 octets)
        et dérive $K_i = \PBKDF_h(P_i,S_i,c,32)$ avec $c=501000$ itérations.
  \item Les parts sont sérialisées en JSON avec les champs \texttt{x}, \texttt{y}, 
        \texttt{k}, \texttt{n}, et \texttt{pub\_hash}, puis chiffrées par AES-GCM.
  \item L'enveloppe chiffrée inclut les métadonnées nécessaires pour la
        vérification lors de la reconstruction.
\end{itemize}

\subsection{RSA, OAEP et chiffrement hybride}

\begin{itemize}[leftmargin=2em]
  \item La paire RSA $(n,e,d)$ est générée avec $n=4096$ bits et $e=65537$.
  \item La clé privée RSA est sérialisée en PEM puis chiffrée sous AES-GCM
        avec $K_{\mathrm{RSA}}$, produisant \texttt{rsa\_wrapped.json}.
  \item Le script \texttt{rsa\_hybrid\_encrypt.py} implémente le chiffrement
        hybride : 
        \begin{itemize}
        \item Génération de $K_{\mathrm{AES}} \in \bin^{256}$ 
        \item Chiffrement de $F$ par $\AESGCM_{K_{\mathrm{AES}}}(N,F)$
        \item Chiffrement de $K_{\mathrm{AES}}$ par $\RSAOAEP_{(n,e)}$
        \end{itemize}
  \item Le déchiffrement dans \texttt{kofn\_rsa\_decrypt.py} inverse ces étapes
        après reconstruction de $S$ et déverrouillage de la clé RSA.
\end{itemize}

\subsection{Signature Ed25519 avec contexte}

\begin{itemize}[leftmargin=2em]
  \item Les signatures utilisent un contexte déterministe :
        \[
        \mathrm{contexte} = \texttt{"kofn-ed25519-v1"} \concat \mathrm{SHA256}(A) \concat M
        \]
        pour éviter la réutilisation hors contexte.
  \item La vérification dans \texttt{verify\_ed25519.py} utilise le même
        contexte, assurant l'authenticité même avec la même clé publique.
\end{itemize}

\subsection{Gestion sécurisée de la mémoire}

\begin{itemize}[leftmargin=2em]
  \item Les secrets éphémères ($S$, seeds) sont stockés dans des 
        \texttt{bytearray} pour permettre l'effacement explicite via
        \verb|secure_wipe|.
  \item Cette mesure atténue les risques d'exposition en RAM après usage.
\end{itemize}

\subsection{Résumé sur les sels publics}

\begin{itemize}[leftmargin=2em]
  \item Sel HKDF Ed25519 $\mathrm{saltEd}$ :
        \begin{itemize}
          \item valeur : chaîne ASCII constante (par exemple
                \verb|"ed25519-salt"|) ;
          \item génération : aucun tirage, valeur codée en dur
                dans le script ;
          \item stockage : implicite dans le code, public et identique
                pour toutes les cérémonies.
        \end{itemize}
  \item Sel HKDF RSA (wrap salt) $W$ :
        \begin{itemize}
          \item valeur : bitstring aléatoire \verb|wrap_salt|
                généré par \verb|os.urandom(WRAP_SALT_SIZE)| ;
          \item génération : une fois par cérémonie de génération
                de la clé RSA ;
          \item stockage : champ \verb|"salt"| dans \texttt{rsa\_wrapped.json},
                encodé en Base64, public.
        \end{itemize}
  \item Sels PBKDF2 $S_i$ :
        \begin{itemize}
          \item valeur : bitstrings aléatoires individuels, un par participant,
                générés par \\
                 \verb|os.urandom(SALT_SIZE)| ;
          \item génération : lors de la création ou de la mise à jour de la
                protection de la part du participant $i$ ;
          \item stockage : dans la partie personnelle du coffre du participant,
                aux côtés de $(N_i,C_i,T_i)$, public mais lié au participant.
        \end{itemize}
\end{itemize}

%=========================================================
\section{Résumé des propriétés de sécurité}

\begin{definition}[Modèle de sécurité]
On considère un adversaire $\mathcal{A}$ ayant accès aux oracles :
\begin{itemize}
\item $\mathcal{O}_{\mathrm{Share}}$ : renvoie jusqu'à $t < k$ parts
\item $\mathcal{O}_{\mathrm{Sign}}$ : signe des messages avec la clé Ed25519
\item $\mathcal{O}_{\mathrm{Decrypt}}$ : déchiffre des textes chiffrés
\end{itemize}
\end{definition}

\begin{theorem}[Confidentialité conditionnelle]
Soit $\mathcal{A}$ un adversaire polynomial n'ayant accès qu'à $t < k$ parts. Alors pour toute fonction $f$ calculable en temps polynomial :
\[
\left|\Pr[\mathcal{A}(f(S)) = 1] - \Pr[\mathcal{A}(f(U)) = 1]\right| \leq \epsilon(\lambda)
\]
où $U$ est uniforme dans $\bin^{256}$ et $\epsilon$ est négligeable dans le paramètre de sécurité $\lambda$.
\end{theorem}

\begin{theorem}[Intégrité des signatures et des chiffrés]
Sous les hypothèses que HKDF, PBKDF2, AES-GCM et RSA-OAEP sont cryptographiquement sûrs, il est computationnellement difficile pour un adversaire polynomial de forger une signature Ed25519 valide ou de modifier un texte chiffré AES-GCM sans être détecté.
\end{theorem}

\begin{remark}
Une preuve complète de sécurité nécessiterait un modèle d'adversaire
précis (oracles, ressources de calcul) et l'utilisation de techniques de
réduction dans des modèles comme l'oracle aléatoire. On ne la développe
pas ici.
\end{remark}

%=========================================================
% RÉFÉRENCES
%=========================================================

\newpage

\begin{thebibliography}{9}

\bibitem{shamir1979share}
Shamir, A. (1979). 
\textit{How to share a secret}. 
Communications of the ACM, 22(11), 612-613.

\bibitem{rfc2104}
Krawczyk, H., Bellare, M., \& Canetti, R. (1997).
\textit{HMAC: Keyed-Hashing for Message Authentication}.
RFC 2104.

\bibitem{rfc5869}
Krawczyk, H., \& Eronen, P. (2010).
\textit{HMAC-based Extract-and-Expand Key Derivation Function (HKDF)}.
RFC 5869.

\bibitem{rfc8018}
Moriarty, K., Kaliski, B., \& Rusch, A. (2017).
\textit{PKCS \#5: Password-Based Cryptography Specification Version 2.1}.
RFC 8018.

\bibitem{rfc8032}
Josefsson, S., \& Liusvaara, I. (2017).
\textit{Edwards-Curve Digital Signature Algorithm (EdDSA)}.
RFC 8032.

\bibitem{rfc8017}
Moriarty, K., Kaliski, B., Jonsson, J., \& Rusch, A. (2016).
\textit{PKCS \#1: RSA Cryptography Specifications Version 2.2}.
RFC 8017.

\bibitem{fips197}
National Institute of Standards and Technology. (2001).
\textit{Advanced Encryption Standard (AES)}.
FIPS PUB 197.

\bibitem{nist-sp800-38d}
Dworkin, M. (2007).
\textit{Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC}.
NIST Special Publication 800-38D.

\bibitem{wikipedia-shamir}
Wikipedia. \textit{Shamir's Secret Sharing}.
\url{https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing}

\bibitem{wikipedia-hmac}
Wikipedia. \textit{HMAC}.
\url{https://en.wikipedia.org/wiki/HMAC}

\bibitem{wikipedia-hkdf}
Wikipedia. \textit{HKDF}.
\url{https://en.wikipedia.org/wiki/HKDF}

\bibitem{wikipedia-pbkdf2}
Wikipedia. \textit{PBKDF2}.
\url{https://en.wikipedia.org/wiki/PBKDF2}

\bibitem{wikipedia-ed25519}
Wikipedia. \textit{Ed25519}.
\url{https://en.wikipedia.org/wiki/Ed25519}

\bibitem{wikipedia-rsa}
Wikipedia. \textit{RSA (cryptosystem)}.
\url{https://en.wikipedia.org/wiki/RSA_(cryptosystem)}

\bibitem{wikipedia-oaep}
Wikipedia. \textit{Optimal asymmetric encryption padding}.
\url{https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding}

\bibitem{wikipedia-aes}
Wikipedia. \textit{Advanced Encryption Standard}.
\url{https://en.wikipedia.org/wiki/Advanced_Encryption_Standard}

\bibitem{wikipedia-gcm}
Wikipedia. \textit{Galois/Counter Mode}.
\url{https://en.wikipedia.org/wiki/Galois/Counter_Mode}

\end{thebibliography}

\end{document}